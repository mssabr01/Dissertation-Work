
==================== FINAL INTERFACE ====================
2018-12-23 21:11:53.635207 UTC

interface main@main:CapDL.MakeModel 8002
  interface hash: 39552e0298a5db4af33a090886ba9725
  ABI hash: 93ac63a43286fb2732207161250a4435
  export-list hash: 34904194f7dd667ceaa063449653d2aa
  orphan hash: f396be2e94005cd66cb8097632fd4c1a
  flag hash: a285d281843002008f986e4fe011c128
  sig of: Nothing
  used TH splices: False
  where
exports:
  CapDL.MakeModel.addCDTCapDecl
  CapDL.MakeModel.addCDTCapDecls
  CapDL.MakeModel.addCDTMapping
  CapDL.MakeModel.addCDTMappings
  CapDL.MakeModel.addCap
  CapDL.MakeModel.addCapCopies
  CapDL.MakeModel.addCapCopy
  CapDL.MakeModel.addCapCopyDecl
  CapDL.MakeModel.addCapCopyDecls
  CapDL.MakeModel.addCapCopyRef
  CapDL.MakeModel.addCapCopyRefs
  CapDL.MakeModel.addCapDecl
  CapDL.MakeModel.addCapDecls
  CapDL.MakeModel.addCapIdent
  CapDL.MakeModel.addCapIdentMapping
  CapDL.MakeModel.addCapIdentMapping'
  CapDL.MakeModel.addCapIdentMappings
  CapDL.MakeModel.addCovered
  CapDL.MakeModel.addIRQ
  CapDL.MakeModel.addIRQMapping
  CapDL.MakeModel.addIRQMappings
  CapDL.MakeModel.addIRQNode
  CapDL.MakeModel.addIRQNodes
  CapDL.MakeModel.addIRQs
  CapDL.MakeModel.addMapping
  CapDL.MakeModel.addMappings
  CapDL.MakeModel.addObject
  CapDL.MakeModel.addObjects
  CapDL.MakeModel.addUTCover
  CapDL.MakeModel.addUTCovers
  CapDL.MakeModel.addUTDecl
  CapDL.MakeModel.addUTDecls
  CapDL.MakeModel.addUTName
  CapDL.MakeModel.addUTNames
  CapDL.MakeModel.addUntyped
  CapDL.MakeModel.addUntypeds
  CapDL.MakeModel.baseName
  CapDL.MakeModel.capCopyGraph
  CapDL.MakeModel.capIdents
  CapDL.MakeModel.capOf
  CapDL.MakeModel.capOf'
  CapDL.MakeModel.capsOf
  CapDL.MakeModel.checkSlot
  CapDL.MakeModel.containsConstr
  CapDL.MakeModel.copyCapParams
  CapDL.MakeModel.empty
  CapDL.MakeModel.emptyIdents
  CapDL.MakeModel.emptyModel
  CapDL.MakeModel.emptyUntyped
  CapDL.MakeModel.funUpd
  CapDL.MakeModel.getARMIODevice
  CapDL.MakeModel.getAsid
  CapDL.MakeModel.getBadge
  CapDL.MakeModel.getBitSize
  CapDL.MakeModel.getCDTDecl
  CapDL.MakeModel.getCDTDecls
  CapDL.MakeModel.getCached
  CapDL.MakeModel.getCapCopies
  CapDL.MakeModel.getCapCopy
  CapDL.MakeModel.getCapCopyDecl
  CapDL.MakeModel.getCapCopyDecls
  CapDL.MakeModel.getCore
  CapDL.MakeModel.getDeclOrSlotRef
  CapDL.MakeModel.getDomainID
  CapDL.MakeModel.getExtraInfo
  CapDL.MakeModel.getFaultEP
  CapDL.MakeModel.getGuard
  CapDL.MakeModel.getGuardSize
  CapDL.MakeModel.getIOAPICIrqIoapic
  CapDL.MakeModel.getIOAPICIrqLevel
  CapDL.MakeModel.getIOAPICIrqPin
  CapDL.MakeModel.getIOAPICIrqPolarity
  CapDL.MakeModel.getInitArguments
  CapDL.MakeModel.getLevel
  CapDL.MakeModel.getMSIIrqHandle
  CapDL.MakeModel.getMSIIrqPCIBus
  CapDL.MakeModel.getMSIIrqPCIDev
  CapDL.MakeModel.getMSIIrqPCIFun
  CapDL.MakeModel.getMasked
  CapDL.MakeModel.getMaybeAsid
  CapDL.MakeModel.getMaybeBitSize
  CapDL.MakeModel.getMaybeFill
  CapDL.MakeModel.getMaybeMapping
  CapDL.MakeModel.getMaybePaddr
  CapDL.MakeModel.getPCIDevice
  CapDL.MakeModel.getPorts
  CapDL.MakeModel.getReplys
  CapDL.MakeModel.getRights
  CapDL.MakeModel.getSCBudget
  CapDL.MakeModel.getSCData
  CapDL.MakeModel.getSCExtraInfo
  CapDL.MakeModel.getSCPeriod
  CapDL.MakeModel.getSlot
  CapDL.MakeModel.getSlotIRQs
  CapDL.MakeModel.getSrcCap
  CapDL.MakeModel.getTCBAddr
  CapDL.MakeModel.getTCBDom
  CapDL.MakeModel.getTCBaffinity
  CapDL.MakeModel.getTCBelf
  CapDL.MakeModel.getTCBip
  CapDL.MakeModel.getTCBmax_prio
  CapDL.MakeModel.getTCBprio
  CapDL.MakeModel.getTCBsp
  CapDL.MakeModel.getUTCov
  CapDL.MakeModel.getUTObj
  CapDL.MakeModel.getUntypedCover
  CapDL.MakeModel.getUntypedCovers
  CapDL.MakeModel.getVMSize
  CapDL.MakeModel.hasCopy
  CapDL.MakeModel.hasUnnumbered
  CapDL.MakeModel.insertCDT
  CapDL.MakeModel.insertCapIdentMapping
  CapDL.MakeModel.insertMapping
  CapDL.MakeModel.insertMappings
  CapDL.MakeModel.insertObjects
  CapDL.MakeModel.isMember
  CapDL.MakeModel.isUntyped
  CapDL.MakeModel.makeIDs
  CapDL.MakeModel.makeModel
  CapDL.MakeModel.members
  CapDL.MakeModel.numConstrs
  CapDL.MakeModel.numObject
  CapDL.MakeModel.objCapOf
  CapDL.MakeModel.objectOf
  CapDL.MakeModel.orderedSubset
  CapDL.MakeModel.printID
  CapDL.MakeModel.putSlot
  CapDL.MakeModel.qNames
  CapDL.MakeModel.refToID
  CapDL.MakeModel.refToIDs
  CapDL.MakeModel.removeConstr
  CapDL.MakeModel.sameName
  CapDL.MakeModel.slotRefToCapRef
  CapDL.MakeModel.slotsAndCapsOf
  CapDL.MakeModel.sortConstrs
  CapDL.MakeModel.subsetConstrs
  CapDL.MakeModel.transMapping
  CapDL.MakeModel.transMappingE
  CapDL.MakeModel.unrange
  CapDL.MakeModel.validCapPars
  CapDL.MakeModel.validCapPars'
  CapDL.MakeModel.validMapping
  CapDL.MakeModel.validObjPars
  CapDL.MakeModel.CapRefMappings
  CapDL.MakeModel.SlotState
module dependencies: CapDL.AST CapDL.Model CapDL.State
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      pretty-1.1.3.3@pretty-1.1.3.3
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Data da440c60016500822a3d4307ca5dea66
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:Data.Word 77f42e01d0fb6b071f1ea2176d87fa6c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:GHC.Word 2f8cb4e909eeef2f95e1563807dd9268
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22:Data.List.Compat 418dd9bb7e30a0545524709bdb407f11
import  -/  base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22:Prelude.Compat 26d0dbb9ddc9475bb1179736f86de98b
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 192db525847d66243089501d3ee84714
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 318df275d77dcdb18e0006d8d7870c2a
import  -/  CapDL.AST f4e424cb2594d82c83adfc3fa04a31a3
  exports: a5bc172604bc9e0b84a19cb1123d06cf
  ARMIOSpace 1529ef04563d799297975baa06487334
  Addr 3fe6a1bab163898b890b8152f6c93dfd
  Affinity ed95facf5fe7511897fcccf710888539
  All 1a7ac73eacea07b77075f4385521efd7
  Asid da550fdc6e7331b37c321e2a4e1ee90d
  Badge fa2123d84190fdc6a5e87628d3cbd79a
  BitSize 1f1a94d03a373e2f3da0995b9bfe90e7
  Budget 05479879dc979efa9a50a3a9eb025ce2
  CDTDecl f22ed2e17934355627e0bac2790e7a67
  Cached 4e34df1d0986f18a219b571b37d97f0a
  CapDecl ea81bdf4e19b0e0214d6d7741dabd110
  CapMapping db48763d0d9a9f24ba2ff6aa68d94787
  CapMapping 6f333562637ba8a5d02ee9b310f593a5
  CapNameDecl b11375ca0a45e78b74e63d4180ed1a0b
  CapParam 78e1501056c1ccef1e4ef1413b54a0c8
  CopyOf 2c276132d23e1b457557c3d8ffc9513c
  Core ec2eb1707241f5d51ad81991dff37c83
  Decl 8f7df8173f53c7ba9e17b58715798d32
  Dom 46e6a3f50165c183a504cf6ef3dbf3cb
  DomainID 3b20e5fb5efd627ff78ff952a1c9c35a
  Elf ad736d7388861c66e5cd633c94174ff5
  FaultEP 4cf082586ab199ba374a7511bb35c691
  Fill 3195263bba31977210a7085eb38d54af
  FrameExtraParam a1f9aca57e16a4336afefab46db9dadb
  FrameMapping b7ec4c1fb7599c5b14c1284d359edb24
  From e294795f7e49512ce5b6686ff87fff06
  FromTo 8e9f18bfe66099761ade7b7367b08967
  Guard f994acdd156d03b4fa99fc5d6759bdc8
  GuardSize b85a340f77d7c3a406b5b7d1dc6d1028
  IOAPIC 6affdcf487a4cddafb52cb2462ca3431
  IOAPICIRQExtraParam 5a4b79f9bafa793ada3fff7e41bf375d
  IOPTLevel 1399fa99a99a3e339df6c641cd5caa62
  IP fd8d47ac750f3445ccab135a68292e67
  IRQDecl 8592477763454e4d03b2eb89b22ab14e
  IRQMapping 27d99bfc3184ed88adb49dc24c9eae8c
  InitArguments 2c96e5c8309ecc4651d01d866051ae8b
  KO 519e5ee713264da3f66ce82e6106a9de
  KODecl a77b29e6ef85f645bae140ad15b5e98e
  Level a0f12f5f0d7d88eaaeb62071bce08141
  MSIHandle cbb6848ce8a0adc1c7215bba1c4afb78
  MSIIRQExtraParam abf068b78123b7a6e4501d98e1314766
  MSIPCIBus f469c7e3c8f276d24068e616610471ed
  MSIPCIDev 17a47c647bc4b285744597792a9a81e8
  MSIPCIFun 14c1d1cd4c9e56719952473e14159b78
  Masked f6413c3398bdd808fadb5d0e31bc08dd
  MasterReply 6a977f21f1d096a56cb9eec4d99692f3
  MaxPrio b9bb9967a6e51281065c258451cf1f19
  Module c0c8edf7fa2a6725c3bedd81df851bde
  Module 73de65ddd075a145d2849201c98ab8bf
  Name a2810da6ca6e8f0c509e387b6c1140d9
  NameRef adfb5fef568a67640f1355469089264d
  Obj 1ce085730dbe5de4337a59e25fc61521
  ObjDecl 46902648a63be12f5207f705ddf0095c
  ObjParam c9bd94a581800fbb5b80072a4c9344c7
  Only 83722f2110d7166982e12b17a265789a
  PCIDevice ec215489e532821a6096e0bc7361b575
  Paddr 07ad9f6e85c6fc4e947b4022883602da
  Period 67c71ba969bdf09e6c6238262acc6b19
  Pin af441b619b9a221c2c2547645862a7ef
  Polarity 34afca5abecc37214674970a2ebc995c
  Ports f23d1823a9a7c7e841be911fafdbcbbd
  Prio 2f95ecc2cc302547c2d4604af18f8aba
  QName 61118e720f7ecb8253135a1baef3438a
  Range 3578ccc8a9d40f34b37cc824007f79f9
  Reply c9410c1573ebe83a8ca5807e718d54b6
  Rights c94d4cda92eb30d8f5e7ec5d4a36a7f8
  SCData b3181eac94a4ddbf53d84a42b1b75a9d
  SCExtraParam 82825cc70aa17fd54452a319ba9770d7
  SP b4db0eb2a992896fd5a1e2daa13c37ee
  SlotRef 745ddbab1ba029dfb54b3f3247de45c5
  TCBExtraParam a9a4c6cf58627f52602f5aa4a448d0f7
  To a98a7cd7f0b4cce391f54842c2ab373e
  VMSize e8b39f2f6e1328c5230a0339c4ddd005
  koType 907025394d40cf60529857b60e8f5297
  maybeParent 15c77b16e8020203a5022f8de1784c9d
  objDecls 09dd1a62eca6631ad431752fe549a29d
  params 273124c8de0436a7936559df9f5bed58
  slot dd1d66ffe198bb7f04b9aef06d0abd75
import  -/  CapDL.Model 8e26b32fabef412aa2e46767667c26cb
  exports: 194cc77771ecdac5cfada74519b29912
  ARMIODevice 8d08fd1166b8de2048c52e2b9ba46fc9
  ARMIODevice_T 599f9fcaf92961056c4cc646fbff4f97
  ARMIOSpaceCap 244266543b9bb53794fb556e30a4fa22
  ASIDControlCap a3104e7f04f2308bce70b72a9539f64c
  ASIDPool ba5104d1532a081bc49c891060909aeb
  ASIDPoolCap 220dabb0361563f94fe2205d48394fdd
  ASIDPool_T b671a907c79754d0df1e018dc6b8950d
  Asid 6f3133939880369b522965111423cea0
  CDT 55973b7d1a84f9de6a8a38ae41e41412
  CNode 693211dc12ef4126b116f6e95fe7e75f
  CNodeCap 590fd2c6f6ecf22b2eeebcb996881e19
  CNode_T 468124b4eb5837ca3ee0b172e04091e4
  Cap 2a21d35a68336a201f9362f96f90a464
  CapName 7f6708f4412dcdf3921e3fc30ed248e0
  CapRef 577051ad5ff1ec257c722ca2a90ffb32
  CapRights fee87d5c49f4692c15b6de86f85fa1c8
  CopyMap 30d06829776f11b94c33c433c23696ba
  CoverMap 478d8c578699fc12ee5d1852b54284c2
  DomainCap 206cd7d1fdbf05217e0afd4b921ec586
  Endpoint c7cea90dd68aeb74658e3b6beaf32a8c
  EndpointCap de93c9c099a382fb6d594d38dffc515f
  Endpoint_T 0103099ef460e7ce58411a9d0616b799
  Frame a1a72eb2098660223f462524f6d64cf1
  FrameCap 358500e6ad48a24c1af7b4eeb9abeeaa
  Frame_T 713a80bd39eafdccf4bd9a6d79beb900
  IOAPICIrq 9f24f8ed20ffbab428657aae84561aad
  IOAPICIrqSlot_T 80e0f7a144e9d7021dce388ca2ff895b
  IODevice f669911d54b94953bc180cecc4b80eea
  IODevice_T ab0566da36d763cc5c5a1a7313820aed
  IOPT 1988dd5bdc0c2470efd93a0d63e68922
  IOPTCap eeb4d7ba3197f880fcb4c3b77fe2bc10
  IOPT_T bfbcbf62586a2b16bef1ea108e5922b7
  IOPorts 49268bae7609d49418f5b50e0677c646
  IOPortsCap 377691fc07b5c1d255b3fc9dda6ec5ae
  IOPorts_T d4a31ca77a94ca320eef79df2bda4155
  IOSpaceCap 6673a14c764d87aa3a2ba80ca2d617d4
  IOSpaceMasterCap df07f42b3a4dffbb476c3f95a4616c55
  IRQControlCap babd09b93c0c2ddc43877f1de09ef9b3
  IRQHandlerCap 3f111314ce395ab293e006573af72663
  IRQIOAPICHandlerCap 7de4cff137d170defd36aaf06926d5ae
  IRQMSIHandlerCap 26b9b7fb929e0c2f4ebda5b275885208
  IRQMap 49498d7e37e25c2f2cd49bbacdd33a00
  Idents 556419a76562862a21de9f262a19ec65
  Idents f96b2f5fbb7738b3c6c33245caa3a364
  IrqSlot_T 549042eea807814af40b64d1c373d35d
  KernelObject 74facc4ab534e001bd4ca07a143628e7
  MSIIrq 7807e4bd04f2b57c12200eeed8d32cd1
  MSIIrqSlot_T e11b94044ec48c858435f8098ed9eeef
  MasterReplyCap 8d2e215096b21052f109b41a538449e6
  Model df1f00d4fc6384f8455b17f2f30da3ed
  Model 589b7c47d95fa3c92cab05c02d9ec104
  Notification 7bfb9587626e7f2e148fb306f316d71e
  NotificationCap 063382f0af99af375a364faf442ece26
  Notification_T 6e218f8732a4a2298542d80c713aa521
  NullCap 8c7613d0a705ef268c687dd8eecdf246
  ObjID 79624deef3a276329daf8841ec6c4e4b
  ObjMap 4211baa280b570e4c761bd30aa346582
  ObjSet 111c787764dac1efc754aa81b5769320
  PD a3f7eeb64b66c2523cdbb5294fc559f8
  PDCap a94a62f40927fc7b39a00d764e98d22d
  PDPT c05bab1de4197b6570ed51849b26fbe2
  PDPTCap da168249856e97a7ec7799fc57050a3d
  PDPT_T d90c90163da7b8d081d208a36bfd6c3a
  PD_T e601f2030044f920e821cf948c7c4890
  PGD c636cf4902f9f85b500efdb960d51164
  PGDCap 13b6ea7c08f70d272ef7dde0819f0eb7
  PGD_T 43727f9bf763053d937ae1e0aa9d8574
  PML4 9fb7f4f98ca95bc9722aa291c7cf87e8
  PML4Cap 3c7b81cf4fe38138c153a3ebec74925a
  PML4_T 0a9facae3d6263a15031bd9681ec63be
  PT 47267c52f19b6b6c3dc0112098310e54
  PTCap 1264048166584f595250e46b1190742c
  PT_T 1119ee50cfdd3c370e13d27f5e21dc9a
  PUD 6b9a2fb014f7e9737d85cbf5fa5b2a67
  PUDCap f060a900c8c1100c942bd75887e983cb
  PUD_T 3b00b8a3f3c76a89ab799c4689065ff3
  RTReply d0ea798641d6a73ce7571d1e08711c4c
  RTReplyCap 0c5f43140b19aae3ce24409078489145
  RTReply_T 2ed06a99420445f4cd797b757c11c36f
  ReplyCap a5ef6bb715de4ce692cfb4d00d75748a
  SC 281c858ee2e9992504088a82b2e1efe8
  SCCap 491f26c4528f4790d9f8d78bc359d796
  SCExtraInfo 4e6ceab6c64e92c8c353507f1379b199
  SCExtraInfo 366cc09a485b95c7479948ee37508363
  SC_T 815944868db889e6e2b25df1777c9cb5
  SchedControlCap 800551c2b0416e5048788d34d608fac4
  TCB 226edd638c439891141a4bdf9d407698
  TCBCap 381122f5a4889633fde5616ee62a3ac6
  TCBExtraInfo 6ca71812d051d54a572613f888b12f0b
  TCBExtraInfo 9a1a1a6fafb3bdcb24b646113e179c74
  TCB_T d63337a7c5175657c7e46b348ff4469d
  Untyped 1ea9c340003fffbd6472826ee10b2a82
  UntypedCap c2e82114d9b1d6f0e2c295de577bf108
  Untyped_T 7f14fc8ec45b426989dad4ee2feb0c9b
  VCPU a3f204f39160fa01138f5aaea2a49d4b
  VCPUCap a5d4385f5f4a97cb20ff1809b8ec787c
  VCPU_T c6aef7b7b19f6775a9484bcef06ea711
  allRights 7de37506685362797532f861a1ab6a62
  asidControl 9a39dbd32f13c94c6bd04f1c15c0a2a3
  capRights 64e6a41c777718fb450d946ae4678e9b
  capStrings c5ed03d000ade3b2b20f95c593b817e1
  cap_ids 327643484b46167a10182f9ba955edac
  domain b8cc9fff8b13c65e15770f5d957b37b1
  hasRights 1f0e1c3ff796c14f610b2de9e305e438
  hasSlots 727f06887ba2c03ce0cad4cdb044263e
  ioSpaceMaster 2c313766acac4ab7bfacf717a93cff90
  irqControl 887a55db1b1ebbe922ac3e5b9984bebc
  schedControl f3374ce32e92018dc523ff1b74a4564e
  slots 0503d6fc6bb18b62d855ae9d996073f2
import  -/  CapDL.State fa4e01b6464f59636102c2c595e82527
  exports: ad43b37a513c35266b5b5dfd897c0f17
  maybeSlotCap fd5f7bd0d6fbfb6bea5598fb1f6bb54e
  setCap f20304c3b2438b6f6b38737a670970d6
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
1f61b2da4a76dead0be753261f1c6e40
  $s$fEq(,) ::
    GHC.Classes.Eq ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     CapDL.MakeModel.$s$fEq(,)_$dEq
                     CapDL.MakeModel.$s$fEq(,)_$dEq1)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     CapDL.MakeModel.$s$fEq(,)_$dEq
                     CapDL.MakeModel.$s$fEq(,)_$dEq1) -}
7dee3f2badb02258b2455d892c5bd25d
  $s$fEq(,)1 ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Word)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqWord a1 b1 } }) -}
328a8a83a7ee327906e7e405b3b6bec3
  $s$fEq(,)2 ::
    GHC.Classes.Eq
      ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                     GHC.Types.Word)
                  (GHC.Classes.$fEq(,)_$c==
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.MakeModel.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
                     CapDL.MakeModel.$s$fEq(,)_$dEq2)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.MakeModel.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
                     CapDL.MakeModel.$s$fEq(,)_$dEq2) -}
23fe3e95be49373fc51c34fbdb7f9ecf
  $s$fEq(,)_$dEq :: GHC.Classes.Eq [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
895a3ee8ffb99cc169d3eae5fb4fe6bd
  $s$fEq(,)_$dEq1 :: GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.$s$fEq(,)_$s$fEqMaybe -}
41f56b57aaaf9be0462f93c9e069e325
  $s$fEq(,)_$dEq2 :: GHC.Classes.Eq GHC.Types.Word
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GHC.Classes.$fEqWord -}
c72f484af0625cc04162ee91630fad1b
  $s$fEq(,)_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Word)
                  CapDL.MakeModel.$s$fEq(,)1
                  (GHC.Base.$fEqMaybe_$c/=
                     @ GHC.Types.Word
                     CapDL.MakeModel.$s$fEq(,)_$dEq2) -}
7939eeca1d435554479006e6caf8e7e4
  $s$fEq(,)_$s$fOrd(,)_$cp1Ord ::
    GHC.Classes.Eq ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) CapDL.MakeModel.$s$fEq(,) -}
f8fb61e14f84ae7a8358d69765ea6320
  $sinsert_$s$w$sgo1 ::
    Data.Set.Base.Set ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> GHC.Types.Word
    -> [GHC.Types.Char]
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
d269c93d31a264f34d4770b3d8fd9e11
  $sinsert_$s$w$sgo10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
        GHC.Types.Word)
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map
         CapDL.Model.ObjID (CapDL.Model.ObjID, GHC.Types.Word)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
c9d2986c635bf872e15e0930a4a1e83a
  $sinsert_$s$w$sgo2 ::
    Data.Set.Base.Set ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> [GHC.Types.Char] -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 2, Strictness: <S,1*U><L,U> -}
58161ac609f84cecaaa52f87620d025f
  $sinsert_$s$w$sgo3 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1
    -> a1
    -> GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
dc0b5609021d86357d0fbb938762a775
  $sinsert_$s$w$sgo4 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1
    -> a1
    -> GHC.Types.Word
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
8751bd424cf820ae9de7679b016431a2
  $sinsert_$s$w$sgo5 ::
    Data.Set.Base.Set ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
ec6dbf359d8b71f5b14c7f69e0593a52
  $sinsert_$sgo1 ::
    CapDL.Model.ObjID
    -> a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 3, Strictness: <S,1*U(U,U)><L,U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: CapDL.Model.ObjID)
                   (w1 :: a1)
                   (w2 :: Data.Map.Base.Map CapDL.Model.ObjID a1) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$w$sgo1 @ a1 ww1 ww2 w1 w2 }) -}
2599278241e07a16f19a6a1a055d51f7
  $sinsert_$sgo5 ::
    CapDL.Model.ObjID
    -> Data.Set.Base.Set CapDL.Model.ObjID
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: Data.Set.Base.Set CapDL.Model.ObjID) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$w$sgo5 ww1 ww2 w1 }) -}
bb58a20d32d1a8b76d9aced367072db5
  $slookup3 ::
    CapDL.Model.ObjID
    -> Data.Map.Base.Map CapDL.Model.ObjID a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: CapDL.Model.ObjID)
                   (w1 :: Data.Map.Base.Map CapDL.Model.ObjID a) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wpoly_go1 @ a ww1 ww2 w1 }) -}
36c1df7d618c7a896ad8c7178fc34241
  $slookup_$s$wpoly_go1 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> [GHC.Types.Char]
    -> GHC.Base.Maybe (CapDL.Model.ObjID, GHC.Types.Word)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
e55842fc8822960e9c98ffa61c4efe16
  $slookup_$s$wpoly_go10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> GHC.Types.Word
    -> [GHC.Types.Char]
    -> GHC.Base.Maybe (CapDL.Model.ObjID, GHC.Types.Word)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
b2c5dc818a507351a88d36527bae1138
  $slookup_$s$wpoly_go2 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> GHC.Base.Maybe (CapDL.Model.ObjID, GHC.Types.Word)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
29ddc126e272288d183a710059148229
  $smember_$s$wpoly_go1 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (CapDL.Model.KernelObject GHC.Types.Word)
    -> GHC.Prim.Word# -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
225b6c7b5fbb9feda920daee8e3593a1
  $smember_$s$wpoly_go10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (CapDL.Model.KernelObject GHC.Types.Word)
    -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
ca2e22804c729d0073a47b0ec98fba2b
  $smember_$s$wpoly_go2 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a
    -> GHC.Types.Word -> [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
81ddbb9821373cda88493612a81edef5
  $sput ::
    s
    -> Control.Monad.Trans.State.Lazy.StateT
         s Data.Functor.Identity.Identity ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, False)
                (\ @ s (s1 :: s) ->
                 GHC.Base.$
                   @ 'GHC.Types.PtrRepLifted
                   @ (s -> ((), s))
                   @ (Control.Monad.Trans.State.Lazy.StateT
                        s Data.Functor.Identity.Identity ())
                   (Control.Monad.Trans.State.Lazy.state
                      @ Data.Functor.Identity.Identity
                      @ s
                      @ ()
                      Data.Functor.Identity.$fMonadIdentity)
                   (\ (ds :: s) -> (GHC.Tuple.(), s1))) -}
27c4588f85ea9fb6fffd1be8c6b983e9
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   CapDL.MakeModel.$trModule2
                   CapDL.MakeModel.$trModule1) -}
46d18734a19bb7e3312b48a24025cc58
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "CapDL.MakeModel"#) -}
c58f1d01c4d9eb4ddc0ec30937fe2053
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
d4e1fc83521498efef81427f66b17e6a
  $w$sgo1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
8f1d421d8d4624df27cbf11ba7b92917
  $w$sgo10 ::
    CapDL.Model.ObjID
    -> GHC.Types.Word
    -> a1
    -> Data.Map.Base.Map CapDL.Model.CapRef a1
    -> Data.Map.Base.Map CapDL.Model.CapRef a1
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><S,1*U>,
     Inline: [0] -}
cb2d2ef1018d22e5d6139a7f7f97fbf9
  $w$sgo2 ::
    GHC.Prim.Word#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Word a1
    -> Data.Map.Base.Map GHC.Types.Word a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
94d5929631dc0e48ebf1f77ca09fca72
  $w$sgo5 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> Data.Set.Base.Set CapDL.Model.ObjID
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
e33625d4951a185a110b080daf645970
  $waddCDTMappings ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CDT
    -> CapDL.Model.ObjID
    -> [CapDL.AST.CapMapping]
    -> CapDL.MakeModel.SlotState CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,U(U)><L,U><L,U(U,U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.CDT)
                   (ww :: CapDL.Model.ObjID)
                   (ww1 :: [CapDL.AST.CapMapping]) ->
                 letrec {
                   go4 :: [CapDL.AST.CapMapping]
                          -> CapDL.Model.CDT
                          -> Control.Monad.Trans.State.Lazy.StateT
                               GHC.Types.Word Data.Functor.Identity.Identity CapDL.Model.CDT
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [CapDL.AST.CapMapping]) (eta :: CapDL.Model.CDT) ->
                     case ds of wild {
                       []
                       -> (GHC.Tuple.(,) @ CapDL.Model.CDT @ GHC.Types.Word eta)
                            `cast`
                          (Trans
                               (<GHC.Types.Word>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                              <(CapDL.Model.CDT, GHC.Types.Word)>_R))
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <GHC.Types.Word>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <CapDL.Model.CDT>_N)))
                       : y ys
                       -> let {
                            m1 :: Control.Monad.Trans.State.Lazy.StateT
                                    GHC.Types.Word Data.Functor.Identity.Identity CapDL.Model.CDT
                            = CapDL.MakeModel.addCDTMapping w ww eta y
                          } in
                          (\ (s1 :: GHC.Types.Word) ->
                           let {
                             ds1 :: Data.Functor.Identity.Identity
                                      (CapDL.Model.CDT, GHC.Types.Word)
                             = m1
                                 `cast`
                               (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CapDL.Model.CDT>_N)
                                 s1
                           } in
                           (go4
                              ys
                              (case ds1
                                      `cast`
                                    (Data.Functor.Identity.N:Identity[0]
                                         <(CapDL.Model.CDT,
                                           GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                               a1 }))
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <GHC.Types.Word>_N
                                <Data.Functor.Identity.Identity>_R
                                <CapDL.Model.CDT>_N)
                             (case ds1
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(CapDL.Model.CDT,
                                          GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                              s' }))
                            `cast`
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CapDL.Model.CDT>_N)) }
                 } in
                 go4 ww1 w1) -}
874240093eade6c5543fee7d8cc4b49b
  $waddCap ::
    CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> [CapDL.AST.CapMapping]
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 8, Strictness: <L,U><S,U><L,U><L,U><L,U><L,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.Arch)
                   (ww1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww2 :: CapDL.Model.IRQMap)
                   (ww3 :: CapDL.Model.CDT)
                   (ww4 :: CapDL.Model.CoverMap)
                   (ww5 :: GHC.Base.String)
                   (ww6 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww7 :: [CapDL.AST.CapMapping]) ->
                 case CapDL.MakeModel.$wpoly_go1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww5
                        ww6
                        ww1 of wild {
                   GHC.Base.Nothing
                   -> case CapDL.MakeModel.addCap2 ww5 ww6
                      ret_ty (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
                                CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
                      of {}
                   GHC.Base.Just obj
                   -> case CapDL.MakeModel.hasCopy ww7 of wild1 {
                        GHC.Types.False
                        -> (# ww,
                              CapDL.MakeModel.$w$sgo1
                                @ (CapDL.Model.KernelObject GHC.Types.Word)
                                ww5
                                ww6
                                (case ((CapDL.MakeModel.addMappings ww1 (ww5, ww6) obj ww7)
                                         `cast`
                                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                            <GHC.Types.Word>_N
                                            <Data.Functor.Identity.Identity>_R
                                            <CapDL.Model.KernelObject GHC.Types.Word>_N)
                                         CapDL.MakeModel.addCDTCapDecl1)
                                        `cast`
                                      (Data.Functor.Identity.N:Identity[0]
                                           <(CapDL.Model.KernelObject GHC.Types.Word,
                                             GHC.Types.Word)>_R) of wild2 { (,) x4 ds1 ->
                                 x4 })
                                ww1,
                              ww2, ww3, ww4 #)
                        GHC.Types.True
                        -> case CapDL.MakeModel.hasUnnumbered ww7 of wild2 {
                             GHC.Types.False
                             -> (# ww,
                                   CapDL.MakeModel.$w$sgo1
                                     @ (CapDL.Model.KernelObject GHC.Types.Word)
                                     ww5
                                     ww6
                                     (case ((CapDL.MakeModel.addMappings ww1 (ww5, ww6) obj ww7)
                                              `cast`
                                            (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                 <GHC.Types.Word>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <CapDL.Model.KernelObject GHC.Types.Word>_N)
                                              CapDL.MakeModel.addCDTCapDecl1)
                                             `cast`
                                           (Data.Functor.Identity.N:Identity[0]
                                                <(CapDL.Model.KernelObject GHC.Types.Word,
                                                  GHC.Types.Word)>_R) of wild3 { (,) x4 ds1 ->
                                      x4 })
                                     ww1,
                                   ww2, ww3, ww4 #)
                             GHC.Types.True
                             -> case CapDL.MakeModel.addCap1 ww5 ww6
                                ret_ty (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
                                          CapDL.Model.IRQMap, CapDL.Model.CDT,
                                          CapDL.Model.CoverMap #)
                                of {} } } }) -}
67d4b4bdd86a681595913b825fd9d697
  $waddCapCopies ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.AST.Name
    -> [CapDL.AST.Range]
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> CapDL.AST.CapMapping
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 10,
     Strictness: <L,U(U)><L,C(U)><L,U><S,1*U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (ww :: CapDL.AST.Name)
                   (ww1 :: [CapDL.AST.Range])
                   (ww2 :: CapDL.Model.Arch)
                   (ww3 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww4 :: CapDL.Model.IRQMap)
                   (ww5 :: CapDL.Model.CDT)
                   (ww6 :: CapDL.Model.CoverMap)
                   (w2 :: CapDL.AST.CapMapping) ->
                 letrec {
                   $wgo2 :: [CapDL.Model.ObjID]
                            -> CapDL.Model.Arch
                            -> CapDL.Model.ObjMap GHC.Types.Word
                            -> CapDL.Model.IRQMap
                            -> CapDL.Model.CDT
                            -> CapDL.Model.CoverMap
                            -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
                                  CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
                     {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U>,
                        Inline: [0] -}
                   = \ (w3 :: [CapDL.Model.ObjID])
                       (ww7 :: CapDL.Model.Arch)
                       (ww8 :: CapDL.Model.ObjMap GHC.Types.Word)
                       (ww9 :: CapDL.Model.IRQMap)
                       (ww10 :: CapDL.Model.CDT)
                       (ww11 :: CapDL.Model.CoverMap) ->
                     case w3 of wild {
                       [] -> (# ww7, ww8, ww9, ww10, ww11 #)
                       : y ys
                       -> case CapDL.MakeModel.$waddCapCopy
                                 w
                                 w1
                                 y
                                 ww7
                                 ww8
                                 ww9
                                 ww10
                                 ww11
                                 w2 of ww12 { (#,,,,#) ww13 ww14 ww15 ww16 ww17 ->
                          $wgo2 ys ww13 ww14 ww15 ww16 ww17 } }
                 } in
                 $wgo2
                   (CapDL.MakeModel.$wrefToIDs
                      @ (CapDL.Model.KernelObject GHC.Types.Word)
                      ww3
                      ww
                      ww1)
                   ww2
                   ww3
                   ww4
                   ww5
                   ww6) -}
4815dcaadd7bb66412213bd8f096f910
  $waddCapCopy ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.ObjID
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> CapDL.AST.CapMapping
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 9,
     Strictness: <L,U(U)><L,C(U)><L,U(U,U)><L,U><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0] -}
8070cbc46a219985c0002353c5afdbac
  $waddCapCopyDecl ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> CapDL.AST.Decl
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 8,
     Strictness: <L,U(U)><L,C(U)><L,U><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (ww :: CapDL.Model.Arch)
                   (ww1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww2 :: CapDL.Model.IRQMap)
                   (ww3 :: CapDL.Model.CDT)
                   (ww4 :: CapDL.Model.CoverMap)
                   (w2 :: CapDL.AST.Decl) ->
                 case w2 of wild {
                   DEFAULT -> (# ww, ww1, ww2, ww3, ww4 #)
                   CapDL.AST.CapDecl obj mappings
                   -> case mappings of wild1 {
                        [] -> (# ww, ww1, ww2, ww3, ww4 #)
                        : y ys
                        -> case obj of ww5 { (,) ww6 ww7 ->
                           case CapDL.MakeModel.$waddCapCopies
                                  w
                                  w1
                                  ww6
                                  ww7
                                  ww
                                  ww1
                                  ww2
                                  ww3
                                  ww4
                                  y of ww8 { (#,,,,#) ww9 ww10 ww11 ww12 ww13 ->
                           letrec {
                             $wgo2 :: [CapDL.AST.CapMapping]
                                      -> CapDL.Model.Arch
                                      -> CapDL.Model.ObjMap GHC.Types.Word
                                      -> CapDL.Model.IRQMap
                                      -> CapDL.Model.CDT
                                      -> CapDL.Model.CoverMap
                                      -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
                                            CapDL.Model.IRQMap, CapDL.Model.CDT,
                                            CapDL.Model.CoverMap #)
                               {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U>,
                                  Inline: [0] -}
                             = \ (w3 :: [CapDL.AST.CapMapping])
                                 (ww14 :: CapDL.Model.Arch)
                                 (ww15 :: CapDL.Model.ObjMap GHC.Types.Word)
                                 (ww16 :: CapDL.Model.IRQMap)
                                 (ww17 :: CapDL.Model.CDT)
                                 (ww18 :: CapDL.Model.CoverMap) ->
                               case w3 of wild2 {
                                 [] -> (# ww14, ww15, ww16, ww17, ww18 #)
                                 : y1 ys1
                                 -> case CapDL.MakeModel.$waddCapCopies
                                           w
                                           w1
                                           ww6
                                           ww7
                                           ww14
                                           ww15
                                           ww16
                                           ww17
                                           ww18
                                           y1 of ww19 { (#,,,,#) ww20 ww21 ww22 ww23 ww24 ->
                                    $wgo2 ys1 ww20 ww21 ww22 ww23 ww24 } }
                           } in
                           $wgo2 ys ww9 ww10 ww11 ww12 ww13 } } } }) -}
f8897e216f350f04f501081e1c46e8c9
  $waddCapCopyDecls ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> [CapDL.AST.Decl]
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 8,
     Strictness: <L,U(U)><L,C(U)><L,U><L,U><L,U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (ww :: CapDL.Model.Arch)
                   (ww1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww2 :: CapDL.Model.IRQMap)
                   (ww3 :: CapDL.Model.CDT)
                   (ww4 :: CapDL.Model.CoverMap)
                   (w2 :: [CapDL.AST.Decl]) ->
                 letrec {
                   $wgo2 :: [CapDL.AST.Decl]
                            -> CapDL.Model.Arch
                            -> CapDL.Model.ObjMap GHC.Types.Word
                            -> CapDL.Model.IRQMap
                            -> CapDL.Model.CDT
                            -> CapDL.Model.CoverMap
                            -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
                                  CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
                     {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U>,
                        Inline: [0] -}
                   = \ (w3 :: [CapDL.AST.Decl])
                       (ww5 :: CapDL.Model.Arch)
                       (ww6 :: CapDL.Model.ObjMap GHC.Types.Word)
                       (ww7 :: CapDL.Model.IRQMap)
                       (ww8 :: CapDL.Model.CDT)
                       (ww9 :: CapDL.Model.CoverMap) ->
                     case w3 of wild {
                       [] -> (# ww5, ww6, ww7, ww8, ww9 #)
                       : y ys
                       -> case CapDL.MakeModel.$waddCapCopyDecl
                                 w
                                 w1
                                 ww5
                                 ww6
                                 ww7
                                 ww8
                                 ww9
                                 y of ww10 { (#,,,,#) ww11 ww12 ww13 ww14 ww15 ->
                          $wgo2 ys ww11 ww12 ww13 ww14 ww15 } }
                 } in
                 $wgo2 w2 ww ww1 ww2 ww3 ww4) -}
64271e6537f7fef9b76bc6f47bb8dae5
  $waddCapCopyRef ::
    Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
    -> CapDL.Model.ObjID
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.CapRefMappings
  {- Arity: 4, Strictness: <L,1*U><L,U(U,U)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: Data.Map.Base.Map
                            CapDL.Model.CapName CapDL.Model.CapRef)
                   (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.AST.CapMapping) ->
                 case w2 of wild {
                   DEFAULT -> w1
                   CapDL.AST.CopyOf ds ds1 target ds2 ds3
                   -> case ds of wild1 {
                        GHC.Base.Nothing -> w1
                        GHC.Base.Just slot
                        -> let {
                             y :: GHC.Base.Maybe CapDL.Model.CapRef
                             = case target of ww1 { (,) ww2 ww3 ->
                               case ww3 of wild2 {
                                 [] -> CapDL.MakeModel.$slookup_$s$wpoly_go1 ww ww2
                                 : ds4 ds5
                                 -> case ds4 of wild3 {
                                      DEFAULT
                                      -> case CapDL.MakeModel.$wlvl ww2 wild2
                                         ret_ty (GHC.Base.Maybe (CapDL.Model.ObjID, GHC.Types.Word))
                                         of {}
                                      CapDL.AST.Only n2
                                      -> case ds5 of wild4 {
                                           [] -> CapDL.MakeModel.$slookup_$s$wpoly_go10 ww n2 ww2
                                           : ipv ipv1
                                           -> case CapDL.MakeModel.$wlvl ww2 wild2
                                              ret_ty (GHC.Base.Maybe
                                                        (CapDL.Model.ObjID, GHC.Types.Word))
                                              of {} } } } }
                           } in
                           \ (z :: CapDL.Model.CapRef) ->
                           case z of ww1 { (,) ww2 ww3 ->
                           case ww2 of ww4 { (,) ww5 ww6 ->
                           case w of ww7 { (,) ww8 ww9 ->
                           case GHC.Base.eqString ww5 ww8 of wild2 {
                             GHC.Types.False -> w1 ww1
                             GHC.Types.True
                             -> case ww6 of wild3 {
                                  GHC.Base.Nothing
                                  -> case ww9 of wild4 {
                                       GHC.Base.Nothing
                                       -> case ww3 of wild5 { GHC.Types.W# x4 ->
                                          case slot of wild6 { GHC.Types.W# y1 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.eqWord# x4 y1) of wild7 {
                                            GHC.Types.False -> w1 ww1 GHC.Types.True -> y } } }
                                       GHC.Base.Just ipv -> w1 ww1 }
                                  GHC.Base.Just a1
                                  -> case ww9 of wild4 {
                                       GHC.Base.Nothing -> w1 ww1
                                       GHC.Base.Just b1
                                       -> case a1 of wild5 { GHC.Types.W# x4 ->
                                          case b1 of wild6 { GHC.Types.W# y1 ->
                                          case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.eqWord# x4 y1) of wild7 {
                                            GHC.Types.False -> w1 ww1
                                            GHC.Types.True
                                            -> case ww3 of wild8 { GHC.Types.W# x5 ->
                                               case slot of wild9 { GHC.Types.W# y2 ->
                                               case GHC.Prim.tagToEnum#
                                                      @ GHC.Types.Bool
                                                      (GHC.Prim.eqWord# x5 y2) of wild10 {
                                                 GHC.Types.False -> w1 ww1
                                                 GHC.Types.True -> y } } } } } } } } } } } } } }) -}
13fd1c06155a917e69b5d37fd076649a
  $waddCapIdent ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
    -> CapDL.AST.Decl
    -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww :: Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef)
                   (w1 :: CapDL.AST.Decl) ->
                 case w1 of wild {
                   DEFAULT -> (# ww #)
                   CapDL.AST.CapDecl obj mappings
                   -> let {
                        k :: CapDL.Model.ObjID
                        = case obj of ww1 { (,) ww2 ww3 ->
                          case CapDL.MakeModel.$wrefToIDs
                                 @ (CapDL.Model.KernelObject GHC.Types.Word)
                                 w
                                 ww2
                                 ww3 of wild1 {
                            [] -> GHC.List.badHead @ CapDL.Model.ObjID : x4 ds1 -> x4 } }
                      } in
                      letrec {
                        $wgo2 :: [CapDL.AST.CapMapping]
                                 -> Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
                                 -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
                          {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                        = \ (w2 :: [CapDL.AST.CapMapping])
                            (ww1 :: Data.Map.Base.Map
                                      CapDL.Model.CapName CapDL.Model.CapRef) ->
                          case w2 of wild1 {
                            [] -> (# ww1 #)
                            : y ys
                            -> case CapDL.MakeModel.$waddCapIdentMapping
                                      w
                                      k
                                      ww1
                                      y of ww2 { Unit# ww3 ->
                               $wgo2 ys ww3 } }
                      } in
                      $wgo2 mappings ww
                   CapDL.AST.CapNameDecl name target slot
                   -> (# CapDL.MakeModel.$sinsert_$s$w$sgo10
                           ww
                           (case target of ww1 { (,) ww2 ww3 ->
                            case ww3 of wild1 {
                              [] -> (ww2, GHC.Base.Nothing @ GHC.Types.Word)
                              : ds ds1
                              -> case ds of wild2 {
                                   DEFAULT -> CapDL.MakeModel.$wlvl ww2 wild1
                                   CapDL.AST.Only n2
                                   -> case ds1 of wild3 {
                                        [] -> (ww2, GHC.Base.Just @ GHC.Types.Word n2)
                                        : ipv ipv1 -> CapDL.MakeModel.$wlvl ww2 wild1 } } } },
                            slot)
                           name #) }) -}
3675f85374d6b535e1095e1ec217132d
  $waddCapIdentMapping ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
    -> CapDL.AST.CapMapping
    -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (ww :: Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef)
                   (w2 :: CapDL.AST.CapMapping) ->
                 case w2 of wild {
                   DEFAULT -> (# ww #)
                   CapDL.AST.CapMapping ds ds1 ref ds2 ds3
                   -> case ds of wild1 {
                        GHC.Base.Nothing -> (# ww #)
                        GHC.Base.Just slot
                        -> case ds1 of wild2 {
                             GHC.Base.Nothing -> (# ww #)
                             GHC.Base.Just names
                             -> case names of ww1 { (,) ww2 ww3 ->
                                case ref of ww4 { (,) ww5 ww6 ->
                                CapDL.MakeModel.$waddCapIdentMapping'
                                  w
                                  w1
                                  ww
                                  slot
                                  ww2
                                  ww3
                                  ww5
                                  ww6 } } } }
                   CapDL.AST.CopyOf ds ds1 ref ds2 ds3
                   -> case ds of wild1 {
                        GHC.Base.Nothing -> (# ww #)
                        GHC.Base.Just slot
                        -> case ds1 of wild2 {
                             GHC.Base.Nothing -> (# ww #)
                             GHC.Base.Just names
                             -> case names of ww1 { (,) ww2 ww3 ->
                                case ref of ww4 { (,) ww5 ww6 ->
                                CapDL.MakeModel.$waddCapIdentMapping'
                                  w
                                  w1
                                  ww
                                  slot
                                  ww2
                                  ww3
                                  ww5
                                  ww6 } } } } }) -}
e73a1c15105ea020e65a9bf751a41a9c
  $waddCapIdentMapping' ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
    -> GHC.Types.Word
    -> CapDL.AST.Name
    -> [CapDL.AST.Range]
    -> CapDL.AST.Name
    -> [CapDL.AST.Range]
    -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
  {- Arity: 8,
     Strictness: <L,U><L,U><L,U><L,1*U(U)><L,U><S,1*U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (ww :: Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef)
                   (w2 :: GHC.Types.Word)
                   (ww1 :: CapDL.AST.Name)
                   (ww2 :: [CapDL.AST.Range])
                   (ww3 :: CapDL.AST.Name)
                   (ww4 :: [CapDL.AST.Range]) ->
                 case GHC.List.$wlenAcc
                        @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                        (CapDL.MakeModel.$wrefToIDs
                           @ (CapDL.Model.KernelObject GHC.Types.Word)
                           w
                           ww3
                           ww4)
                        0# of ww5 { DEFAULT ->
                 case ww2 of wild {
                   []
                   -> case ww5 of wild1 {
                        DEFAULT
                        -> case CapDL.MakeModel.addCapIdent2 ww1
                           ret_ty (# Data.Map.Base.Map
                                       CapDL.Model.CapName CapDL.Model.CapRef #)
                           of {}
                        1#
                        -> case w2 of wild2 { GHC.Types.W# x4 ->
                           case GHC.Enum.eftWord
                                  x4
                                  (GHC.Prim.minusWord# (GHC.Prim.plusWord# x4 1##) 1##) of wild3 {
                             [] -> (# ww #)
                             : y ys
                             -> (# CapDL.MakeModel.$sinsert_$s$w$sgo10 ww (w1, y) ww1 #) } } }
                   : ds ds1
                   -> case ds of wild1 {
                        DEFAULT
                        -> case CapDL.MakeModel.addCapIdent1
                           ret_ty (# Data.Map.Base.Map
                                       CapDL.Model.CapName CapDL.Model.CapRef #)
                           of {}
                        CapDL.AST.All
                        -> case ds1 of wild2 {
                             []
                             -> letrec {
                                  $wxs4 :: [GHC.Base.Maybe GHC.Types.Word]
                                           -> [GHC.Types.Word]
                                           -> Data.Map.Base.Map
                                                CapDL.Model.CapName CapDL.Model.CapRef
                                           -> (# Data.Map.Base.Map
                                                   CapDL.Model.CapName CapDL.Model.CapRef #)
                                    {- Arity: 3, Strictness: <S,1*U><L,1*U><L,U>, Inline: [0] -}
                                  = \ (w3 :: [GHC.Base.Maybe GHC.Types.Word])
                                      (w4 :: [GHC.Types.Word])
                                      (ww6 :: Data.Map.Base.Map
                                                CapDL.Model.CapName CapDL.Model.CapRef) ->
                                    case w3 of wild3 {
                                      [] -> (# ww6 #)
                                      : y ys
                                      -> case w4 of wild4 {
                                           [] -> (# ww6 #)
                                           : y1 ys1
                                           -> $wxs4
                                                ys
                                                ys1
                                                (CapDL.MakeModel.$w$sgo1
                                                   @ (CapDL.Model.ObjID, GHC.Types.Word)
                                                   ww1
                                                   y
                                                   (w1, y1)
                                                   ww6) } }
                                } in
                                let {
                                  y :: GHC.Prim.Word#
                                  = GHC.Prim.minusWord# (GHC.Prim.int2Word# ww5) 1##
                                } in
                                letrec {
                                  go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                                    {- Arity: 1, Strictness: <L,U> -}
                                  = \ (x4 :: GHC.Prim.Word#) ->
                                    GHC.Types.:
                                      @ (GHC.Base.Maybe GHC.Types.Word)
                                      (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x4))
                                      (case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.eqWord# x4 y) of wild3 {
                                         GHC.Types.False -> go4 (GHC.Prim.plusWord# x4 1##)
                                         GHC.Types.True
                                         -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                                } in
                                $wxs4
                                  (go4 0##)
                                  (case w2 of wild3 { GHC.Types.W# x4 ->
                                   GHC.Enum.eftWord
                                     x4
                                     (GHC.Prim.minusWord#
                                        (GHC.Prim.plusWord# x4 (GHC.Prim.int2Word# ww5))
                                        1##) })
                                  ww
                             : ipv ipv1
                             -> case CapDL.MakeModel.addCapIdent1
                                ret_ty (# Data.Map.Base.Map
                                            CapDL.Model.CapName CapDL.Model.CapRef #)
                                of {} } } } }) -}
45198d57e848bb3365318ce2b6d9dc6e
  $waddIRQ ::
    CapDL.Model.IRQMap
    -> GHC.Prim.Word# -> CapDL.Model.ObjID -> CapDL.Model.IRQMap
  {- Arity: 3, Strictness: <S,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.IRQMap)
                   (ww :: GHC.Prim.Word#)
                   (ww1 :: CapDL.Model.ObjID) ->
                 case CapDL.MakeModel.$wpoly_go3
                        @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                        ww
                        w of wild {
                   GHC.Types.False
                   -> CapDL.MakeModel.$w$sgo2
                        @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                        ww
                        ww1
                        w
                   GHC.Types.True -> CapDL.MakeModel.addIRQ1 ww }) -}
7c3196f47ec77133170c04b6496c9c02
  $waddIRQMapping ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
    -> CapDL.AST.CapMapping
    -> GHC.Types.Word
    -> (# CapDL.Model.IRQMap, GHC.Types.Word #)
  {- Arity: 4, Strictness: <L,U><L,1*C1(U(U,U))><L,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.MakeModel.SlotState CapDL.Model.IRQMap)
                   (w2 :: CapDL.AST.CapMapping)
                   (w3 :: GHC.Types.Word) ->
                 let {
                   ds :: Data.Functor.Identity.Identity
                           ([(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word)
                   = case CapDL.MakeModel.$wgetSlotIRQs
                            w
                            w2
                            w3 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <([(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word)>_R)) }
                 } in
                 let {
                   ds1 :: Data.Functor.Identity.Identity
                            (CapDL.Model.IRQMap, GHC.Types.Word)
                   = w1
                       `cast`
                     (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <GHC.Types.Word>_N
                          <Data.Functor.Identity.Identity>_R
                          <CapDL.Model.IRQMap>_N)
                       (case ds
                               `cast`
                             (Data.Functor.Identity.N:Identity[0]
                                  <([(GHC.Types.Word, CapDL.Model.ObjID)],
                                    GHC.Types.Word)>_R) of wild { (,) a1 s' ->
                        s' })
                 } in
                 (# case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <([(GHC.Types.Word, CapDL.Model.ObjID)],
                                GHC.Types.Word)>_R) of wild { (,) a1 s' ->
                    case ds1
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(CapDL.Model.IRQMap, GHC.Types.Word)>_R) of wild1 { (,) a2 s'1 ->
                    CapDL.MakeModel.addIRQMapping_go a1 a2 } },
                    case ds1
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <(CapDL.Model.IRQMap, GHC.Types.Word)>_R) of wild { (,) a1 s' ->
                    s' } #)) -}
7b4d75722fd1d7b225c7e24c195a0bd9
  $waddUTCover ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> [CapDL.Model.ObjID]
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> Data.Map.Base.Map
         CapDL.Model.ObjID (Data.Set.Base.Set CapDL.Model.ObjID)
  {- Arity: 5, Strictness: <L,U><S,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.CoverMap)
                   (w2 :: [CapDL.Model.ObjID])
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 CapDL.MakeModel.$w$sgo1
                   @ (Data.Set.Base.Set CapDL.Model.ObjID)
                   ww
                   ww1
                   (case CapDL.MakeModel.$wpoly_go1
                           @ (Data.Set.Base.Set CapDL.Model.ObjID)
                           ww
                           ww1
                           w1 of wild {
                      GHC.Base.Nothing
                      -> case (CapDL.MakeModel.addCovered2
                                 @ (CapDL.Model.KernelObject GHC.Types.Word)
                                 w2
                                 w)
                                `cast`
                              (Data.Monoid.N:All[0]) of wild1 {
                           GHC.Types.False -> CapDL.MakeModel.addCovered1 w2
                           GHC.Types.True
                           -> CapDL.MakeModel.addCovered_go
                                w2
                                (Data.Set.Base.Tip @ CapDL.Model.ObjID) }
                      GHC.Base.Just cov
                      -> case (CapDL.MakeModel.addCovered2
                                 @ (CapDL.Model.KernelObject GHC.Types.Word)
                                 w2
                                 w)
                                `cast`
                              (Data.Monoid.N:All[0]) of wild1 {
                           GHC.Types.False -> CapDL.MakeModel.addCovered1 w2
                           GHC.Types.True -> CapDL.MakeModel.addCovered_go w2 cov } })
                   w1) -}
bc5c5ce4013532f8701b875586a429bd
  $wcapIdents ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.AST.Decl]
    -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: [CapDL.AST.Decl]) ->
                 letrec {
                   $wgo2 :: [CapDL.AST.Decl]
                            -> Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
                            -> (# Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ (w2 :: [CapDL.AST.Decl])
                       (ww :: Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef) ->
                     case w2 of wild {
                       [] -> (# ww #)
                       : y ys
                       -> case CapDL.MakeModel.$waddCapIdent w ww y of ww1 { Unit# ww2 ->
                          $wgo2 ys ww2 } }
                 } in
                 $wgo2
                   w1
                   (Data.Map.Base.Tip @ CapDL.Model.CapName @ CapDL.Model.CapRef)) -}
6de0cef77a7a7955d1f4e4f1f52de06c
  $wcapOf ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> [CapDL.AST.CapParam]
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Cap
  {- Arity: 5, Strictness: <S,1*U><L,1*U(1*U,1*U)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: [CapDL.AST.CapParam])
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case CapDL.MakeModel.$wpoly_go1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        w of wild {
                   GHC.Base.Nothing
                   -> case w1 of ww2 { (,) ww3 ww4 ->
                      CapDL.MakeModel.capOf1 ww3 ww4 ww ww1 }
                   GHC.Base.Just obj
                   -> CapDL.MakeModel.objCapOf w1 obj (ww, ww1) w2 }) -}
03c7ced8c2f84fa85fa90ac1cfd909bd
  $wgetCapCopies ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.Name
    -> [CapDL.AST.Range]
    -> CapDL.Model.CopyMap
    -> CapDL.AST.CapMapping
    -> CapDL.Model.CopyMap
  {- Arity: 6, Strictness: <L,U(U)><L,U><L,U><S,1*U><S,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww :: CapDL.AST.Name)
                   (ww1 :: [CapDL.AST.Range])
                   (w2 :: CapDL.Model.CopyMap)
                   (w3 :: CapDL.AST.CapMapping) ->
                 letrec {
                   go4 :: [CapDL.Model.ObjID]
                          -> CapDL.Model.CopyMap -> CapDL.Model.CopyMap
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.Model.ObjID]) (eta :: CapDL.Model.CopyMap) ->
                     case ds of wild {
                       [] -> eta
                       : y ys -> go4 ys (CapDL.MakeModel.$wgetCapCopy w y eta w3) }
                 } in
                 go4
                   (CapDL.MakeModel.$wrefToIDs
                      @ (CapDL.Model.KernelObject GHC.Types.Word)
                      w1
                      ww
                      ww1)
                   w2) -}
4c4c7e929ec6fa840f9512370b7f3d1c
  $wgetCapCopy ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjID
    -> CapDL.Model.CopyMap
    -> CapDL.AST.CapMapping
    -> CapDL.Model.CopyMap
  {- Arity: 4, Strictness: <L,1*U(1*U)><L,U(U,U)><S,1*U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.CopyMap)
                   (w3 :: CapDL.AST.CapMapping) ->
                 case w3 of wild {
                   DEFAULT -> w2
                   CapDL.AST.CopyOf ds ds1 src ds2 ds3
                   -> case ds of wild1 {
                        GHC.Base.Nothing -> w2
                        GHC.Base.Just slot
                        -> case src of ww { (,) ww1 ww2 ->
                           case slot of wild2 { GHC.Types.W# x4 ->
                           let {
                             capNames :: [CapDL.Model.ObjID]
                             = CapDL.MakeModel.$wrefToIDs
                                 @ CapDL.Model.CapRef
                                 (CapDL.Model.cap_ids @ CapDL.Model.CapName w)
                                 ww1
                                 ww2
                           } in
                           case GHC.List.$wlenAcc
                                  @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                  capNames
                                  0# of ww3 { DEFAULT ->
                           letrec {
                             xs :: [GHC.Types.Word]
                                   -> [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
                                   -> Data.Map.Base.Map CapDL.Model.CapRef CapDL.Model.CapName
                                   -> Data.Map.Base.Map CapDL.Model.CapRef CapDL.Model.CapName
                               {- Arity: 3, Strictness: <S,1*U><L,1*U><S,1*U> -}
                             = \ (ds4 :: [GHC.Types.Word])
                                 (eta :: [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)])
                                 (eta1 :: Data.Map.Base.Map
                                            CapDL.Model.CapRef CapDL.Model.CapName) ->
                               case ds4 of wild3 {
                                 [] -> eta1
                                 : y ys
                                 -> case eta of wild4 {
                                      [] -> eta1
                                      : y1 ys1
                                      -> xs
                                           ys
                                           ys1
                                           (CapDL.MakeModel.$w$sgo10
                                              @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                              w1
                                              y
                                              y1
                                              eta1) } }
                           } in
                           xs
                             (GHC.Enum.eftWord
                                x4
                                (GHC.Prim.plusWord# x4 (GHC.Prim.int2Word# ww3)))
                             capNames
                             w2 } } } } }) -}
eeebbe332ed2c9b371d77e3fc6cab043
  $wgetSlotIRQs ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> GHC.Types.Word
    -> (# [(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word #)
  {- Arity: 3, Strictness: <L,U><S,1*U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.AST.CapMapping)
                   (w2 :: GHC.Types.Word) ->
                 case w1 of wild {
                   DEFAULT
                   -> case CapDL.MakeModel.addIRQMapping2
                      ret_ty (# [(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word #)
                      of {}
                   CapDL.AST.IRQMapping slot nameRef
                   -> let {
                        irqs :: [CapDL.Model.ObjID]
                        = case nameRef of ww { (,) ww1 ww2 ->
                          CapDL.MakeModel.$wrefToIDs
                            @ (CapDL.Model.KernelObject GHC.Types.Word)
                            w
                            ww1
                            ww2 }
                      } in
                      let {
                        slot' :: GHC.Types.Word
                        = case slot of wild1 {
                            GHC.Base.Nothing
                            -> case w2 of wild2 { GHC.Types.W# x# ->
                               GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                            GHC.Base.Just slot1 -> slot1 }
                      } in
                      let {
                        lastSlot :: GHC.Types.Word
                        = case slot' of wild1 { GHC.Types.W# x# ->
                          case GHC.List.$wlenAcc
                                 @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                 irqs
                                 0# of ww2 { DEFAULT ->
                          GHC.Types.W#
                            (GHC.Prim.plusWord#
                               x#
                               (GHC.Prim.int2Word# (GHC.Prim.-# ww2 1#))) } }
                      } in
                      (# case slot' of wild1 { GHC.Types.W# x4 ->
                         case lastSlot of wild2 { GHC.Types.W# y ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.gtWord# x4 y) of wild3 {
                           GHC.Types.False
                           -> letrec {
                                go4 :: GHC.Prim.Word#
                                       -> [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
                                       -> [(GHC.Types.Word,
                                            (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))]
                                  {- Arity: 2, Strictness: <L,U><S,1*U> -}
                                = \ (x5 :: GHC.Prim.Word#)
                                    (eta :: [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]) ->
                                  case eta of wild4 {
                                    []
                                    -> GHC.Types.[]
                                         @ (GHC.Types.Word,
                                            (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))
                                    : y1 ys
                                    -> GHC.Types.:
                                         @ (GHC.Types.Word,
                                            (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))
                                         (GHC.Types.W# x5, y1)
                                         (case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.eqWord# x5 y) of wild5 {
                                            GHC.Types.False -> go4 (GHC.Prim.plusWord# x5 1##) ys
                                            GHC.Types.True
                                            -> GHC.Types.[]
                                                 @ (GHC.Types.Word,
                                                    (GHC.Base.String,
                                                     GHC.Base.Maybe GHC.Types.Word)) }) }
                              } in
                              go4 x4 irqs
                           GHC.Types.True
                           -> GHC.Types.[]
                                @ (GHC.Types.Word,
                                   (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)) } } },
                         lastSlot #) }) -}
cd4ce0fd327c471d337d8c92ece51ee1
  $wgetSrcCap ::
    Data.Map.Base.Map CapDL.Model.CapName CapDL.Model.CapRef
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Cap
  {- Arity: 5, Strictness: <S,1*U><C(S),C(U)><S,1*U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: Data.Map.Base.Map
                            CapDL.Model.CapName CapDL.Model.CapRef)
                   (w :: CapDL.MakeModel.CapRefMappings)
                   (ww1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww2 :: GHC.Base.String)
                   (ww3 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case CapDL.MakeModel.$wpoly_go1
                        @ (CapDL.Model.ObjID, GHC.Types.Word)
                        ww2
                        ww3
                        ww of wild {
                   GHC.Base.Nothing -> CapDL.MakeModel.getSrcCap2 ww2 ww3
                   GHC.Base.Just srcRef
                   -> case CapDL.MakeModel.getSrcCap_$stransMappingE
                             (GHC.Types.[] @ CapDL.Model.CapRef)
                             w
                             srcRef of ww4 { (,) ww5 ww6 ->
                      case ww5 of ww7 { (,) ww8 ww9 ->
                      case ww6 of ww10 { GHC.Types.W# ww11 ->
                      case CapDL.State.$wpoly_go10
                             @ (CapDL.Model.KernelObject GHC.Types.Word)
                             ww8
                             ww9
                             ww1 of wild1 {
                        GHC.Base.Nothing -> CapDL.MakeModel.getSrcCap1 w srcRef
                        GHC.Base.Just x4
                        -> case CapDL.State.$wpoly_go1
                                  @ CapDL.Model.Cap
                                  ww11
                                  (CapDL.State.objSlots x4) of wild2 {
                             GHC.Base.Nothing -> CapDL.MakeModel.getSrcCap1 w srcRef
                             GHC.Base.Just cap -> cap } } } } } }) -}
6ab0d162247e40a4ca77a24512cecc58
  $wgetUTObj ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case CapDL.MakeModel.$wpoly_go1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        w of wild {
                   GHC.Base.Nothing -> CapDL.MakeModel.emptyUntyped
                   GHC.Base.Just obj
                   -> case obj of wild1 {
                        DEFAULT -> CapDL.MakeModel.getUTObj1 ww ww1 wild1
                        CapDL.Model.Untyped ds ds1 -> wild1 } }) -}
449f1edbdd3f5958f51c983f21194089
  $wgetVMSize ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Prim.Word#
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
da3dfdf2cf1fe99424c209932ac06b16
  $wgo ::
    [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
    -> [[CapDL.AST.CapMapping]]
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 7, Strictness: <S,1*U><L,1*U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
0abde1c5acdeee0c2dbc8f616dbf4f22
  $wgo1 ::
    [CapDL.AST.Decl]
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap GHC.Types.Word,
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 6, Strictness: <S,1*U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
7df349ce2bda721313da973a19fd5ab3
  $winsertCDT ::
    CapDL.Model.ObjID
    -> GHC.Types.Word
    -> CapDL.Model.CapRef
    -> CapDL.Model.CDT
    -> Data.Map.Base.Map CapDL.Model.CapRef CapDL.Model.CapRef
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><S,U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjID)
                   (ww1 :: GHC.Types.Word)
                   (w :: CapDL.Model.CapRef)
                   (w1 :: CapDL.Model.CDT) ->
                 case CapDL.MakeModel.$wpoly_go10
                        @ (CapDL.Model.ObjID, GHC.Types.Word)
                        ww
                        ww1
                        w1 of wild {
                   GHC.Base.Nothing
                   -> CapDL.MakeModel.$w$sgo10
                        @ (CapDL.Model.ObjID, GHC.Types.Word)
                        ww
                        ww1
                        w
                        w1
                   GHC.Base.Just ipv -> CapDL.MakeModel.addCDTMapping1 ww1 ww }) -}
fab75f83fdc8f4373699dd20a54a1fa4
  $winsertMapping ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> GHC.Prim.Word#
    -> CapDL.Model.Cap
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 3, Strictness: <S,U><L,U><L,U>, Inline: [0] -}
95178285e99d03ca1756b5f5620a13ca
  $wlvl :: CapDL.AST.Name -> [CapDL.AST.Range] -> CapDL.Model.ObjID
  {- Arity: 2, Strictness: <B,1*U><B,U>x, Inline: [0] -}
586dab574581c97399c572745bcedb9b
  $wlvl1 ::
    CapDL.MakeModel.CapRefMappings
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Prim.Word#
    -> CapDL.Model.Cap
  {- Arity: 4, Strictness: <B,C(U)><B,U><B,U><B,U>x, Inline: [0] -}
3398eb2184f4dd41a9d31d80e5cf36c1
  $wmakeModel ::
    CapDL.Model.Arch
    -> [CapDL.AST.Decl]
    -> (# CapDL.Model.Model GHC.Types.Word,
          CapDL.Model.Idents CapDL.Model.CapName, CapDL.Model.CopyMap #)
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.Arch) (ww1 :: [CapDL.AST.Decl]) ->
                 let {
                   objs' :: CapDL.Model.ObjMap GHC.Types.Word
                   = CapDL.MakeModel.makeModel_go1
                       ww1
                       (CapDL.MakeModel.makeModel_go
                          ww1
                          (Data.Map.Base.Tip
                             @ CapDL.Model.ObjID
                             @ (CapDL.Model.KernelObject GHC.Types.Word)))
                 } in
                 let {
                   ids :: CapDL.Model.Idents CapDL.Model.CapName
                   = case CapDL.MakeModel.$wcapIdents objs' ww1 of ww2 { Unit# ww3 ->
                     CapDL.Model.Idents @ CapDL.Model.CapName ww3 }
                 } in
                 (# case CapDL.MakeModel.$wgo1
                           ww1
                           ww
                           objs'
                           (CapDL.MakeModel.addIRQNodes
                              objs'
                              (Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.ObjID)
                              ww1)
                           (CapDL.MakeModel.addCDTCapDecls
                              objs'
                              ids
                              (CapDL.MakeModel.getCDTDecls ids ww1)
                              ww1)
                           (CapDL.MakeModel.getUntypedCovers
                              (GHC.Types.[] @ CapDL.AST.NameRef)
                              objs'
                              (Data.Map.Base.Tip @ CapDL.Model.ObjID @ CapDL.Model.ObjSet)
                              ww1) of ww2 { (#,,,,#) ww3 ww4 ww5 ww6 ww7 ->
                    case CapDL.MakeModel.$waddCapCopyDecls
                           ids
                           (CapDL.MakeModel.capCopyGraph objs' ids ww1)
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww1 of ww8 { (#,,,,#) ww9 ww10 ww11 ww12 ww13 ->
                    CapDL.Model.Model @ GHC.Types.Word ww9 ww10 ww11 ww12 ww13 } },
                    ids, CapDL.MakeModel.getCapCopyDecls ids objs' ww1 #)) -}
7744c2d8998e4a4fb1e8a515e9f6a32a
  $wnumConstrs :: Data.Data.Data a => a -> GHC.Prim.Int#
  {- Arity: 2,
     Strictness: <S(LLLLC(S(LS))LLLLLLLLLL),1*U(A,A,A,A,1*C1(U(1*U,1*U)),A,A,A,A,A,A,A,A,A,A)><L,U>,
     Inline: [0],
     Unfolding: (\ @ a (w :: Data.Data.Data a) (w1 :: a) ->
                 case Data.Data.dataTypeOf
                        @ a
                        w
                        w1 of ww { Data.Data.DataType ww1 ww2 ->
                 GHC.List.$wlenAcc
                   @ Data.Data.Constr
                   (Data.Data.$wdataTypeConstrs ww1 ww2)
                   0# }) -}
09bc2342c169fbfdaf10d9a42575af14
  $wnumObject ::
    Data.Map.Base.Map CapDL.Model.ObjID a
    -> CapDL.AST.Name -> GHC.Prim.Word#
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Map.Base.Map CapDL.Model.ObjID a)
                   (w1 :: CapDL.AST.Name) ->
                 case CapDL.MakeModel.$smember_$s$wpoly_go2
                        @ a
                        w
                        CapDL.MakeModel.refToIDs3
                        w1 of wild {
                   GHC.Types.False
                   -> case CapDL.MakeModel.refToIDs2 w1 ret_ty GHC.Prim.Word# of {}
                   GHC.Types.True
                   -> letrec {
                        go10 :: (GHC.Types.Int -> GHC.Types.Int)
                                -> Data.Map.Base.Map
                                     (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word) a
                                -> GHC.Types.Int
                                -> GHC.Types.Int
                          {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                        = \ (z' :: GHC.Types.Int -> GHC.Types.Int)
                            (ds :: Data.Map.Base.Map
                                     (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word) a) ->
                          case ds of wild1 {
                            Data.Map.Base.Bin dt kx x4 l r
                            -> case kx of wild2 { (,) second ds1 ->
                               go10
                                 (case GHC.Base.eqString w1 second of wild3 {
                                    GHC.Types.False -> go10 z' r
                                    GHC.Types.True
                                    -> let {
                                         r1 :: GHC.Types.Int -> GHC.Types.Int = go10 z' r
                                       } in
                                       \ (a1 :: GHC.Types.Int) ->
                                       case a1 of a2 { GHC.Types.I# ipv ->
                                       r1 (GHC.Types.I# (GHC.Prim.+# ipv 1#)) } })
                                 l }
                            Data.Map.Base.Tip -> z' }
                      } in
                      case go10
                             (GHC.Base.id @ GHC.Types.Int)
                             w
                             CapDL.MakeModel.refToIDs1 of wild1 { GHC.Types.I# x# ->
                      GHC.Prim.int2Word# x# } }) -}
f0d6d0113cb735e6515fd5b9b1f6548a
  $wobjectOf ::
    CapDL.AST.Name
    -> CapDL.Model.KOType
    -> [CapDL.AST.ObjParam]
    -> [Data.Either.Either CapDL.AST.KODecl CapDL.AST.NameRef]
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 4, Strictness: <L,U><S,U><S,U><L,U>, Inline: [0] -}
b3d268ad059ed45a3091b2f2cb912a8d
  $wpoly_go1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> Data.Map.Base.Map CapDL.Model.ObjID a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [0] -}
cb61c099784afda5e57a98730e8e28ff
  $wpoly_go10 ::
    CapDL.Model.ObjID
    -> GHC.Types.Word
    -> Data.Map.Base.Map CapDL.Model.CapRef a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(U,U)><L,U(U)><S,1*U>,
     Inline: [0] -}
0ea654ca1945cfef7fcd63f80e7170e0
  $wpoly_go2 ::
    CapDL.AST.Name
    -> GHC.Base.Maybe GHC.Types.Word
    -> Data.Map.Base.Map
         (CapDL.AST.Name, GHC.Base.Maybe GHC.Types.Word) a
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [0] -}
c207154f952684887323a636305d5e13
  $wpoly_go3 ::
    GHC.Prim.Word#
    -> Data.Map.Base.Map GHC.Types.Word a -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
3ee7465b77264de9556b9d23d68d6279
  $wprintID ::
    GHC.Base.String -> GHC.Base.Maybe GHC.Types.Word -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case ww1 of wild {
                   GHC.Base.Nothing -> ww
                   GHC.Base.Just num
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww
                        (GHC.CString.unpackAppendCString#
                           "["#
                           (case num of wild1 { GHC.Types.W# w ->
                            case GHC.Show.$wshowWord
                                   w
                                   (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                            GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                              CapDL.MakeModel.printID1 } })) }) -}
83a99dbe0ee2fcf9a356035aa02c43b2
  $wrefToIDs ::
    Data.Map.Base.Map CapDL.Model.ObjID a
    -> CapDL.AST.Name -> [CapDL.AST.Range] -> [CapDL.Model.ObjID]
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Map.Base.Map CapDL.Model.ObjID a)
                   (ww :: CapDL.AST.Name)
                   (ww1 :: [CapDL.AST.Range]) ->
                 case ww1 of wild {
                   []
                   -> GHC.Types.:
                        @ CapDL.Model.ObjID
                        (ww, GHC.Base.Nothing @ GHC.Types.Word)
                        (GHC.Types.[] @ CapDL.Model.ObjID)
                   : ipv ipv1
                   -> letrec {
                        xs :: [GHC.Base.Maybe GHC.Types.Word]
                              -> [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [GHC.Base.Maybe GHC.Types.Word]) ->
                          case ds of wild1 {
                            []
                            -> GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                            : y ys
                            -> GHC.Types.:
                                 @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                 (ww, y)
                                 (xs ys) }
                      } in
                      let {
                        f :: GHC.Types.Word
                        = case CapDL.MakeModel.$wnumObject @ a w ww of ww2 { DEFAULT ->
                          GHC.Types.W# ww2 }
                      } in
                      letrec {
                        go4 :: [CapDL.AST.Range] -> [GHC.Base.Maybe GHC.Types.Word]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [CapDL.AST.Range]) ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word)
                            : y ys
                            -> GHC.Base.++
                                 @ (GHC.Base.Maybe GHC.Types.Word)
                                 (CapDL.MakeModel.unrange f y)
                                 (go4 ys) }
                      } in
                      let {
                        $sgo :: CapDL.AST.Range
                                -> [CapDL.AST.Range] -> [GHC.Base.Maybe GHC.Types.Word]
                          {- Arity: 2, Strictness: <L,U><L,U> -}
                        = \ (sc :: CapDL.AST.Range) (sc1 :: [CapDL.AST.Range]) ->
                          GHC.Base.++
                            @ (GHC.Base.Maybe GHC.Types.Word)
                            (CapDL.MakeModel.unrange f sc)
                            (go4 sc1)
                      } in
                      xs ($sgo ipv ipv1) }) -}
49a68f371f636dae6cb704dde939477d
  $wvalidObjPars ::
    CapDL.Model.KOType
    -> [CapDL.AST.ObjParam]
    -> [Data.Either.Either CapDL.AST.KODecl CapDL.AST.NameRef]
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><S,U><L,1*U>, Inline: [0] -}
61abc78ad2a4b97196be2c4ae143569d
  type CapRefMappings =
    CapDL.Model.CapRef -> GHC.Base.Maybe CapDL.Model.CapRef
f2785f8dcb23bf5fa859eef1886f119d
  type SlotState =
    Control.Monad.Trans.State.Lazy.State GHC.Types.Word :: * -> *
09a4f4451c679998872c017a9a53ee04
  addCDTCapDecl ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CDT
    -> CapDL.AST.Decl
    -> CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,U><L,U(U)><S,1*U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (cdt :: CapDL.Model.CDT)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> cdt
                   CapDL.AST.CapDecl names mappings
                   -> letrec {
                        go4 :: [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
                               -> [[CapDL.AST.CapMapping]] -> CapDL.Model.CDT -> CapDL.Model.CDT
                          {- Arity: 3, Strictness: <S,1*U><L,1*U><S,1*U> -}
                        = \ (ds1 :: [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)])
                            (_ys :: [[CapDL.AST.CapMapping]])
                            (eta :: CapDL.Model.CDT) ->
                          case ds1 of wild1 {
                            [] -> eta
                            : ipv ipv1
                            -> case _ys of wild2 {
                                 [] -> eta
                                 : ipv2 ipv3
                                 -> case eta of z { DEFAULT ->
                                    case ((CapDL.MakeModel.$waddCDTMappings ids z ipv ipv2)
                                            `cast`
                                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                               <GHC.Types.Word>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <CapDL.Model.CDT>_N)
                                            CapDL.MakeModel.addCDTCapDecl1)
                                           `cast`
                                         (Data.Functor.Identity.N:Identity[0]
                                              <(CapDL.Model.CDT,
                                                GHC.Types.Word)>_R) of wild3 { (,) x4 ds2 ->
                                    go4 ipv1 ipv3 x4 } } } }
                      } in
                      go4
                        (CapDL.MakeModel.refToIDs
                           @ (CapDL.Model.KernelObject GHC.Types.Word)
                           objs
                           names)
                        (GHC.List.repeat @ [CapDL.AST.CapMapping] mappings)
                        cdt }) -}
1b9e2ff441ae9c09cc9b6c5571bf745d
  addCDTCapDecl1 :: GHC.Types.Word
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.W# 18446744073709551615##) -}
89cc7be3be5a276ce09a96a16616f727
  addCDTCapDecls ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CDT
    -> [CapDL.AST.Decl]
    -> CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,U><L,U(U)><S,1*U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (eta :: CapDL.Model.CDT)
                   (eta1 :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl] -> CapDL.Model.CDT -> CapDL.Model.CDT
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl]) (eta2 :: CapDL.Model.CDT) ->
                     case ds of wild {
                       [] -> eta2
                       : y ys -> go4 ys (CapDL.MakeModel.addCDTCapDecl objs ids eta2 y) }
                 } in
                 go4 eta1 eta) -}
b09f49cc44701874aaa9f9eb76e6fac3
  addCDTMapping ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjID
    -> CapDL.Model.CDT
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.SlotState CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,1*U(1*U)><L,U(U,U)><L,U><S,U>,
     Unfolding: (\ (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (obj :: CapDL.Model.ObjID)
                   (cdt :: CapDL.Model.CDT)
                   (mapping :: CapDL.AST.CapMapping) ->
                 let {
                   lvl424 :: CapDL.Model.CapRef
                   = case mapping of wild {
                       DEFAULT
                       -> case CapDL.AST.maybeParent1 ret_ty CapDL.Model.CapRef of {}
                       CapDL.AST.CapMapping ds2 ds3 ds4 ds5 ds6
                       -> case ds6 of wild1 {
                            GHC.Base.Nothing
                            -> case Data.Maybe.fromJust1 ret_ty CapDL.Model.CapRef of {}
                            GHC.Base.Just x4 -> CapDL.MakeModel.slotRefToCapRef ids x4 }
                       CapDL.AST.CopyOf ds2 ds3 ds4 ds5 ds6
                       -> case ds6 of wild1 {
                            GHC.Base.Nothing
                            -> case Data.Maybe.fromJust1 ret_ty CapDL.Model.CapRef of {}
                            GHC.Base.Just x4 -> CapDL.MakeModel.slotRefToCapRef ids x4 } }
                 } in
                 let {
                   $w$j :: GHC.Types.Word -> (# CapDL.Model.CDT, GHC.Types.Word #)
                     {- Arity: 1, Strictness: <L,1*U(U)>, Inline: [0] -}
                   = \ (w :: GHC.Types.Word) ->
                     let {
                       slot' :: GHC.Types.Word
                       = case mapping of wild {
                           CapDL.AST.CapMapping ds2 ds3 ds4 ds5 ds6
                           -> case ds2 of wild1 {
                                GHC.Base.Nothing
                                -> case w of wild2 { GHC.Types.W# x# ->
                                   GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                                GHC.Base.Just slot -> slot }
                           CapDL.AST.CopyOf ds2 ds3 ds4 ds5 ds6
                           -> case ds2 of wild1 {
                                GHC.Base.Nothing
                                -> case w of wild2 { GHC.Types.W# x# ->
                                   GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                                GHC.Base.Just slot -> slot }
                           CapDL.AST.IRQMapping ds2 ds3
                           -> case ds2 of wild1 {
                                GHC.Base.Nothing
                                -> case w of wild2 { GHC.Types.W# x# ->
                                   GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                                GHC.Base.Just slot -> slot }
                           CapDL.AST.ASIDMapping ds2 ds3
                           -> case ds2 of wild1 {
                                GHC.Base.Nothing
                                -> case w of wild2 { GHC.Types.W# x# ->
                                   GHC.Types.W# (GHC.Prim.plusWord# x# 1##) }
                                GHC.Base.Just slot -> slot } }
                     } in
                     (# CapDL.MakeModel.$winsertCDT obj slot' lvl424 cdt, slot' #)
                 } in
                 case mapping of wild {
                   DEFAULT
                   -> case CapDL.AST.maybeParent1
                      ret_ty (Control.Monad.Trans.State.Lazy.StateT
                                GHC.Types.Word Data.Functor.Identity.Identity CapDL.Model.CDT)
                      of {}
                   CapDL.AST.CapMapping ds2 ds3 ds4 ds5 ds6
                   -> case ds6 of wild1 {
                        GHC.Base.Nothing
                        -> (\ (eta1 :: GHC.Types.Word) -> (cdt, eta1))
                             `cast`
                           (Trans
                                (<GHC.Types.Word>_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                               <(CapDL.Model.CDT, GHC.Types.Word)>_R))
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <GHC.Types.Word>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <CapDL.Model.CDT>_N)))
                        GHC.Base.Just ipv
                        -> (\ (w :: GHC.Types.Word) ->
                            case $w$j w of ww { (#,#) ww1 ww2 ->
                            (ww1, ww2)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <(CapDL.Model.CDT, GHC.Types.Word)>_R)) })
                             `cast`
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <GHC.Types.Word>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <CapDL.Model.CDT>_N)) }
                   CapDL.AST.CopyOf ds2 ds3 ds4 ds5 ds6
                   -> case ds6 of wild1 {
                        GHC.Base.Nothing
                        -> (\ (eta1 :: GHC.Types.Word) -> (cdt, eta1))
                             `cast`
                           (Trans
                                (<GHC.Types.Word>_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                               <(CapDL.Model.CDT, GHC.Types.Word)>_R))
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <GHC.Types.Word>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <CapDL.Model.CDT>_N)))
                        GHC.Base.Just ipv
                        -> (\ (w :: GHC.Types.Word) ->
                            case $w$j w of ww { (#,#) ww1 ww2 ->
                            (ww1, ww2)
                              `cast`
                            (Sym (Data.Functor.Identity.N:Identity[0]
                                      <(CapDL.Model.CDT, GHC.Types.Word)>_R)) })
                             `cast`
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <GHC.Types.Word>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <CapDL.Model.CDT>_N)) } }) -}
9b3e393d720710ce4451e9ca615d64ce
  addCDTMapping1 ::
    GHC.Types.Word -> CapDL.Model.ObjID -> CapDL.Model.CDT
  {- Arity: 2, Strictness: <L,U><L,U>x -}
8d96b45aba828af93f49cc35f63d3050
  addCDTMappings ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CDT
    -> (CapDL.Model.ObjID, [CapDL.AST.CapMapping])
    -> CapDL.MakeModel.SlotState CapDL.Model.CDT
  {- Arity: 3, Strictness: <L,U(U)><L,U><S(LS),1*U(U(U,U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.CDT)
                   (w2 :: (CapDL.Model.ObjID, [CapDL.AST.CapMapping])) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$waddCDTMappings w w1 ww1 ww2 }) -}
46c22b0736f47f482f3c34cac0bf887f
  addCap ::
    CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.ObjID, [CapDL.AST.CapMapping])
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 2,
     Strictness: <S(LSLLL),1*U(U,U,U,U,U)><S(SS),1*U(U(U,U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: (CapDL.Model.ObjID, [CapDL.AST.CapMapping])) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case w1 of ww6 { (,) ww7 ww8 ->
                 case ww7 of ww9 { (,) ww10 ww11 ->
                 case CapDL.MakeModel.$waddCap
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww10
                        ww11
                        ww8 of ww12 { (#,,,,#) ww13 ww14 ww15 ww16 ww17 ->
                 CapDL.Model.Model
                   @ GHC.Types.Word
                   ww13
                   ww14
                   ww15
                   ww16
                   ww17 } } } }) -}
c54f57327c126a66b72302b52635aab4
  addCap1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><L,U>x -}
98d261fb14bdff7d86b1cd5e35b7e622
  addCap2 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><L,U>x -}
6d8cbe91c00bde876089fa9f1e18b93c
  addCapCopies ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.AST.NameRef
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 5,
     Strictness: <L,U(U)><L,C(U)><S(LS),1*U(U,1*U)><S,1*U(U,U,U,U,U)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.AST.NameRef)
                   (w3 :: CapDL.Model.Model GHC.Types.Word)
                   (w4 :: CapDL.AST.CapMapping) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case w3 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 case CapDL.MakeModel.$waddCapCopies
                        w
                        w1
                        ww1
                        ww2
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        w4 of ww9 { (#,,,,#) ww10 ww11 ww12 ww13 ww14 ->
                 CapDL.Model.Model
                   @ GHC.Types.Word
                   ww10
                   ww11
                   ww12
                   ww13
                   ww14 } } }) -}
5ec29602b2c44daf76b41b55dbb1b893
  addCapCopy ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 5,
     Strictness: <L,U(U)><L,C(U)><L,U(U,U)><S,U(U,U,U,U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: CapDL.Model.Model GHC.Types.Word)
                   (w4 :: CapDL.AST.CapMapping) ->
                 case w3 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.MakeModel.$waddCapCopy
                        w
                        w1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        w4 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 CapDL.Model.Model @ GHC.Types.Word ww7 ww8 ww9 ww10 ww11 } }) -}
e2efcf73d7a6f4422136d5766f3b76f5
  addCapCopyDecl ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.AST.Decl
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 4,
     Strictness: <L,U(U)><L,C(U)><S,1*U(U,U,U,U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.Model.Model GHC.Types.Word)
                   (w3 :: CapDL.AST.Decl) ->
                 case w2 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.MakeModel.$waddCapCopyDecl
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        w3 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 CapDL.Model.Model @ GHC.Types.Word ww7 ww8 ww9 ww10 ww11 } }) -}
681de006f6f3ff3d776360dd8fc259e3
  addCapCopyDecls ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.Model GHC.Types.Word
    -> [CapDL.AST.Decl]
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 4,
     Strictness: <L,U(U)><L,C(U)><S,1*U(U,U,U,U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.Model.Model GHC.Types.Word)
                   (w3 :: [CapDL.AST.Decl]) ->
                 case w2 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.MakeModel.$waddCapCopyDecls
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        w3 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 CapDL.Model.Model @ GHC.Types.Word ww7 ww8 ww9 ww10 ww11 } }) -}
1ebf89b5081df9ab7cf0e687b78ee6ba
  addCapCopyRef ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjID
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.CapRefMappings
  {- Arity: 4, Strictness: <S,1*U(1*U)><L,U(U,U)><L,U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.MakeModel.CapRefMappings)
                   (w3 :: CapDL.AST.CapMapping) ->
                 case w of ww { CapDL.Model.Idents ww1 ->
                 CapDL.MakeModel.$waddCapCopyRef ww1 w1 w2 w3 }) -}
dff680871175bd0c04c45fba8db1f1cd
  addCapCopyRefs ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.AST.Decl
    -> CapDL.MakeModel.CapRefMappings
  {- Arity: 4, Strictness: <L,U><L,U(U)><S,1*U><S,1*U>,
     Unfolding: (\ (map :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (m :: CapDL.MakeModel.CapRefMappings)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> m
                   CapDL.AST.CapDecl objs mappings
                   -> letrec {
                        go4 :: [CapDL.Model.ObjID]
                               -> CapDL.MakeModel.CapRefMappings -> CapDL.MakeModel.CapRefMappings
                          {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds1 :: [CapDL.Model.ObjID])
                            (eta :: CapDL.MakeModel.CapRefMappings) ->
                          case ds1 of wild1 {
                            [] -> eta
                            : y ys
                            -> case mappings of wild2 {
                                 [] -> go4 ys eta
                                 : y1 ys1
                                 -> case eta of z { DEFAULT ->
                                    case ids of ww { CapDL.Model.Idents ww1 ->
                                    letrec {
                                      go5 :: [CapDL.AST.CapMapping]
                                             -> CapDL.MakeModel.CapRefMappings
                                             -> CapDL.MakeModel.CapRefMappings
                                        {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                                      = \ (ds2 :: [CapDL.AST.CapMapping])
                                          (eta1 :: CapDL.MakeModel.CapRefMappings) ->
                                        case ds2 of wild3 {
                                          [] -> eta1
                                          : y2 ys2
                                          -> case eta1 of z1 { DEFAULT ->
                                             go5
                                               ys2
                                               (CapDL.MakeModel.$waddCapCopyRef ww1 y z1 y2) } }
                                    } in
                                    go4
                                      ys
                                      (go5 ys1 (CapDL.MakeModel.$waddCapCopyRef ww1 y z y1)) } } } }
                      } in
                      go4
                        (CapDL.MakeModel.refToIDs
                           @ (CapDL.Model.KernelObject GHC.Types.Word)
                           map
                           objs)
                        m }) -}
a6b3fec095a82fc7b1970e5baeeff0f6
  addCapDecl ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.AST.Decl -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U(U,U,U,U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: CapDL.AST.Decl) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case w1 of wild {
                   DEFAULT -> CapDL.Model.Model @ GHC.Types.Word ww1 ww2 ww3 ww4 ww5
                   CapDL.AST.CapDecl names mappings
                   -> case CapDL.MakeModel.$wgo
                             (CapDL.MakeModel.refToIDs
                                @ (CapDL.Model.KernelObject GHC.Types.Word)
                                ww2
                                names)
                             (GHC.List.repeat @ [CapDL.AST.CapMapping] mappings)
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                      CapDL.Model.Model @ GHC.Types.Word ww7 ww8 ww9 ww10 ww11 } } }) -}
0d7821a49c8b0dd3c822f0045700a569
  addCapDecls ::
    [CapDL.AST.Decl]
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [CapDL.AST.Decl])
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.MakeModel.$wgo1
                        w
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 CapDL.Model.Model @ GHC.Types.Word ww7 ww8 ww9 ww10 ww11 } }) -}
46aceb04228e63e32d1f68503d9a135c
  addCapIdent ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.AST.Decl
    -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 3, Strictness: <L,U><S,1*U(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w2 :: CapDL.AST.Decl) ->
                 case w1 of ww { CapDL.Model.Idents ww1 ->
                 case CapDL.MakeModel.$waddCapIdent w ww1 w2 of ww2 { Unit# ww3 ->
                 CapDL.Model.Idents @ CapDL.Model.CapName ww3 } }) -}
aedf5d9ca27c89aba9d0506963ea1a77
  addCapIdent1 :: [(CapDL.AST.Name, GHC.Base.Maybe GHC.Types.Word)]
  {- Strictness: x -}
00c1b18dfebfeb92f8e1dda322178f5b
  addCapIdent2 ::
    CapDL.AST.Name -> [(CapDL.AST.Name, GHC.Base.Maybe GHC.Types.Word)]
  {- Arity: 1, Strictness: <L,U>x -}
f51df1c983457e0ac628d2e3a5af6c11
  addCapIdentMapping ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.AST.CapMapping
    -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 4, Strictness: <L,U><L,U><S,1*U(U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w3 :: CapDL.AST.CapMapping) ->
                 case w2 of ww { CapDL.Model.Idents ww1 ->
                 case CapDL.MakeModel.$waddCapIdentMapping
                        w
                        w1
                        ww1
                        w3 of ww2 { Unit# ww3 ->
                 CapDL.Model.Idents @ CapDL.Model.CapName ww3 } }) -}
a02c1d58a17ed943e578a99023e8039c
  addCapIdentMapping' ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> GHC.Types.Word
    -> CapDL.AST.NameRef
    -> CapDL.AST.NameRef
    -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 6,
     Strictness: <L,U><L,U><S,1*U(U)><L,1*U(U)><S(LS),1*U(U,1*U)><S(LS),1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w3 :: GHC.Types.Word)
                   (w4 :: CapDL.AST.NameRef)
                   (w5 :: CapDL.AST.NameRef) ->
                 case w2 of ww { CapDL.Model.Idents ww1 ->
                 case w4 of ww2 { (,) ww3 ww4 ->
                 case w5 of ww5 { (,) ww6 ww7 ->
                 case CapDL.MakeModel.$waddCapIdentMapping'
                        w
                        w1
                        ww1
                        w3
                        ww3
                        ww4
                        ww6
                        ww7 of ww8 { Unit# ww9 ->
                 CapDL.Model.Idents @ CapDL.Model.CapName ww9 } } } }) -}
c6bf02803c1fadbb2c6dea833d358a65
  addCapIdentMappings ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.NameRef
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> [CapDL.AST.CapMapping]
    -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 2, Strictness: <L,U><L,1*U(U,1*U)>,
     Unfolding: (\ (m :: CapDL.Model.ObjMap GHC.Types.Word)
                   (obj :: CapDL.AST.NameRef) ->
                 GHC.List.foldl'
                   @ CapDL.AST.CapMapping
                   @ (CapDL.Model.Idents CapDL.Model.CapName)
                   (let {
                      w :: CapDL.Model.ObjID
                      = case obj of ww { (,) ww1 ww2 ->
                        case CapDL.MakeModel.$wrefToIDs
                               @ (CapDL.Model.KernelObject GHC.Types.Word)
                               m
                               ww1
                               ww2 of wild {
                          [] -> GHC.List.badHead @ CapDL.Model.ObjID : x4 ds1 -> x4 } }
                    } in
                    \ (w1 :: CapDL.Model.Idents CapDL.Model.CapName)
                      (w2 :: CapDL.AST.CapMapping) ->
                    case w1 of ww { CapDL.Model.Idents ww1 ->
                    case CapDL.MakeModel.$waddCapIdentMapping
                           m
                           w
                           ww1
                           w2 of ww2 { Unit# ww3 ->
                    CapDL.Model.Idents @ CapDL.Model.CapName ww3 } })) -}
16f9a6bb18598318d32968d2a88901fd
  addCovered ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.Model.ObjID] -> CapDL.Model.ObjSet -> CapDL.Model.ObjSet
  {- Arity: 3, Strictness: <L,U><S,U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (names :: [CapDL.Model.ObjID])
                   (cov :: CapDL.Model.ObjSet) ->
                 case (CapDL.MakeModel.addCovered2
                         @ (CapDL.Model.KernelObject GHC.Types.Word)
                         names
                         objs)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> CapDL.MakeModel.addCovered1 names
                   GHC.Types.True -> CapDL.MakeModel.addCovered_go names cov }) -}
9d05c71420beb977030530035f732598
  addCovered1 :: [CapDL.Model.ObjID] -> CapDL.Model.ObjSet
  {- Arity: 1, Strictness: <L,U>x -}
e484d64ffddfebaf797363dfc105f284
  addCovered2 ::
    [CapDL.Model.ObjID]
    -> Data.Map.Base.Map CapDL.Model.ObjID a -> Data.Monoid.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a
                   (names :: [CapDL.Model.ObjID])
                   (objs :: Data.Map.Base.Map CapDL.Model.ObjID a) ->
                 letrec {
                   go4 :: [CapDL.Model.ObjID] -> Data.Monoid.All
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [CapDL.Model.ObjID]) ->
                     case ds of wild {
                       [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                       : y ys
                       -> case y of ww { (,) ww1 ww2 ->
                          case CapDL.MakeModel.$wpoly_go2 @ a ww1 ww2 objs of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                            GHC.Types.True -> go4 ys } } }
                 } in
                 go4 names) -}
c82fb3bbc603b84b73ba755ac79bc278
  addCovered_go ::
    [CapDL.Model.ObjID]
    -> Data.Set.Base.Set CapDL.Model.ObjID
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
a7a9b9b6d1672ab0371d34a7a441f943
  addIRQ ::
    CapDL.Model.IRQMap
    -> (GHC.Types.Word, CapDL.Model.ObjID) -> CapDL.Model.IRQMap
  {- Arity: 2, Strictness: <S,U><S(SL),1*U(U(U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.IRQMap)
                   (w1 :: (GHC.Types.Word, CapDL.Model.ObjID)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.W# ww4 ->
                 CapDL.MakeModel.$waddIRQ w ww4 ww2 } }) -}
b39c85dc52625837f775e900588a826b
  addIRQ1 :: GHC.Prim.Word# -> CapDL.Model.IRQMap
  {- Arity: 1, Strictness: <L,U>x -}
944baa7f59eed73baa7f301845e04ece
  addIRQMapping ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
  {- Arity: 4, Strictness: <L,U><L,1*C1(U(U,U))><L,1*U><L,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.addIRQMapping1
                  `cast`
                (<CapDL.Model.ObjMap GHC.Types.Word>_R
                 ->_R <CapDL.MakeModel.SlotState CapDL.Model.IRQMap>_R
                 ->_R <CapDL.AST.CapMapping>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <CapDL.Model.IRQMap>_N)) -}
5ebeb3956f184fad76971d58efe15a35
  addIRQMapping1 ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
    -> CapDL.AST.CapMapping
    -> GHC.Types.Word
    -> Data.Functor.Identity.Identity
         (CapDL.Model.IRQMap, GHC.Types.Word)
  {- Arity: 4, Strictness: <L,U><L,1*C1(U(U,U))><L,1*U><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.MakeModel.SlotState CapDL.Model.IRQMap)
                   (w2 :: CapDL.AST.CapMapping)
                   (w3 :: GHC.Types.Word) ->
                 case CapDL.MakeModel.$waddIRQMapping
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(CapDL.Model.IRQMap, GHC.Types.Word)>_R)) }) -}
2336964069c0384f10b5a19d4752534f
  addIRQMapping2 ::
    CapDL.MakeModel.SlotState [(GHC.Types.Word, CapDL.Model.ObjID)]
  {- Strictness: x -}
11af7545190a640e5ff6a0df72809409
  addIRQMapping_go ::
    [(GHC.Types.Word, CapDL.Model.ObjID)]
    -> CapDL.Model.IRQMap -> CapDL.Model.IRQMap
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
41b35ebf16e7bc7b1ce66e092e7f7c91
  addIRQMappings ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> [CapDL.AST.CapMapping]
    -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (irqNode :: CapDL.Model.IRQMap)
                   (eta :: [CapDL.AST.CapMapping]) ->
                 letrec {
                   go4 :: [CapDL.AST.CapMapping]
                          -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
                          -> CapDL.MakeModel.SlotState CapDL.Model.IRQMap
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.CapMapping])
                       (eta1 :: CapDL.MakeModel.SlotState CapDL.Model.IRQMap) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> case eta1
                                 `cast`
                               (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CapDL.Model.IRQMap>_N) of nt { DEFAULT ->
                          go4
                            ys
                            (\ (w :: GHC.Types.Word) ->
                             let {
                               ds1 :: Data.Functor.Identity.Identity
                                        ([(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word)
                               = case CapDL.MakeModel.$wgetSlotIRQs
                                        objs
                                        y
                                        w of ww { (#,#) ww1 ww2 ->
                                 (ww1, ww2)
                                   `cast`
                                 (Sym (Data.Functor.Identity.N:Identity[0]
                                           <([(GHC.Types.Word, CapDL.Model.ObjID)],
                                             GHC.Types.Word)>_R)) }
                             } in
                             let {
                               ds2 :: Data.Functor.Identity.Identity
                                        (CapDL.Model.IRQMap, GHC.Types.Word)
                               = nt
                                   (case ds1
                                           `cast`
                                         (Data.Functor.Identity.N:Identity[0]
                                              <([(GHC.Types.Word, CapDL.Model.ObjID)],
                                                GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                                    s' })
                             } in
                             (case ds1
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <([(GHC.Types.Word, CapDL.Model.ObjID)],
                                          GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                              case ds2
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(CapDL.Model.IRQMap,
                                          GHC.Types.Word)>_R) of wild2 { (,) a2 s'1 ->
                              CapDL.MakeModel.addIRQMapping_go a1 a2 } },
                              case ds2
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(CapDL.Model.IRQMap,
                                          GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                              s' })
                               `cast`
                             (Sym (Data.Functor.Identity.N:Identity[0]
                                       <(CapDL.Model.IRQMap, GHC.Types.Word)>_R)))
                              `cast`
                            (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <GHC.Types.Word>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <CapDL.Model.IRQMap>_N)) } }
                 } in
                 go4
                   eta
                   (\ (eta1 :: GHC.Types.Word) -> (irqNode, eta1))
                     `cast`
                   (Trans
                        (<GHC.Types.Word>_R
                         ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                       <(CapDL.Model.IRQMap, GHC.Types.Word)>_R))
                        (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                  <GHC.Types.Word>_N
                                  <Data.Functor.Identity.Identity>_R
                                  <CapDL.Model.IRQMap>_N)))) -}
b412d79efdb7491e326e89d2412d646f
  addIRQNode ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap -> CapDL.AST.Decl -> CapDL.Model.IRQMap
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (irqNode :: CapDL.Model.IRQMap)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> irqNode
                   CapDL.AST.IRQDecl irqs
                   -> case irqNode of wild1 {
                        Data.Map.Base.Bin dt ds1 ds2 ds3 ds4 -> CapDL.MakeModel.addIRQNode1
                        Data.Map.Base.Tip
                        -> case ((CapDL.MakeModel.addIRQMappings
                                    objs
                                    (Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.ObjID)
                                    irqs)
                                   `cast`
                                 (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                      <GHC.Types.Word>_N
                                      <Data.Functor.Identity.Identity>_R
                                      <CapDL.Model.IRQMap>_N)
                                   CapDL.MakeModel.addCDTCapDecl1)
                                  `cast`
                                (Data.Functor.Identity.N:Identity[0]
                                     <(CapDL.Model.IRQMap,
                                       GHC.Types.Word)>_R) of wild2 { (,) x4 ds1 ->
                           x4 } } }) -}
19ce51584e6790e44e14c2703080ffbc
  addIRQNode1 :: CapDL.Model.IRQMap
  {- Strictness: x -}
a0b18cf15183ba8dd158a3c4cdf2ca36
  addIRQNodes ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap -> [CapDL.AST.Decl] -> CapDL.Model.IRQMap
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (eta :: CapDL.Model.IRQMap)
                   (eta1 :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl] -> CapDL.Model.IRQMap -> CapDL.Model.IRQMap
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl]) (eta2 :: CapDL.Model.IRQMap) ->
                     case ds of wild {
                       [] -> eta2
                       : y ys
                       -> case y of wild1 {
                            DEFAULT -> go4 ys eta2
                            CapDL.AST.IRQDecl irqs
                            -> case eta2 of wild2 {
                                 Data.Map.Base.Bin dt ds1 ds2 ds3 ds4 -> CapDL.MakeModel.addIRQNode1
                                 Data.Map.Base.Tip
                                 -> case ((CapDL.MakeModel.addIRQMappings
                                             objs
                                             (Data.Map.Base.Tip
                                                @ GHC.Types.Word
                                                @ CapDL.Model.ObjID)
                                             irqs)
                                            `cast`
                                          (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                               <GHC.Types.Word>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <CapDL.Model.IRQMap>_N)
                                            CapDL.MakeModel.addCDTCapDecl1)
                                           `cast`
                                         (Data.Functor.Identity.N:Identity[0]
                                              <(CapDL.Model.IRQMap,
                                                GHC.Types.Word)>_R) of wild3 { (,) x4 ds1 ->
                                    go4 ys x4 } } } }
                 } in
                 go4 eta1 eta) -}
460956886159e39bfce68efaa2f05845
  addIRQs ::
    CapDL.Model.IRQMap
    -> [(GHC.Types.Word, CapDL.Model.ObjID)] -> CapDL.Model.IRQMap
  {- Arity: 2,
     Unfolding: (GHC.List.foldl'
                   @ (GHC.Types.Word, CapDL.Model.ObjID)
                   @ CapDL.Model.IRQMap
                   CapDL.MakeModel.addIRQ) -}
b92789511e16881c0b36a3c90e12544c
  addMapping ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.SlotState
         (CapDL.Model.KernelObject GHC.Types.Word)
  {- Arity: 4, Strictness: <L,U><L,U(U,U)><L,U><L,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (n2 :: CapDL.Model.ObjID)
                   (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (cm :: CapDL.AST.CapMapping) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           GHC.Types.Word
                           Data.Functor.Identity.Identity
                           [(GHC.Types.Word, CapDL.Model.Cap)]
                   = CapDL.MakeModel.slotsAndCapsOf objs n2 cm
                 } in
                 (\ (s1 :: GHC.Types.Word) ->
                  let {
                    ds :: Data.Functor.Identity.Identity
                            ([(GHC.Types.Word, CapDL.Model.Cap)], GHC.Types.Word)
                    = m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Types.Word>_N
                           <Data.Functor.Identity.Identity>_R
                           <[(GHC.Types.Word, CapDL.Model.Cap)]>_N)
                        s1
                  } in
                  (case ds
                          `cast`
                        (Data.Functor.Identity.N:Identity[0]
                             <([(GHC.Types.Word, CapDL.Model.Cap)],
                               GHC.Types.Word)>_R) of wild { (,) a1 s' ->
                   CapDL.MakeModel.addMappings_go a1 obj },
                   case ds
                          `cast`
                        (Data.Functor.Identity.N:Identity[0]
                             <([(GHC.Types.Word, CapDL.Model.Cap)],
                               GHC.Types.Word)>_R) of wild { (,) a1 s' ->
                   s' })
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(CapDL.Model.KernelObject GHC.Types.Word, GHC.Types.Word)>_R)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <GHC.Types.Word>_N
                           <Data.Functor.Identity.Identity>_R
                           <CapDL.Model.KernelObject GHC.Types.Word>_N))) -}
06468a64b2996eaba35c3675fe99ed6f
  addMappings ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> [CapDL.AST.CapMapping]
    -> CapDL.MakeModel.SlotState
         (CapDL.Model.KernelObject GHC.Types.Word)
  {- Arity: 4, Strictness: <L,U><L,U(U,U)><L,U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (n2 :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.KernelObject GHC.Types.Word)
                   (eta1 :: [CapDL.AST.CapMapping]) ->
                 letrec {
                   go4 :: [CapDL.AST.CapMapping]
                          -> CapDL.Model.KernelObject GHC.Types.Word
                          -> Control.Monad.Trans.State.Lazy.StateT
                               GHC.Types.Word
                               Data.Functor.Identity.Identity
                               (CapDL.Model.KernelObject GHC.Types.Word)
                     {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [CapDL.AST.CapMapping])
                       (eta2 :: CapDL.Model.KernelObject GHC.Types.Word) ->
                     case ds of wild {
                       []
                       -> (GHC.Tuple.(,)
                             @ (CapDL.Model.KernelObject GHC.Types.Word)
                             @ GHC.Types.Word
                             eta2)
                            `cast`
                          (Trans
                               (<GHC.Types.Word>_R
                                ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                              <(CapDL.Model.KernelObject GHC.Types.Word,
                                                GHC.Types.Word)>_R))
                               (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                         <GHC.Types.Word>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <CapDL.Model.KernelObject GHC.Types.Word>_N)))
                       : y ys
                       -> let {
                            m1 :: Control.Monad.Trans.State.Lazy.StateT
                                    GHC.Types.Word
                                    Data.Functor.Identity.Identity
                                    [(GHC.Types.Word, CapDL.Model.Cap)]
                            = CapDL.MakeModel.slotsAndCapsOf objs n2 y
                          } in
                          (\ (s1 :: GHC.Types.Word) ->
                           let {
                             ds1 :: Data.Functor.Identity.Identity
                                      ([(GHC.Types.Word, CapDL.Model.Cap)], GHC.Types.Word)
                             = m1
                                 `cast`
                               (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[(GHC.Types.Word, CapDL.Model.Cap)]>_N)
                                 s1
                           } in
                           (go4
                              ys
                              (case ds1
                                      `cast`
                                    (Data.Functor.Identity.N:Identity[0]
                                         <([(GHC.Types.Word, CapDL.Model.Cap)],
                                           GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                               CapDL.MakeModel.addMappings_go a1 eta2 }))
                             `cast`
                           (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <GHC.Types.Word>_N
                                <Data.Functor.Identity.Identity>_R
                                <CapDL.Model.KernelObject GHC.Types.Word>_N)
                             (case ds1
                                     `cast`
                                   (Data.Functor.Identity.N:Identity[0]
                                        <([(GHC.Types.Word, CapDL.Model.Cap)],
                                          GHC.Types.Word)>_R) of wild1 { (,) a1 s' ->
                              s' }))
                            `cast`
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CapDL.Model.KernelObject GHC.Types.Word>_N)) }
                 } in
                 go4 eta1 eta) -}
863ccf215ef071f27449ae142dc6ba95
  addMappings_go ::
    [(GHC.Types.Word, CapDL.Model.Cap)]
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
d32c239ef50a1d04ce03aa587fd67bfd
  addObject ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.Decl -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><S,1*U> -}
18b9c8c21d9fdbe0d43c4e29b1980956
  addObject_$saddObject ::
    CapDL.AST.KODecl
    -> Data.Map.Base.Map
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,U> -}
9360f5674f9db246b9565a55beded77f
  addObjects ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.AST.Decl] -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2,
     Unfolding: (GHC.List.foldl'
                   @ CapDL.AST.Decl
                   @ (CapDL.Model.ObjMap GHC.Types.Word)
                   CapDL.MakeModel.addObject) -}
625a71ea9f7a96197f91f1f9dcf232e8
  addUTCover ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> [CapDL.Model.ObjID]
    -> CapDL.Model.ObjID
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><S,U><L,U><S,U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.CoverMap)
                   (w2 :: [CapDL.Model.ObjID])
                   (w3 :: CapDL.Model.ObjID) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$waddUTCover w w1 w2 ww1 ww2 }) -}
e6fbea98c0446ee4c9d7c71068401dfb
  addUTCovers ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> [CapDL.Model.ObjID]
    -> [CapDL.Model.ObjID]
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><S,U><L,U><S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.ObjMap GHC.Types.Word)
                   (covers :: CapDL.Model.CoverMap)
                   (ds1 :: [CapDL.Model.ObjID])
                   (ds2 :: [CapDL.Model.ObjID]) ->
                 case ds2 of wild {
                   [] -> covers
                   : ut ds3
                   -> case ds3 of wild1 {
                        [] -> CapDL.MakeModel.addUTCover ds covers ds1 ut
                        : ipv ipv1
                        -> case ut of ww { (,) ww1 ww2 ->
                           CapDL.MakeModel.addUTCovers_$saddUTCovers
                             ipv
                             ipv1
                             (GHC.Types.:
                                @ CapDL.Model.ObjID
                                ww
                                (GHC.Types.[] @ CapDL.Model.ObjID))
                             (CapDL.MakeModel.$waddUTCover ds covers ds1 ww1 ww2)
                             ds } } }) -}
b378e34986716bb68b87834e4cf5698b
  addUTCovers_$saddUTCovers ::
    ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> Data.Map.Base.Map
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
         (Data.Set.Base.Set
            ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word))
    -> Data.Map.Base.Map
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.CoverMap
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,U><L,U> -}
88a37776e50998429641179b76bf1759
  addUTDecl ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.CoverMap
    -> CapDL.AST.NameRef
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><S,U(U,U)><S,U><L,1*U(U,1*U)>,
     Unfolding: InlineRule (4, True, False)
                (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ut :: CapDL.Model.ObjID)
                   (covers :: CapDL.Model.CoverMap)
                   (names :: CapDL.AST.NameRef) ->
                 CapDL.MakeModel.addUTCover
                   objs
                   covers
                   (CapDL.MakeModel.refToIDs
                      @ (CapDL.Model.KernelObject GHC.Types.Word)
                      objs
                      names)
                   ut) -}
f3fcfb1bdb0b73acd6fa0ea2eaed7382
  addUTDecls ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.CoverMap
    -> [CapDL.AST.NameRef]
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><L,U(U,U)><S,1*U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ut :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.CoverMap)
                   (eta1 :: [CapDL.AST.NameRef]) ->
                 case eta1 of wild {
                   [] -> eta
                   : y ys
                   -> case ut of ww { (,) ww1 ww2 ->
                      letrec {
                        go4 :: [CapDL.AST.NameRef]
                               -> CapDL.Model.CoverMap -> CapDL.Model.CoverMap
                          {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds :: [CapDL.AST.NameRef]) (eta2 :: CapDL.Model.CoverMap) ->
                          case ds of wild1 {
                            [] -> eta2
                            : y1 ys1
                            -> go4
                                 ys1
                                 (CapDL.MakeModel.$waddUTCover
                                    objs
                                    eta2
                                    (CapDL.MakeModel.refToIDs
                                       @ (CapDL.Model.KernelObject GHC.Types.Word)
                                       objs
                                       y1)
                                    ww1
                                    ww2) }
                      } in
                      go4
                        ys
                        (CapDL.MakeModel.$waddUTCover
                           objs
                           eta
                           (CapDL.MakeModel.refToIDs
                              @ (CapDL.Model.KernelObject GHC.Types.Word)
                              objs
                              y)
                           ww1
                           ww2) } }) -}
41ea063f2ee787671ea40f1c36242ac2
  addUTName ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><S,U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ut :: CapDL.Model.ObjID) ->
                 CapDL.MakeModel.$sinsert_$sgo1
                   @ (CapDL.Model.KernelObject GHC.Types.Word)
                   ut
                   (CapDL.MakeModel.getUTObj objs ut)
                   objs) -}
de22fb524cc8ced9b7aff440e6c4cc92
  addUTNames ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.Model.ObjID] -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ds :: [CapDL.Model.ObjID]) ->
                 case ds of wild {
                   [] -> objs
                   : ut ds1
                   -> case ds1 of wild1 {
                        [] -> CapDL.MakeModel.addUTName objs ut
                        : ipv ipv1
                        -> case ut of ww { (,) ww1 ww2 ->
                           CapDL.MakeModel.addUTNames_$saddUTNames
                             ipv
                             ipv1
                             (CapDL.MakeModel.$w$sgo1
                                @ (CapDL.Model.KernelObject GHC.Types.Word)
                                ww1
                                ww2
                                (CapDL.MakeModel.$wgetUTObj objs ww1 ww2)
                                objs) } } }) -}
af18990556a9660b8042fa0108d9f075
  addUTNames_$saddUTNames ::
    ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> Data.Map.Base.Map
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 3, Strictness: <L,U><L,U><S,U> -}
3af80c2defaffa8e2409842c5a2e3c4b
  addUntyped ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.Decl -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> objs
                   CapDL.AST.ObjDecl ds1
                   -> case ds1 of wild1 { CapDL.AST.KODecl objName obj ->
                      case obj of wild2 { CapDL.AST.Obj ds2 ds3 ds4 ->
                      case ds4 of wild3 {
                        []
                        -> case objName of wild4 {
                             []
                             -> case GHC.List.init2
                                ret_ty (CapDL.Model.ObjMap GHC.Types.Word)
                                of {}
                             : x4 xs
                             -> CapDL.MakeModel.addUTNames
                                  objs
                                  (GHC.Base.map
                                     @ (CapDL.AST.Name, [CapDL.AST.Range])
                                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                     CapDL.MakeModel.refToID
                                     (GHC.List.init1 @ CapDL.AST.NameRef x4 xs)) }
                        : ds5 ds6
                        -> case objName of wild4 {
                             []
                             -> case GHC.List.init2
                                ret_ty (CapDL.Model.ObjMap GHC.Types.Word)
                                of {}
                             : x4 xs
                             -> CapDL.MakeModel.addUntyped_go
                                  (Data.Either.lefts1 @ CapDL.AST.KODecl @ CapDL.AST.NameRef wild3)
                                  (CapDL.MakeModel.addUTNames
                                     objs
                                     (GHC.Base.map
                                        @ (CapDL.AST.Name, [CapDL.AST.Range])
                                        @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                        CapDL.MakeModel.refToID
                                        (GHC.List.init1 @ CapDL.AST.NameRef x4 xs))) } } } } }) -}
793d7972318dface6f756fc9975f30bf
  addUntyped_$saddUntyped ::
    CapDL.AST.KODecl
    -> Data.Map.Base.Map
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,U> -}
5b03642fddf89ee7c7a038245d386b6e
  addUntyped_go ::
    [CapDL.AST.KODecl]
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
1ff0eb1bf9bd270b588087ff8fa9a7fd
  addUntypeds ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.AST.Decl] -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2,
     Unfolding: (GHC.List.foldl'
                   @ CapDL.AST.Decl
                   @ (CapDL.Model.ObjMap GHC.Types.Word)
                   CapDL.MakeModel.addUntyped) -}
d5187b71081e0e90f7677f7637d278d6
  baseName :: CapDL.AST.QName -> CapDL.AST.NameRef
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (GHC.List.last @ CapDL.AST.NameRef) -}
10cb03903d0b2f342c93adcbd9965871
  capCopyGraph ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> [CapDL.AST.Decl]
    -> CapDL.MakeModel.CapRefMappings
  {- Arity: 3, Strictness: <L,U><L,U(U)><S,1*U>,
     Unfolding: (\ (m :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (eta :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl]
                          -> CapDL.MakeModel.CapRefMappings -> CapDL.MakeModel.CapRefMappings
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl])
                       (eta1 :: CapDL.MakeModel.CapRefMappings) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys -> go4 ys (CapDL.MakeModel.addCapCopyRefs m ids eta1 y) }
                 } in
                 go4
                   eta
                   (CapDL.MakeModel.empty
                      @ CapDL.Model.CapRef
                      @ CapDL.Model.CapRef)) -}
f64257ff252188cb87264964c9454981
  capIdents ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.AST.Decl] -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 2, Strictness: <L,U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: [CapDL.AST.Decl]) ->
                 case CapDL.MakeModel.$wcapIdents w w1 of ww { Unit# ww1 ->
                 CapDL.Model.Idents @ CapDL.Model.CapName ww1 }) -}
8cd241def266604a34b985d1d3aacb1c
  capOf ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> [CapDL.AST.CapParam]
    -> CapDL.Model.ObjID
    -> CapDL.Model.Cap
  {- Arity: 4, Strictness: <S,1*U><L,1*U(1*U,1*U)><S,U><S,U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: [CapDL.AST.CapParam])
                   (w3 :: CapDL.Model.ObjID) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wcapOf w w1 w2 ww1 ww2 }) -}
a85dc96598a1d5e64c8893509512a571
  capOf' ::
    CapDL.Model.ObjID
    -> CapDL.AST.Name -> [CapDL.AST.CapParam] -> CapDL.Model.Cap
  {- Arity: 3, Strictness: <L,1*U(1*U,1*U)><S,U><L,1*U>,
     Unfolding: (\ (containerName :: CapDL.Model.ObjID)
                   (capName :: CapDL.AST.Name)
                   (ps :: [CapDL.AST.CapParam]) ->
                 case GHC.Base.eqString capName CapDL.Model.ioSpaceMaster of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             capName
                             CapDL.Model.asidControl of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString capName CapDL.Model.irqControl of wild2 {
                             GHC.Types.False
                             -> case GHC.Base.eqString capName CapDL.Model.domain of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Base.eqString
                                            capName
                                            CapDL.Model.schedControl of wild4 {
                                       GHC.Types.False -> CapDL.MakeModel.capOf'1 capName
                                       GHC.Types.True
                                       -> CapDL.Model.SchedControlCap
                                            (CapDL.MakeModel.getCore containerName ps) }
                                  GHC.Types.True -> CapDL.Model.DomainCap }
                             GHC.Types.True -> CapDL.Model.IRQControlCap }
                        GHC.Types.True -> CapDL.Model.ASIDControlCap }
                   GHC.Types.True -> CapDL.Model.IOSpaceMasterCap }) -}
dae1eeb959e4411be84ea13ce17a952c
  capOf'1 :: CapDL.AST.Name -> CapDL.Model.Cap
  {- Arity: 1, Strictness: <L,U>x -}
3bc756ea932f493352a52ae587433b89
  capOf1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Cap
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
d493467adb27dbede296ef84d084cc1a
  capsOf ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> [CapDL.Model.ObjID]
    -> [CapDL.AST.CapParam]
    -> [CapDL.Model.Cap]
  {- Arity: 4, Strictness: <L,U><L,U(U,U)><S,1*U><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (name :: CapDL.Model.ObjID)
                   (ids :: [CapDL.Model.ObjID])
                   (xs :: [CapDL.AST.CapParam]) ->
                 GHC.Base.build
                   @ CapDL.Model.Cap
                   (\ @ b1
                      (c :: CapDL.Model.Cap -> b1 -> b1)[OneShot]
                      (n2 :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                      @ b1
                      (GHC.Base.mapFB
                         @ CapDL.Model.Cap
                         @ b1
                         @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                         c
                         (CapDL.MakeModel.capOf objs name xs))
                      n2
                      ids)) -}
4127cb761a7910cf819b86ca9f04b567
  checkSlot ::
    GHC.Base.Maybe GHC.Types.Word
    -> CapDL.MakeModel.SlotState GHC.Types.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.checkSlot1
                  `cast`
                (<GHC.Base.Maybe GHC.Types.Word>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Word>_N)) -}
4e45cb505ee35f6ea5fdc2fa0ecf3d99
  checkSlot1 ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Types.Word
    -> Data.Functor.Identity.Identity (GHC.Types.Word, GHC.Types.Word)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Word) (eta :: GHC.Types.Word) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> (case eta of wild1 { GHC.Types.W# x# ->
                       GHC.Types.W# (GHC.Prim.plusWord# x# 1##) },
                       eta)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Word, GHC.Types.Word)>_R))
                   GHC.Base.Just slot
                   -> (slot, eta)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Word, GHC.Types.Word)>_R)) }) -}
b0924169e5aeb7fa26f7b78bce6ecbb1
  containsConstr :: Data.Data.Data b => b -> [b] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
     Unfolding: (\ @ b
                   ($dData :: Data.Data.Data b)
                   (x4 :: b)
                   (xs :: [b]) ->
                 GHC.List.elem
                   @ Data.Data.Constr
                   Data.Data.$fEqConstr
                   (Data.Data.toConstr @ b $dData x4)
                   (GHC.Base.map
                      @ b
                      @ Data.Data.Constr
                      (Data.Data.toConstr @ b $dData)
                      xs)) -}
4f09c36533b5b28dc50abd4ee9b22c0f
  copyCapParams ::
    [CapDL.AST.CapParam] -> CapDL.Model.Cap -> CapDL.Model.Cap
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: (\ (params :: [CapDL.AST.CapParam])
                   (cap :: CapDL.Model.Cap) ->
                 let {
                   $j :: GHC.Prim.Void# -> CapDL.Model.Cap
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       ds :: CapDL.Model.CapRights
                       = case CapDL.MakeModel.getMasked params of wild {
                           Data.Set.Base.Bin ipv ipv1 ipv2 ipv3
                           -> let {
                                $j1 :: GHC.Prim.Int#
                                       -> CapDL.Model.Rights
                                       -> Data.Set.Base.Set CapDL.Model.Rights
                                       -> Data.Set.Base.Set CapDL.Model.Rights
                                       -> Data.Set.Base.Set CapDL.Model.Rights
                                  {- Arity: 4, Strictness: <S,U><L,U><L,U><L,U> -}
                                = \ (ipv4 :: GHC.Prim.Int#)[OneShot]
                                    (ipv5 :: CapDL.Model.Rights)[OneShot]
                                    (ipv6 :: Data.Set.Base.Set CapDL.Model.Rights)[OneShot]
                                    (ipv7 :: Data.Set.Base.Set CapDL.Model.Rights)[OneShot] ->
                                  Data.Set.Base.intersection_$shedgeInt
                                    @ CapDL.Model.Rights
                                    ipv4
                                    ipv5
                                    ipv6
                                    ipv7
                                    ipv
                                    ipv1
                                    ipv2
                                    ipv3
                                    (Data.Set.Base.NothingS @ CapDL.Model.Rights)
                                    (Data.Set.Base.NothingS @ CapDL.Model.Rights)
                                    CapDL.Model.$fOrdRights
                              } in
                              case cap of wild1 {
                                DEFAULT -> CapDL.Model.capRights1
                                CapDL.Model.EndpointCap ds1 ds2 ds3
                                -> case ds3 of wild2 {
                                     Data.Set.Base.Bin ipv4 ipv5 ipv6 ipv7
                                     -> $j1 ipv4 ipv5 ipv6 ipv7
                                     Data.Set.Base.Tip -> Data.Set.Base.Tip @ CapDL.Model.Rights }
                                CapDL.Model.NotificationCap ds1 ds2 ds3
                                -> case ds3 of wild2 {
                                     Data.Set.Base.Bin ipv4 ipv5 ipv6 ipv7
                                     -> $j1 ipv4 ipv5 ipv6 ipv7
                                     Data.Set.Base.Tip -> Data.Set.Base.Tip @ CapDL.Model.Rights }
                                CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                                -> case ds2 of wild2 {
                                     Data.Set.Base.Bin ipv4 ipv5 ipv6 ipv7
                                     -> $j1 ipv4 ipv5 ipv6 ipv7
                                     Data.Set.Base.Tip -> Data.Set.Base.Tip @ CapDL.Model.Rights } }
                           Data.Set.Base.Tip -> Data.Set.Base.Tip @ CapDL.Model.Rights }
                     } in
                     case cap of wild {
                       DEFAULT -> CapDL.MakeModel.copyCapParams1
                       CapDL.Model.EndpointCap ds1 ds2 ds3
                       -> CapDL.Model.EndpointCap ds1 ds2 ds
                       CapDL.Model.NotificationCap ds1 ds2 ds3
                       -> CapDL.Model.NotificationCap ds1 ds2 ds
                       CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                       -> CapDL.Model.FrameCap ds1 ds ds3 ds4 ds5 }
                 } in
                 case cap of wild {
                   DEFAULT -> wild
                   CapDL.Model.EndpointCap ds1 ds2 ds3 -> $j GHC.Prim.void#
                   CapDL.Model.NotificationCap ds1 ds2 ds3 -> $j GHC.Prim.void#
                   CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5 -> $j GHC.Prim.void# }) -}
587ea2ffe37aa21a86a3b433ef9d1a61
  copyCapParams1 :: CapDL.Model.Cap
  {- Strictness: x -}
3d53675ca560f6b39200f162d0289b53
  empty :: a -> GHC.Base.Maybe b
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a @ b (ds :: a) -> GHC.Base.Nothing @ b) -}
e2a07540c2f72fddefd2e3f0044ff1ea
  emptyIdents :: CapDL.Model.Idents cap_id
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ cap_id ->
                 CapDL.Model.Idents
                   @ cap_id
                   (Data.Map.Base.Tip @ cap_id @ CapDL.Model.CapRef)) -}
d0542ecb67270004f614e5f0680e6b42
  emptyModel ::
    CapDL.Model.Arch
    -> CapDL.Model.CDT -> CapDL.Model.CoverMap -> CapDL.Model.Model a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a
                   (arch :: CapDL.Model.Arch)
                   (eta :: CapDL.Model.CDT)
                   (eta1 :: CapDL.Model.CoverMap) ->
                 CapDL.Model.Model
                   @ a
                   arch
                   (Data.Map.Base.Tip
                      @ CapDL.Model.ObjID
                      @ (CapDL.Model.KernelObject a))
                   (Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.ObjID)
                   eta
                   eta1) -}
154252516f7a77b128813616be4fbbd2
  emptyUntyped :: CapDL.Model.KernelObject GHC.Types.Word
  {- HasNoCafRefs, Strictness: m5,
     Unfolding: (CapDL.Model.Untyped
                   @ GHC.Types.Word
                   (GHC.Base.Nothing @ GHC.Types.Word)
                   (GHC.Base.Nothing @ GHC.Types.Word)) -}
cc4276489d02ea7101b2711721d7485b
  funUpd :: GHC.Classes.Eq a => (a -> b) -> a -> b -> a -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,1*C1(U)><L,U><L,1*U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ b
                   ($dEq :: GHC.Classes.Eq a)
                   (f :: a -> b)
                   (x4 :: a)
                   (y :: b)
                   (z :: a) ->
                 case GHC.Classes.== @ a $dEq z x4 of wild {
                   GHC.Types.False -> f z GHC.Types.True -> y }) -}
d8931d285eaed52c8049989d43c0d4be
  getARMIODevice ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
3cbef97787d62e2ccbf35328368555b7
  getAsid ::
    CapDL.Model.ObjID
    -> CapDL.Model.ObjID -> [CapDL.AST.CapParam] -> CapDL.Model.Asid
  {- Arity: 3, Strictness: <L,1*U(1*U,1*U)><L,1*U(1*U,1*U)><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (containerName :: CapDL.Model.ObjID)
                   (objRef :: CapDL.Model.ObjID)
                   (ps :: [CapDL.AST.CapParam]) ->
                 case CapDL.MakeModel.getMaybeAsid ps of wild {
                   GHC.Base.Nothing -> CapDL.MakeModel.getAsid1 containerName objRef
                   GHC.Base.Just asid -> asid }) -}
223ff34009c92d4c740537c74661afd9
  getAsid1 ::
    CapDL.Model.ObjID -> CapDL.Model.ObjID -> CapDL.Model.Asid
  {- Arity: 2, Strictness: <B,1*U(1*U,1*U)><B,1*U(1*U,1*U)>x,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID) (w1 :: CapDL.Model.ObjID) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 CapDL.MakeModel.getAsid2 ww1 ww2 ww4 ww5 } }) -}
64b7ee18b35eda31808c057fb368c6eb
  getAsid2 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Asid
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
2e979b1bd2c8bae27d044e6ee31267f7
  getBadge :: [CapDL.AST.CapParam] -> GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0dc4f233502c4170addb0afd068d1b9c
  getBitSize ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (n2 :: CapDL.AST.Name) (xs :: [CapDL.AST.ObjParam]) ->
                 case CapDL.MakeModel.getMaybeBitSize xs of wild {
                   GHC.Base.Nothing -> CapDL.MakeModel.getBitSize1 n2
                   GHC.Base.Just sz -> sz }) -}
37b4634e38a082761d22efe0b1c4be96
  getBitSize1 :: CapDL.AST.Name -> GHC.Types.Word
  {- Arity: 1, Strictness: <B,U>x -}
d0aa9dcecd593eaa275cf2078c8e1cfc
  getCDTDecl ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CDT -> CapDL.AST.Decl -> CapDL.Model.CDT
  {- Arity: 3, Strictness: <L,U(U)><S,1*U><S,1*U>,
     Unfolding: (\ (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (cdt :: CapDL.Model.CDT)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> cdt
                   CapDL.AST.CDTDecl parent children
                   -> let {
                        k :: CapDL.Model.CapRef
                        = CapDL.MakeModel.slotRefToCapRef ids parent
                      } in
                      letrec {
                        go4 :: [Data.Either.Either CapDL.AST.Decl CapDL.AST.SlotRef]
                               -> CapDL.Model.CDT -> CapDL.Model.CDT
                          {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds1 :: [Data.Either.Either CapDL.AST.Decl CapDL.AST.SlotRef])
                            (eta :: CapDL.Model.CDT) ->
                          case ds1 of wild1 {
                            [] -> eta
                            : y ys -> go4 ys (CapDL.MakeModel.getDeclOrSlotRef ids k eta y) }
                      } in
                      go4 children cdt }) -}
3115ada66c2fc4f9abb14c137b6ef8b6
  getCDTDecl_$sgetCDTDecl ::
    Data.Either.Either
      (([GHC.Types.Char], [CapDL.AST.Range]), GHC.Types.Word)
      ([GHC.Types.Char], [CapDL.AST.Range])
    -> [Data.Either.Either
          CapDL.AST.Decl
          (Data.Either.Either
             (([GHC.Types.Char], [CapDL.AST.Range]), GHC.Types.Word)
             ([GHC.Types.Char], [CapDL.AST.Range]))]
    -> Data.Map.Base.Map
         (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
         (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> CapDL.Model.Idents
         ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,U><L,U><S,1*U><L,U(U)>,
     Unfolding: (\ (sc :: Data.Either.Either
                            (([GHC.Types.Char], [CapDL.AST.Range]), GHC.Types.Word)
                            ([GHC.Types.Char], [CapDL.AST.Range]))
                   (sc1 :: [Data.Either.Either
                              CapDL.AST.Decl
                              (Data.Either.Either
                                 (([GHC.Types.Char], [CapDL.AST.Range]), GHC.Types.Word)
                                 ([GHC.Types.Char], [CapDL.AST.Range]))])
                   (sc2 :: Data.Map.Base.Map
                             (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
                             (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                              GHC.Types.Word))
                   (sc3 :: CapDL.Model.Idents
                             ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)) ->
                 let {
                   k :: CapDL.Model.CapRef = CapDL.MakeModel.slotRefToCapRef sc3 sc
                 } in
                 letrec {
                   go4 :: [Data.Either.Either CapDL.AST.Decl CapDL.AST.SlotRef]
                          -> CapDL.Model.CDT -> CapDL.Model.CDT
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [Data.Either.Either CapDL.AST.Decl CapDL.AST.SlotRef])
                       (eta :: CapDL.Model.CDT) ->
                     case ds of wild {
                       [] -> eta
                       : y ys -> go4 ys (CapDL.MakeModel.getDeclOrSlotRef sc3 k eta y) }
                 } in
                 go4 sc1 sc2) -}
10219b9e81766fdca3d3a5c3ca6c7f20
  getCDTDecls ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> [CapDL.AST.Decl] -> CapDL.Model.CDT
  {- Arity: 2, Strictness: <L,U(U)><S,1*U>,
     Unfolding: (\ (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (eta :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl] -> CapDL.Model.CDT -> CapDL.Model.CDT
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl]) (eta1 :: CapDL.Model.CDT) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys -> go4 ys (CapDL.MakeModel.getCDTDecl ids eta1 y) }
                 } in
                 go4
                   eta
                   (Data.Map.Base.Tip @ CapDL.Model.CapRef @ CapDL.Model.CapRef)) -}
33502ae61ffcacc88722a1c06d04cee0
  getCached :: [CapDL.AST.CapParam] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
8a65653dc182b1f4c09084f8f0c7c4b2
  getCapCopies ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.NameRef
    -> CapDL.Model.CopyMap
    -> CapDL.AST.CapMapping
    -> CapDL.Model.CopyMap
  {- Arity: 5,
     Strictness: <L,U(U)><L,U><S(LS),1*U(U,1*U)><S,1*U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w2 :: CapDL.AST.NameRef)
                   (w3 :: CapDL.Model.CopyMap)
                   (w4 :: CapDL.AST.CapMapping) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wgetCapCopies w w1 ww1 ww2 w3 w4 }) -}
172852b9dbdabab04df423b72a8f0caa
  getCapCopy ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.CopyMap
    -> CapDL.AST.CapMapping
    -> CapDL.Model.CopyMap
  {- Arity: 5, Strictness: <L,1*U(1*U)><L,A><L,U(U,U)><S,1*U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, True)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: CapDL.Model.CopyMap)
                   (w4 :: CapDL.AST.CapMapping) ->
                 CapDL.MakeModel.$wgetCapCopy w w2 w3 w4) -}
d9f3a55d99f2952039712647b9523de1
  getCapCopyDecl ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CopyMap
    -> CapDL.AST.Decl
    -> CapDL.Model.CopyMap
  {- Arity: 4, Strictness: <L,U(U)><L,U><S,1*U><S,1*U>,
     Unfolding: (\ (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (m :: CapDL.Model.ObjMap GHC.Types.Word)
                   (copies :: CapDL.Model.CopyMap)
                   (ds :: CapDL.AST.Decl) ->
                 case ds of wild {
                   DEFAULT -> copies
                   CapDL.AST.CapDecl obj mappings
                   -> letrec {
                        go4 :: [CapDL.AST.CapMapping]
                               -> CapDL.Model.CopyMap -> CapDL.Model.CopyMap
                          {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                        = \ (ds1 :: [CapDL.AST.CapMapping]) (eta :: CapDL.Model.CopyMap) ->
                          case ds1 of wild1 {
                            [] -> eta
                            : y ys -> go4 ys (CapDL.MakeModel.getCapCopies ids m obj eta y) }
                      } in
                      go4 mappings copies }) -}
0922407fe61860aeb6b6a1d34d640e2b
  getCapCopyDecls ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> [CapDL.AST.Decl]
    -> CapDL.Model.CopyMap
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,1*U>,
     Unfolding: (\ (ids :: CapDL.Model.Idents CapDL.Model.CapName)
                   (m :: CapDL.Model.ObjMap GHC.Types.Word)
                   (eta :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl]
                          -> CapDL.Model.CopyMap -> CapDL.Model.CopyMap
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl]) (eta1 :: CapDL.Model.CopyMap) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys -> go4 ys (CapDL.MakeModel.getCapCopyDecl ids m eta1 y) }
                 } in
                 go4
                   eta
                   (Data.Map.Base.Tip @ CapDL.Model.CapRef @ CapDL.Model.CapName)) -}
0413daa3dfcd42fa7b133b6ec2f443f1
  getCore ::
    CapDL.Model.ObjID -> [CapDL.AST.CapParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,1*U(1*U,1*U)><S,1*U> -}
a511a6f2ca89d53b0b3d5c3c3cc49c9c
  getDeclOrSlotRef ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CapRef
    -> CapDL.Model.CDT
    -> Data.Either.Either CapDL.AST.Decl CapDL.AST.SlotRef
    -> CapDL.Model.CDT
  {- Arity: 4, Strictness: <L,U(U)><L,U><S,U><S,1*U> -}
f3f4ccac8128c3cb6f0203d9ded3b5c4
  getDomainID ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
9e63e298ea5ba5cb5d5d7c28510b4cd2
  getExtraInfo ::
    CapDL.AST.Name
    -> [CapDL.AST.ObjParam] -> GHC.Base.Maybe CapDL.Model.TCBExtraInfo
  {- Arity: 2, Strictness: <L,1*U><S,U> -}
97b1dabf7760f375ffd593ab789a827d
  getFaultEP :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
54c07afbcb3e80f4c3eb07bf946497ab
  getGuard :: [CapDL.AST.CapParam] -> GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ae2d208a0396e1d9bce1c62dfd5818aa
  getGuardSize :: [CapDL.AST.CapParam] -> GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b2ea7bac0ded3ae1a0f9aaa4a3316efc
  getIOAPICIrqIoapic :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
2db4cfee40417cc31900f562af287329
  getIOAPICIrqLevel :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
d842a48cb6fc97065af6ee3b9db36bd1
  getIOAPICIrqPin :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
9e60f3c72b7f52d5e2e0ebad6f5ffe73
  getIOAPICIrqPolarity :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
8c5fae97043ca243957e6fce40275cf6
  getInitArguments :: [CapDL.AST.ObjParam] -> [GHC.Types.Word]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
5b2e51318f6aa20fbee62bb1519bf116
  getLevel ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
e693e5f12454984de0ad3534e214954b
  getMSIIrqHandle :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
b20d3aa42472e0ba8d2b58165988dcf8
  getMSIIrqPCIBus :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
c07fa0fb168c5db19dfd0aedbd95ebdd
  getMSIIrqPCIDev :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
cd1a2694bb6967f46cee1959c798c7ed
  getMSIIrqPCIFun :: [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 1, Strictness: <S,1*U> -}
f0116f54650fc48f635ed069b36365f4
  getMasked :: [CapDL.AST.CapParam] -> CapDL.Model.CapRights
  {- Arity: 1, Strictness: <S,1*U> -}
d1b79a23bb01a59954ba4f69f3aaf658
  getMaybeAsid ::
    [CapDL.AST.CapParam] -> GHC.Base.Maybe CapDL.Model.Asid
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b34900f82ea5af5054b8f840a704b40d
  getMaybeBitSize ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
315a233aad2c09b6d0c05e46f2847c6c
  getMaybeFill ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
483d59ff5a23043edf542c0e0ce0ea15
  getMaybeMapping ::
    [CapDL.AST.CapParam]
    -> GHC.Base.Maybe (CapDL.Model.ObjID, GHC.Types.Word)
  {- Arity: 1, Strictness: <S,1*U> -}
2b95f8eaa4cc4bb1e21935b8648abbc0
  getMaybePaddr ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
662bc11e0cb94fb46751d72d386b6125
  getPCIDevice ::
    CapDL.AST.Name
    -> [CapDL.AST.ObjParam]
    -> (GHC.Types.Word, GHC.Types.Word, GHC.Types.Word)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
f19f82d7052a1be04b3e827e1cb108e7
  getPorts ::
    CapDL.AST.Name
    -> [CapDL.AST.ObjParam] -> (GHC.Types.Word, GHC.Types.Word)
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
1af997f31bf1ff51e2f2b7970b63f202
  getReplys :: [CapDL.AST.CapParam] -> [CapDL.AST.CapParam]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
59d4dc1dd585aaf018abb2e2a0f7d591
  getRights :: [CapDL.AST.CapParam] -> CapDL.Model.CapRights
  {- Arity: 1, Strictness: <S,1*U> -}
ca956a7db8e526a299850ee436a10068
  getSCBudget ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Word.Word64
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
32a0d0948a672b545f3dfedab0eda6e5
  getSCData :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bc725bb12156a916ca9c45bc8ad77c42
  getSCExtraInfo ::
    CapDL.AST.Name
    -> [CapDL.AST.ObjParam] -> GHC.Base.Maybe CapDL.Model.SCExtraInfo
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: (\ (n2 :: CapDL.AST.Name)
                   (params :: [CapDL.AST.ObjParam]) ->
                 case CapDL.MakeModel.getSCPeriod params of wild {
                   GHC.Base.Nothing
                   -> case CapDL.MakeModel.getSCBudget params of wild1 {
                        GHC.Base.Nothing
                        -> case CapDL.MakeModel.getSCData params of wild2 {
                             GHC.Base.Nothing -> GHC.Base.Nothing @ CapDL.Model.SCExtraInfo
                             GHC.Base.Just ipv
                             -> CapDL.MakeModel.getSCExtraInfo1
                                  (GHC.Base.Nothing @ GHC.Word.Word64)
                                  wild2
                                  (GHC.Base.Nothing @ GHC.Word.Word64)
                                  n2 }
                        GHC.Base.Just ipv
                        -> CapDL.MakeModel.getSCExtraInfo1
                             (GHC.Base.Nothing @ GHC.Word.Word64)
                             (CapDL.MakeModel.getSCData params)
                             wild1
                             n2 }
                   GHC.Base.Just period
                   -> case CapDL.MakeModel.getSCBudget params of wild1 {
                        GHC.Base.Nothing
                        -> CapDL.MakeModel.getSCExtraInfo1
                             wild
                             (CapDL.MakeModel.getSCData params)
                             (GHC.Base.Nothing @ GHC.Word.Word64)
                             n2
                        GHC.Base.Just budget
                        -> case CapDL.MakeModel.getSCData params of wild2 {
                             GHC.Base.Nothing
                             -> GHC.Base.Just
                                  @ CapDL.Model.SCExtraInfo
                                  (CapDL.Model.SCExtraInfo
                                     wild
                                     wild1
                                     (GHC.Base.Nothing @ GHC.Types.Word))
                             GHC.Base.Just scData
                             -> GHC.Base.Just
                                  @ CapDL.Model.SCExtraInfo
                                  (CapDL.Model.SCExtraInfo wild wild1 wild2) } } }) -}
909a6b199140c2443f1b824667e34e37
  getSCExtraInfo1 ::
    GHC.Base.Maybe GHC.Word.Word64
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Word.Word64
    -> CapDL.AST.Name
    -> GHC.Base.Maybe CapDL.Model.SCExtraInfo
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
b3a0b80f803939aeaeca378745e86a7c
  getSCPeriod ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Word.Word64
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
bea6ad0f593ad8f35f351fc381de9793
  getSlot :: CapDL.MakeModel.SlotState GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.getSlot1
                  `cast`
                (Trans
                     (<GHC.Types.Word>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Word, GHC.Types.Word)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Word>_N))) -}
6d9f35ab3fef55734fbb046f16f363e4
  getSlot1 :: GHC.Types.Word -> (GHC.Types.Word, GHC.Types.Word)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: GHC.Types.Word) ->
                 (case s1 of wild { GHC.Types.W# x# ->
                  GHC.Types.W# (GHC.Prim.plusWord# x# 1##) },
                  s1)) -}
3b9f423d48f7ab0cba4127e1315f428a
  getSlotIRQs ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.SlotState [(GHC.Types.Word, CapDL.Model.ObjID)]
  {- Arity: 3, Strictness: <L,U><S,1*U><L,1*U(U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.getSlotIRQs1
                  `cast`
                (<CapDL.Model.ObjMap GHC.Types.Word>_R
                 ->_R <CapDL.AST.CapMapping>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(GHC.Types.Word, CapDL.Model.ObjID)]>_N)) -}
ada810f97a6b7eea4684adb85891f72d
  getSlotIRQs1 ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.AST.CapMapping
    -> GHC.Types.Word
    -> Data.Functor.Identity.Identity
         ([(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word)
  {- Arity: 3, Strictness: <L,U><S,1*U><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.AST.CapMapping)
                   (w2 :: GHC.Types.Word) ->
                 case CapDL.MakeModel.$wgetSlotIRQs w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([(GHC.Types.Word, CapDL.Model.ObjID)], GHC.Types.Word)>_R)) }) -}
7c187a81a6f35216d2eee1911b682375
  getSrcCap ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.Cap
  {- Arity: 4,
     Strictness: <S(S),1*U(1*U)><C(S),C(U)><S(LSLLL),1*U(A,1*U,A,A,A)><S,U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Idents CapDL.Model.CapName)
                   (w1 :: CapDL.MakeModel.CapRefMappings)
                   (w2 :: CapDL.Model.Model GHC.Types.Word)
                   (w3 :: CapDL.Model.ObjID) ->
                 case w of ww { CapDL.Model.Idents ww1 ->
                 case w2 of ww2 { CapDL.Model.Model ww3 ww4 ww5 ww6 ww7 ->
                 case w3 of ww8 { (,) ww9 ww10 ->
                 CapDL.MakeModel.$wgetSrcCap ww1 w1 ww4 ww9 ww10 } } }) -}
ffaccb360e33fa0b5d8bfabca21cfb80
  getSrcCap1 ::
    CapDL.MakeModel.CapRefMappings
    -> CapDL.Model.CapRef -> CapDL.Model.Cap
  {- Arity: 2, Strictness: <B,C(U)><B,U(U(U,U),U(U))>x,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.MakeModel.CapRefMappings)
                   (w1 :: CapDL.Model.CapRef) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case ww2 of ww6 { GHC.Types.W# ww7 ->
                 CapDL.MakeModel.$wlvl1 w ww4 ww5 ww7 } } }) -}
d4ca3d8a3395e65d179f68064dfdd5cd
  getSrcCap2 ::
    GHC.Base.String -> GHC.Base.Maybe GHC.Types.Word -> CapDL.Model.Cap
  {- Arity: 2, Strictness: <L,U><L,U>x -}
871941c09711afbe7e1a3cbc5e0494d5
  getSrcCap_$stransMappingE ::
    [CapDL.Model.CapRef]
    -> (CapDL.Model.CapRef -> GHC.Base.Maybe CapDL.Model.CapRef)
    -> CapDL.Model.CapRef
    -> CapDL.Model.CapRef
  {- Arity: 3, Strictness: <S,U><C(S),C(U)><L,U(U(U,U),U(U))> -}
c20b1f8af0c06c1f21b5ee36e450cf9d
  getTCBAddr :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
2ba46b9798f7f93e635d5d314835239a
  getTCBDom :: [CapDL.AST.ObjParam] -> GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4af17ae3c81f958d217763d461c8ca4f
  getTCBaffinity ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4a93a4630386ce0f91ebd7cd52f9b361
  getTCBelf :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
48d8d252cedc324cc051ec0193e1c78e
  getTCBip :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
7a23d54118805daa30dc28c29a82b0df
  getTCBmax_prio ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a3c1f763d72215e346539e3142179911
  getTCBprio ::
    [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Integer.Type.Integer
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6fa9824ad4b5238d00229a314037bfce
  getTCBsp :: [CapDL.AST.ObjParam] -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d41663a47e1d7f437ee18d04c1a8df2e
  getUTCov ::
    CapDL.Model.CoverMap -> CapDL.Model.ObjID -> CapDL.Model.ObjSet
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (covers :: CapDL.Model.CoverMap) (ut :: CapDL.Model.ObjID) ->
                 case CapDL.MakeModel.$slookup3
                        @ (Data.Set.Base.Set CapDL.Model.ObjID)
                        ut
                        covers of wild {
                   GHC.Base.Nothing -> Data.Set.Base.Tip @ CapDL.Model.ObjID
                   GHC.Base.Just cov -> cov }) -}
336a29061c5b409a5cdba59d65f2d940
  getUTObj ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,U(U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjMap GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wgetUTObj w ww1 ww2 }) -}
c2e3b38e7d607e49f95d3edb6e58b47d
  getUTObj1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
adfd6533a213bae2d65b9b3418e4afb6
  getUntypedCover ::
    [CapDL.AST.NameRef]
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> CapDL.AST.Decl
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><L,U><S,U><S,1*U> -}
cb10e1ac039e5f9dc1e08dbf062917b7
  getUntypedCovers ::
    [CapDL.AST.NameRef]
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> [CapDL.AST.Decl]
    -> CapDL.Model.CoverMap
  {- Arity: 4, Strictness: <L,U><L,U><S,1*U><S,1*U>,
     Unfolding: (\ (ns :: [CapDL.AST.NameRef])
                   (objs :: CapDL.Model.ObjMap GHC.Types.Word)
                   (eta :: CapDL.Model.CoverMap)
                   (eta1 :: [CapDL.AST.Decl]) ->
                 letrec {
                   go4 :: [CapDL.AST.Decl]
                          -> CapDL.Model.CoverMap -> CapDL.Model.CoverMap
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.AST.Decl]) (eta2 :: CapDL.Model.CoverMap) ->
                     case ds of wild {
                       [] -> eta2
                       : y ys -> go4 ys (CapDL.MakeModel.getUntypedCover ns objs eta2 y) }
                 } in
                 go4 eta1 eta) -}
e0b07345fa3c88b23c7cd8d8ed20720d
  getVMSize ::
    CapDL.AST.Name -> [CapDL.AST.ObjParam] -> GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.AST.Name) (w1 :: [CapDL.AST.ObjParam]) ->
                 case CapDL.MakeModel.$wgetVMSize w w1 of ww { DEFAULT ->
                 GHC.Types.W# ww }) -}
4efe5c970b38111aa938d28ee79c296c
  hasCopy :: [CapDL.AST.CapMapping] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ea9f1019154becfde63a96ea0d575946
  hasUnnumbered :: [CapDL.AST.CapMapping] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6712063c40b56bcf70ac491d211d1da9
  insertCDT ::
    CapDL.Model.CapRef
    -> CapDL.Model.CapRef -> CapDL.Model.CDT -> CapDL.Model.CDT
  {- Arity: 3, Strictness: <S,U(U(U,U),U(U))><L,U><S,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.CapRef)
                   (w1 :: CapDL.Model.CapRef)
                   (w2 :: CapDL.Model.CDT) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$winsertCDT ww1 ww2 w1 w2 }) -}
9e4acfa748c995a21594ee1ddb87f3a8
  insertCapIdentMapping ::
    CapDL.Model.ObjID
    -> CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.Model.CapName
    -> GHC.Types.Word
    -> CapDL.Model.Idents CapDL.Model.CapName
  {- Arity: 4, Strictness: <L,U><S,1*U(1*U)><L,1*U(U,U)><L,U>m,
     Unfolding: InlineRule (4, True, False)
                (\ (obj :: CapDL.Model.ObjID)
                   (ds :: CapDL.Model.Idents CapDL.Model.CapName)
                   (name :: CapDL.Model.CapName)
                   (slot :: GHC.Types.Word) ->
                 case ds of wild { CapDL.Model.Idents ids ->
                 CapDL.Model.Idents
                   @ CapDL.Model.CapName
                   (CapDL.MakeModel.$sinsert_$sgo1
                      @ (CapDL.Model.ObjID, GHC.Types.Word)
                      name
                      (obj, slot)
                      ids) }) -}
6e1b497f083cd5b3813c3076273b53bd
  insertMapping ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> (GHC.Types.Word, CapDL.Model.Cap)
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><S(SL),1*U(U(U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w1 :: (GHC.Types.Word, CapDL.Model.Cap)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.W# ww4 ->
                 CapDL.MakeModel.$winsertMapping w ww4 ww2 } }) -}
2de186eb374764ce13f1f202a1cd000f
  insertMappings ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> [(GHC.Types.Word, CapDL.Model.Cap)]
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2,
     Unfolding: (GHC.List.foldl'
                   @ (GHC.Types.Word, CapDL.Model.Cap)
                   @ (CapDL.Model.KernelObject GHC.Types.Word)
                   CapDL.MakeModel.insertMapping) -}
514f8fdef5ee8db7bb856a3c6af44b24
  insertObjects ::
    [CapDL.Model.ObjID]
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U>,
     Unfolding: (\ (ids :: [CapDL.Model.ObjID])
                   (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (objs :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 letrec {
                   go4 :: [CapDL.Model.ObjID]
                          -> Data.Map.Base.Map
                               CapDL.Model.ObjID (CapDL.Model.KernelObject GHC.Types.Word)
                          -> Data.Map.Base.Map
                               CapDL.Model.ObjID (CapDL.Model.KernelObject GHC.Types.Word)
                     {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
                   = \ (ds :: [CapDL.Model.ObjID])
                       (eta :: Data.Map.Base.Map
                                 CapDL.Model.ObjID (CapDL.Model.KernelObject GHC.Types.Word)) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go4
                            ys
                            (CapDL.MakeModel.$sinsert_$sgo1
                               @ (CapDL.Model.KernelObject GHC.Types.Word)
                               y
                               obj
                               eta) }
                 } in
                 go4 ids objs) -}
52cf0f1d88a17f0d41c2950781337bfc
  isMember ::
    CapDL.AST.Name
    -> CapDL.Model.ObjMap GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Unfolding: (\ (name :: CapDL.AST.Name)
                   (objs :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.MakeModel.$smember_$s$wpoly_go10 objs name of wild {
                   GHC.Types.False
                   -> CapDL.MakeModel.$smember_$s$wpoly_go1 objs 0## name
                   GHC.Types.True -> GHC.Types.True }) -}
302c35d2c2afb26b11c8535e2b170e54
  isUntyped ::
    CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.Untyped ds1 ds2 -> GHC.Types.True }) -}
3f8057f8050231e8382de3965bb71e31
  makeIDs ::
    CapDL.AST.Name
    -> GHC.Base.Maybe GHC.Types.Word -> [CapDL.Model.ObjID]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (name :: CapDL.AST.Name)
                   (ds :: GHC.Base.Maybe GHC.Types.Word) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> GHC.Types.:
                        @ CapDL.Model.ObjID
                        (name, GHC.Base.Nothing @ GHC.Types.Word)
                        (GHC.Types.[] @ CapDL.Model.ObjID)
                   GHC.Base.Just num
                   -> case num of wild1 { GHC.Types.W# x# ->
                      letrec {
                        xs :: [GHC.Base.Maybe GHC.Types.Word]
                              -> [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds1 :: [GHC.Base.Maybe GHC.Types.Word]) ->
                          case ds1 of wild2 {
                            []
                            -> GHC.Types.[] @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                            : y ys
                            -> GHC.Types.:
                                 @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                 (name, y)
                                 (xs ys) }
                      } in
                      let {
                        y :: GHC.Prim.Word# = GHC.Prim.minusWord# x# 1##
                      } in
                      letrec {
                        go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x4 :: GHC.Prim.Word#) ->
                          GHC.Types.:
                            @ (GHC.Base.Maybe GHC.Types.Word)
                            (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x4))
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.eqWord# x4 y) of wild2 {
                               GHC.Types.False -> go4 (GHC.Prim.plusWord# x4 1##)
                               GHC.Types.True -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                      } in
                      xs (go4 0##) } }) -}
284013eb842c3e71ab079786b8538abf
  makeModel ::
    CapDL.AST.Module
    -> (CapDL.Model.Model GHC.Types.Word,
        CapDL.Model.Idents CapDL.Model.CapName, CapDL.Model.CopyMap)
  {- Arity: 1, Strictness: <S,1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.AST.Module) ->
                 case w of ww { CapDL.AST.Module ww1 ww2 ->
                 case CapDL.MakeModel.$wmakeModel
                        ww1
                        ww2 of ww3 { (#,,#) ww4 ww5 ww6 ->
                 (ww4, ww5, ww6) } }) -}
a4ce2b0e6db9f6d19608f3c92c743626
  makeModel_go ::
    [CapDL.AST.Decl]
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
8083bd6b5bacad7cc4f470b6b2324b98
  makeModel_go1 ::
    [CapDL.AST.Decl]
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
61f03e5c247fd11088db01909467bee6
  members ::
    GHC.Classes.Ord k => [k] -> Data.Map.Base.Map k a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                CapDL.MakeModel.members1
                  `cast`
                (forall (k :: <*>_N) (a :: <*>_N).
                 <GHC.Classes.Ord k>_R
                 ->_R <[k]>_R
                 ->_R <Data.Map.Base.Map k a>_R
                 ->_R Data.Monoid.N:All[0]) -}
8d7c7bd446062d14b8306f5271a8a306
  members1 ::
    GHC.Classes.Ord k =>
    [k] -> Data.Map.Base.Map k a -> Data.Monoid.All
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,U>,
     Unfolding: (\ @ k
                   @ a
                   ($dOrd :: GHC.Classes.Ord k)
                   (names :: [k])
                   (objs :: Data.Map.Base.Map k a) ->
                 letrec {
                   go4 :: [k] -> Data.Monoid.All {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [k]) ->
                     case ds of wild {
                       [] -> GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                       : y ys
                       -> case Data.Map.Base.member @ k @ a $dOrd y objs of wild1 {
                            GHC.Types.False
                            -> GHC.Types.False `cast` (Sym (Data.Monoid.N:All[0]))
                            GHC.Types.True -> go4 ys } }
                 } in
                 go4 names) -}
6b23c06bc5d23a775a59a61c94fa89a9
  numConstrs :: Data.Data.Data a => a -> GHC.Types.Int
  {- Arity: 2,
     Strictness: <S(LLLLC(S(LS))LLLLLLLLLL),1*U(A,A,A,A,1*C1(U(1*U,1*U)),A,A,A,A,A,A,A,A,A,A)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Data.Data.Data a) (w1 :: a) ->
                 case CapDL.MakeModel.$wnumConstrs @ a w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
1d14a5d041843e42de96567337844b1b
  numObject ::
    Data.Map.Base.Map CapDL.Model.ObjID a
    -> CapDL.AST.Name -> GHC.Types.Word
  {- Arity: 2, Strictness: <S,U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Map.Base.Map CapDL.Model.ObjID a)
                   (w1 :: CapDL.AST.Name) ->
                 case CapDL.MakeModel.$wnumObject @ a w w1 of ww { DEFAULT ->
                 GHC.Types.W# ww }) -}
984d84706c0090dec7d7ba7e61949cc3
  objCapOf ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> [CapDL.AST.CapParam]
    -> CapDL.Model.Cap
  {- Arity: 4, Strictness: <L,1*U(1*U,1*U)><S,U><L,U(U,U)><S,U>,
     Unfolding: (\ (containerName :: CapDL.Model.ObjID)
                   (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (objRef :: CapDL.Model.ObjID)
                   (params :: [CapDL.AST.CapParam]) ->
                 case CapDL.MakeModel.validCapPars obj params of wild {
                   GHC.Types.False -> CapDL.MakeModel.objCapOf2 containerName objRef
                   GHC.Types.True
                   -> case obj of wild1 {
                        CapDL.Model.Endpoint
                        -> CapDL.Model.EndpointCap
                             objRef
                             (CapDL.MakeModel.getBadge params)
                             (CapDL.MakeModel.getRights params)
                        CapDL.Model.Notification
                        -> CapDL.Model.NotificationCap
                             objRef
                             (CapDL.MakeModel.getBadge params)
                             (CapDL.MakeModel.getRights params)
                        CapDL.Model.TCB ds ds1 ds2 ds3 ds4
                        -> case CapDL.MakeModel.getReplys params of wild2 {
                             [] -> CapDL.Model.TCBCap objRef
                             : ds5 ds6
                             -> case ds5 of wild3 {
                                  DEFAULT -> CapDL.MakeModel.objCapOf1
                                  CapDL.AST.Reply
                                  -> case ds6 of wild4 {
                                       [] -> CapDL.Model.ReplyCap objRef
                                       : ipv ipv1 -> CapDL.MakeModel.objCapOf1 }
                                  CapDL.AST.MasterReply
                                  -> case ds6 of wild4 {
                                       [] -> CapDL.Model.MasterReplyCap objRef
                                       : ipv ipv1 -> CapDL.MakeModel.objCapOf1 } } }
                        CapDL.Model.CNode ds ds1
                        -> case ds1 of wild2 { GHC.Types.W# ds2 ->
                           case ds2 of ds3 {
                             DEFAULT
                             -> CapDL.Model.CNodeCap
                                  objRef
                                  (CapDL.MakeModel.getGuard params)
                                  (CapDL.MakeModel.getGuardSize params)
                             0## -> CapDL.Model.IRQHandlerCap objRef } }
                        CapDL.Model.Untyped ds ds1 -> CapDL.Model.UntypedCap objRef
                        CapDL.Model.SC ds ds1 -> CapDL.Model.SCCap objRef
                        CapDL.Model.RTReply -> CapDL.Model.RTReplyCap objRef
                        CapDL.Model.ASIDPool ds
                        -> CapDL.Model.ASIDPoolCap
                             objRef
                             (CapDL.MakeModel.getAsid containerName objRef params)
                        CapDL.Model.PT ds
                        -> CapDL.Model.PTCap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.PD ds
                        -> CapDL.Model.PDCap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.PDPT ds
                        -> CapDL.Model.PDPTCap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.PML4 ds
                        -> CapDL.Model.PML4Cap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.PUD ds
                        -> CapDL.Model.PUDCap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.PGD ds
                        -> CapDL.Model.PGDCap objRef (CapDL.MakeModel.getMaybeAsid params)
                        CapDL.Model.Frame ds ds1 ds2
                        -> CapDL.Model.FrameCap
                             objRef
                             (CapDL.MakeModel.getRights params)
                             (CapDL.MakeModel.getMaybeAsid params)
                             (CapDL.MakeModel.getCached params)
                             (CapDL.MakeModel.getMaybeMapping params)
                        CapDL.Model.ARMIODevice ds ds1 -> CapDL.Model.ARMIOSpaceCap objRef
                        CapDL.Model.IOPorts ds -> CapDL.Model.IOPortsCap objRef
                        CapDL.Model.IODevice ds ds1 ds2 -> CapDL.Model.IOSpaceCap objRef
                        CapDL.Model.IOPT ds ds1 -> CapDL.Model.IOPTCap objRef
                        CapDL.Model.VCPU -> CapDL.Model.VCPUCap objRef
                        CapDL.Model.IOAPICIrq ds ds1 ds2 ds3 ds4
                        -> CapDL.Model.IRQIOAPICHandlerCap objRef
                        CapDL.Model.MSIIrq ds ds1 ds2 ds3 ds4
                        -> CapDL.Model.IRQMSIHandlerCap objRef } }) -}
4d12c50c2aa0a264856d4e440f55a43d
  objCapOf1 :: CapDL.Model.Cap
  {- Strictness: x -}
ccb5244fba53a76c067dddbb13ea453b
  objCapOf2 ::
    CapDL.Model.ObjID -> CapDL.Model.ObjID -> CapDL.Model.Cap
  {- Arity: 2, Strictness: <B,1*U(1*U,1*U)><B,1*U(1*U,1*U)>x,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID) (w1 :: CapDL.Model.ObjID) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { (,) ww4 ww5 ->
                 CapDL.MakeModel.objCapOf3 ww1 ww2 ww4 ww5 } }) -}
c7a48c2ebe03f40176b28c61375cc1b3
  objCapOf3 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Cap
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>x -}
cce1d8364aeba453bb3701520246bf2a
  objectOf ::
    CapDL.AST.Name
    -> CapDL.AST.KO -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><S(SSL),U(U,U,U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.AST.Name) (w1 :: CapDL.AST.KO) ->
                 case w1 of ww { CapDL.AST.Obj ww1 ww2 ww3 ->
                 CapDL.MakeModel.$wobjectOf w ww1 ww2 ww3 }) -}
0ecac6883029667ca22b4f83323d185c
  orderedSubset :: GHC.Classes.Eq a => [a] -> [a] -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U> -}
bbe1b085445083d70a61a24121457d0b
  orderedSubset_$s$sorderedSubset ::
    [Data.Data.Constr]
    -> Data.Data.ConstrRep
    -> [GHC.Types.Char]
    -> [[GHC.Types.Char]]
    -> Data.Data.Fixity
    -> Data.Data.DataType
    -> [Data.Data.Constr]
    -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,1*U><L,U><L,U><L,U><L,U><L,U><L,U> -}
d3840097e9a0503220e498205747540f
  orderedSubset_$sorderedSubset ::
    [Data.Data.Constr] -> [Data.Data.Constr] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
2d91dac85fdde127b7a472dbe53872bf
  orderedSubset_$sorderedSubset1 ::
    [a] -> a -> [a] -> GHC.Classes.Eq a => GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,1*U><L,U><L,U><L,U(C(C1(U)),A)> -}
029ffbaa628fae8c7871f79c3d437fe4
  printID :: CapDL.Model.ObjID -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.ObjID) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wprintID ww1 ww2 }) -}
a44f0f138ac35fd080ecb5bae2d30c18
  printID1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "]"#) -}
4d530cbcd0bce09832e3dfcf9c9dc9bb
  putSlot :: GHC.Types.Word -> CapDL.MakeModel.SlotState ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m,
     Unfolding: InlineRule (0, True, True)
                (CapDL.MakeModel.$sput @ GHC.Types.Word) -}
75e26aa027f981201ae6cd4cc16311f7
  qNames :: CapDL.AST.QName -> [CapDL.AST.NameRef]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (GHC.List.init @ CapDL.AST.NameRef) -}
1efb72c60e93bbf192ad7d2f25ddaa02
  refToID :: CapDL.AST.NameRef -> CapDL.Model.ObjID
  {- Arity: 1, Strictness: <S(LS),1*U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.AST.NameRef) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of wild {
                   [] -> (ww1, GHC.Base.Nothing @ GHC.Types.Word)
                   : ds ds1
                   -> case ds of wild1 {
                        DEFAULT -> CapDL.MakeModel.$wlvl ww1 wild
                        CapDL.AST.Only n2
                        -> case ds1 of wild2 {
                             [] -> (ww1, GHC.Base.Just @ GHC.Types.Word n2)
                             : ipv ipv1 -> CapDL.MakeModel.$wlvl ww1 wild } } } }) -}
e58a2abeb75ec33a1d58d230cc7a12a0
  refToIDs ::
    Data.Map.Base.Map CapDL.Model.ObjID a
    -> CapDL.AST.NameRef -> [CapDL.Model.ObjID]
  {- Arity: 2, Strictness: <L,U><S(LS),1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Map.Base.Map CapDL.Model.ObjID a)
                   (w1 :: CapDL.AST.NameRef) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 CapDL.MakeModel.$wrefToIDs @ a w ww1 ww2 }) -}
e631e66856cdc48d4d06fe4650b09de6
  refToIDs1 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 0#) -}
175f4456c7982b6143ee35d080c1de04
  refToIDs2 :: CapDL.AST.Name -> GHC.Types.Word
  {- Arity: 1, Strictness: <L,U>x -}
aedbbbd16ec0953cbf912d2dfd219df8
  refToIDs3 :: GHC.Types.Word
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.W# 0##) -}
c9eb2319cce4d64b9d60acfc2a6520c1
  removeConstr :: Data.Data.Data a => a -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U(1*U,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A)><L,U><S,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   (x4 :: a)
                   (xs :: [a]) ->
                 GHC.List.filter
                   @ a
                   (\ (y :: a) ->
                    case Data.Data.toConstr
                           @ a
                           $dData
                           x4 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                    case Data.Data.toConstr
                           @ a
                           $dData
                           y of wild1 { Data.Data.Constr ds5 ds6 ds7 ds8 ds9 ->
                    case Data.Data.$fEqConstr_$c==1 ds ds5 of wild2 {
                      GHC.Types.False -> GHC.Types.True
                      GHC.Types.True -> GHC.Types.False } } })
                   xs) -}
3f0bbb9de91a280f819f00bee2b30473
  sameName ::
    CapDL.Model.ObjID -> CapDL.Model.ObjID -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,A)><S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))
                   (ds1 :: (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)) ->
                 case ds of wild { (,) first ds2 ->
                 case ds1 of wild1 { (,) second ds3 ->
                 GHC.Base.eqString first second } }) -}
0ceae896d6dfb472e0a34922dc558b23
  slotRefToCapRef ::
    CapDL.Model.Idents CapDL.Model.CapName
    -> CapDL.AST.SlotRef -> CapDL.Model.CapRef
  {- Arity: 2, Strictness: <L,1*U(1*U)><S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.Idents CapDL.Model.CapName)
                   (ds1 :: Data.Either.Either
                             (CapDL.AST.NameRef, GHC.Types.Word) CapDL.AST.NameRef) ->
                 case ds1 of wild {
                   Data.Either.Left ds2
                   -> case ds2 of wild1 { (,) obj slot ->
                      (CapDL.MakeModel.refToID obj, slot) }
                   Data.Either.Right name
                   -> case ds of wild1 { CapDL.Model.Idents ds2 ->
                      case name of ww { (,) ww1 ww2 ->
                      case ww2 of wild2 {
                        []
                        -> case CapDL.MakeModel.$slookup_$s$wpoly_go1 ds2 ww1 of wild3 {
                             GHC.Base.Nothing
                             -> CapDL.MakeModel.slotRefToCapRef1
                                  ww1
                                  (GHC.Types.[] @ CapDL.AST.Range)
                             GHC.Base.Just capRef -> capRef }
                        : ds3 ds4
                        -> case ds3 of wild3 {
                             DEFAULT
                             -> case CapDL.MakeModel.$wlvl ww1 wild2
                                ret_ty CapDL.Model.CapRef
                                of {}
                             CapDL.AST.Only n2
                             -> case ds4 of wild4 {
                                  []
                                  -> case CapDL.MakeModel.$slookup_$s$wpoly_go10
                                            ds2
                                            n2
                                            ww1 of wild5 {
                                       GHC.Base.Nothing
                                       -> CapDL.MakeModel.slotRefToCapRef1 ww1 wild2
                                       GHC.Base.Just capRef -> capRef }
                                  : ipv ipv1
                                  -> case CapDL.MakeModel.$wlvl ww1 wild2
                                     ret_ty CapDL.Model.CapRef
                                     of {} } } } } } }) -}
a33f98a4367593135dc62f4e1e07de7d
  slotRefToCapRef1 ::
    CapDL.AST.Name -> [CapDL.AST.Range] -> CapDL.Model.CapRef
  {- Arity: 2, Strictness: <L,U><L,U>x -}
a31b8c6109e7ecc4b909313d6928c14f
  slotsAndCapsOf ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.AST.CapMapping
    -> CapDL.MakeModel.SlotState [(GHC.Types.Word, CapDL.Model.Cap)]
  {- Arity: 3, Strictness: <L,U><L,U(U,U)><S,1*U> -}
204c49012920218c61832460ca69dd7b
  sortConstrs ::
    (Data.Data.Data a, GHC.Classes.Ord a) =>
    a -> a -> GHC.Types.Ordering
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LLLC(S(SLLLL))LLLLLLLLLLL),U(A,A,A,C(U(1*U,A,A,A,A)),A,A,A,A,A,A,A,A,A,A,A)><L,1*U(A,1*C1(C1(U)),A,A,A,A,A,A)><L,U><L,U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   ($dOrd :: GHC.Classes.Ord a)
                   (x4 :: a)
                   (y :: a) ->
                 case Data.Data.toConstr
                        @ a
                        $dData
                        x4 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case Data.Data.toConstr
                        @ a
                        $dData
                        y of wild1 { Data.Data.Constr ds5 ds6 ds7 ds8 ds9 ->
                 case Data.Data.$fEqConstr_$c==1 ds ds5 of wild2 {
                   GHC.Types.False -> GHC.Classes.compare @ a $dOrd x4 y
                   GHC.Types.True -> GHC.Types.EQ } } }) -}
a8934cc9339b2e377960be1892ebb1f1
  sortConstrs1 ::
    CapDL.AST.CapParam -> CapDL.AST.CapParam -> GHC.Types.Ordering
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (x4 :: CapDL.AST.CapParam)
                   (y :: CapDL.AST.CapParam) ->
                 case CapDL.AST.$fDataCapParam_$ctoConstr
                        x4 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case CapDL.AST.$fDataCapParam_$ctoConstr
                        y of wild1 { Data.Data.Constr ds5 ds6 ds7 ds8 ds9 ->
                 case Data.Data.$fEqConstr_$c==1 ds ds5 of wild2 {
                   GHC.Types.False -> CapDL.AST.$fOrdCapParam_$ccompare x4 y
                   GHC.Types.True -> GHC.Types.EQ } } }) -}
03af110ca360c5878feff3a129abf3a8
  sortConstrs2 ::
    CapDL.AST.ObjParam -> CapDL.AST.ObjParam -> GHC.Types.Ordering
  {- Arity: 2, Strictness: <S,U><S,U>,
     Unfolding: (\ (x4 :: CapDL.AST.ObjParam)
                   (y :: CapDL.AST.ObjParam) ->
                 case CapDL.AST.$fDataObjParam_$ctoConstr
                        x4 of wild { Data.Data.Constr ds ds1 ds2 ds3 ds4 ->
                 case CapDL.AST.$fDataObjParam_$ctoConstr
                        y of wild1 { Data.Data.Constr ds5 ds6 ds7 ds8 ds9 ->
                 case Data.Data.$fEqConstr_$c==1 ds ds5 of wild2 {
                   GHC.Types.False -> CapDL.AST.$fOrdObjParam_$ccompare x4 y
                   GHC.Types.True -> GHC.Types.EQ } } }) -}
7afe90278702d1691dbcb7c263af9e41
  subsetConstrs ::
    (Data.Data.Data a, GHC.Classes.Ord a) =>
    [a] -> [a] -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U(U,U,U,U,U)),A,A,A,A,A,A,A,A,A,A,A)><L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><L,1*U>,
     Unfolding: (\ @ a
                   ($dData :: Data.Data.Data a)
                   ($dOrd :: GHC.Classes.Ord a)
                   (xs :: [a])
                   (ys :: [a]) ->
                 CapDL.MakeModel.orderedSubset_$sorderedSubset
                   (GHC.Base.map
                      @ a
                      @ Data.Data.Constr
                      (Data.Data.toConstr @ a $dData)
                      (Data.OldList.sortBy
                         @ a
                         (CapDL.MakeModel.sortConstrs @ a $dData $dOrd)
                         xs))
                   (GHC.Base.map
                      @ a
                      @ Data.Data.Constr
                      (Data.Data.toConstr @ a $dData)
                      (Data.OldList.sortBy
                         @ a
                         (CapDL.MakeModel.sortConstrs @ a $dData $dOrd)
                         ys))) -}
8928e646c2ca5ef77ac6f4348e79655b
  subsetConstrs_$ssubsetConstrs ::
    [CapDL.AST.CapParam] -> [CapDL.AST.CapParam] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (xs :: [CapDL.AST.CapParam])
                   (ys :: [CapDL.AST.CapParam]) ->
                 CapDL.MakeModel.orderedSubset_$sorderedSubset
                   (GHC.Base.map
                      @ CapDL.AST.CapParam
                      @ Data.Data.Constr
                      CapDL.AST.$fDataCapParam_$ctoConstr
                      (Data.OldList.sortBy
                         @ CapDL.AST.CapParam
                         CapDL.MakeModel.sortConstrs1
                         xs))
                   (GHC.Base.map
                      @ CapDL.AST.CapParam
                      @ Data.Data.Constr
                      CapDL.AST.$fDataCapParam_$ctoConstr
                      (Data.OldList.sortBy
                         @ CapDL.AST.CapParam
                         CapDL.MakeModel.sortConstrs1
                         ys))) -}
005434153c1fe0afa6a6f724fb8054ac
  subsetConstrs_$ssubsetConstrs1 ::
    [CapDL.AST.ObjParam] -> [CapDL.AST.ObjParam] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (xs :: [CapDL.AST.ObjParam])
                   (ys :: [CapDL.AST.ObjParam]) ->
                 CapDL.MakeModel.orderedSubset_$sorderedSubset
                   (GHC.Base.map
                      @ CapDL.AST.ObjParam
                      @ Data.Data.Constr
                      CapDL.AST.$fDataObjParam_$ctoConstr
                      (Data.OldList.sortBy
                         @ CapDL.AST.ObjParam
                         CapDL.MakeModel.sortConstrs2
                         xs))
                   (GHC.Base.map
                      @ CapDL.AST.ObjParam
                      @ Data.Data.Constr
                      CapDL.AST.$fDataObjParam_$ctoConstr
                      (Data.OldList.sortBy
                         @ CapDL.AST.ObjParam
                         CapDL.MakeModel.sortConstrs2
                         ys))) -}
7e23bdd2c9f3edbb3d99926a5be9b3ca
  transMapping ::
    (GHC.Show.Show a, GHC.Classes.Eq a) =>
    (a -> GHC.Base.Maybe a) -> a -> a
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   ($dEq :: GHC.Classes.Eq a)
                   (eta :: a -> GHC.Base.Maybe a)
                   (eta1 :: a) ->
                 CapDL.MakeModel.transMappingE
                   @ a
                   $dShow
                   $dEq
                   (GHC.Types.[] @ a)
                   eta
                   eta1) -}
412abadc1a6b7009f3031bfd838f200b
  transMappingE ::
    (GHC.Show.Show a, GHC.Classes.Eq a) =>
    [a] -> (a -> GHC.Base.Maybe a) -> a -> a
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U(C(C1(U)),A)><S,U><C(S),C(U)><L,U> -}
f2acd509973dcd0a29b768a38a4a5a49
  unrange ::
    GHC.Types.Word
    -> CapDL.AST.Range -> [GHC.Base.Maybe GHC.Types.Word]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ (num :: GHC.Types.Word) (range :: CapDL.AST.Range) ->
                 case range of wild {
                   CapDL.AST.Only id
                   -> GHC.Types.:
                        @ (GHC.Base.Maybe GHC.Types.Word)
                        (GHC.Base.Just @ GHC.Types.Word id)
                        (GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word))
                   CapDL.AST.FromTo first last
                   -> case first of wild1 { GHC.Types.W# x4 ->
                      case last of wild2 { GHC.Types.W# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.leWord# x4 y) of wild3 {
                        GHC.Types.False
                        -> let {
                             x5 :: GHC.Prim.Word# = GHC.Prim.minusWord# x4 1##
                           } in
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.geWord# x5 x4) of wild4 {
                             GHC.Types.False
                             -> GHC.Enum.efdtWordDnFB
                                  @ [GHC.Base.Maybe GHC.Types.Word]
                                  CapDL.MakeModel.unrange_c
                                  (GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word))
                                  x4
                                  x5
                                  y
                             GHC.Types.True
                             -> GHC.Enum.efdtWordUpFB
                                  @ [GHC.Base.Maybe GHC.Types.Word]
                                  CapDL.MakeModel.unrange_c
                                  (GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word))
                                  x4
                                  x5
                                  y }
                        GHC.Types.True
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.gtWord# x4 y) of wild4 {
                             GHC.Types.False
                             -> letrec {
                                  go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                                    {- Arity: 1, Strictness: <L,U> -}
                                  = \ (x5 :: GHC.Prim.Word#) ->
                                    GHC.Types.:
                                      @ (GHC.Base.Maybe GHC.Types.Word)
                                      (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x5))
                                      (case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.eqWord# x5 y) of wild5 {
                                         GHC.Types.False -> go4 (GHC.Prim.plusWord# x5 1##)
                                         GHC.Types.True
                                         -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                                } in
                                go4 x4
                             GHC.Types.True
                             -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) } } } }
                   CapDL.AST.From first
                   -> case first of wild1 { GHC.Types.W# x4 ->
                      case num of wild2 { GHC.Types.W# x# ->
                      let {
                        y :: GHC.Prim.Word# = GHC.Prim.minusWord# x# 1##
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.gtWord# x4 y) of wild3 {
                        GHC.Types.False
                        -> letrec {
                             go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                               {- Arity: 1, Strictness: <L,U> -}
                             = \ (x5 :: GHC.Prim.Word#) ->
                               GHC.Types.:
                                 @ (GHC.Base.Maybe GHC.Types.Word)
                                 (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x5))
                                 (case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.eqWord# x5 y) of wild4 {
                                    GHC.Types.False -> go4 (GHC.Prim.plusWord# x5 1##)
                                    GHC.Types.True
                                    -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                           } in
                           go4 x4
                        GHC.Types.True
                        -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) } } }
                   CapDL.AST.To last
                   -> case last of wild1 { GHC.Types.W# y ->
                      letrec {
                        go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x4 :: GHC.Prim.Word#) ->
                          GHC.Types.:
                            @ (GHC.Base.Maybe GHC.Types.Word)
                            (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x4))
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.eqWord# x4 y) of wild2 {
                               GHC.Types.False -> go4 (GHC.Prim.plusWord# x4 1##)
                               GHC.Types.True -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                      } in
                      go4 0## }
                   CapDL.AST.All
                   -> case num of wild1 { GHC.Types.W# x# ->
                      let {
                        y :: GHC.Prim.Word# = GHC.Prim.minusWord# x# 1##
                      } in
                      letrec {
                        go4 :: GHC.Prim.Word# -> [GHC.Base.Maybe GHC.Types.Word]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x4 :: GHC.Prim.Word#) ->
                          GHC.Types.:
                            @ (GHC.Base.Maybe GHC.Types.Word)
                            (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# x4))
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.eqWord# x4 y) of wild2 {
                               GHC.Types.False -> go4 (GHC.Prim.plusWord# x4 1##)
                               GHC.Types.True -> GHC.Types.[] @ (GHC.Base.Maybe GHC.Types.Word) })
                      } in
                      go4 0## } }) -}
c98636142ec82b4f7591348015d87bc4
  unrange_c ::
    GHC.Types.Word
    -> [GHC.Base.Maybe GHC.Types.Word]
    -> [GHC.Base.Maybe GHC.Types.Word]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x4 :: GHC.Types.Word)
                   (ys :: [GHC.Base.Maybe GHC.Types.Word]) ->
                 GHC.Types.:
                   @ (GHC.Base.Maybe GHC.Types.Word)
                   (GHC.Base.Just @ GHC.Types.Word x4)
                   ys) -}
2e873fbc4cb23b7bd75b061f164172fa
  validCapPars ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> [CapDL.AST.CapParam] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,U> -}
82f0cd026f5113625de7881412753fe6
  validCapPars' ::
    CapDL.AST.Name -> [CapDL.AST.CapParam] -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (name :: CapDL.AST.Name)
                   (ps :: [CapDL.AST.CapParam]) ->
                 case GHC.Base.eqString name CapDL.Model.schedControl of wild {
                   GHC.Types.False -> GHC.List.null @ CapDL.AST.CapParam ps
                   GHC.Types.True
                   -> CapDL.MakeModel.subsetConstrs_$ssubsetConstrs
                        ps
                        CapDL.MakeModel.validCapPars'1 }) -}
91f5a5442d7958c31b8fdcb4770fd27b
  validCapPars'1 :: [CapDL.AST.CapParam]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ CapDL.AST.CapParam
                   CapDL.MakeModel.validCapPars'2
                   (GHC.Types.[] @ CapDL.AST.CapParam)) -}
6324e39669aade3036cbf3f95343b33f
  validCapPars'2 :: CapDL.AST.CapParam
  {- Strictness: m7,
     Unfolding: (CapDL.AST.Core CapDL.MakeModel.validCapPars'3) -}
e02a4aadb9707a4522cd873e0a2c043a
  validCapPars'3 :: GHC.Types.Word
  {- Strictness: x -}
655cbafeafb3217570c2f5df2477437b
  validMapping :: [CapDL.AST.CapMapping] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (mappings :: [CapDL.AST.CapMapping]) ->
                 case CapDL.MakeModel.hasCopy mappings of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case CapDL.MakeModel.hasUnnumbered mappings of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
3527bc021a0d6133321ebad610111792
  validObjPars :: CapDL.AST.KO -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S(SSL),1*U(1*U,U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.AST.KO) ->
                 case w of ww { CapDL.AST.Obj ww1 ww2 ww3 ->
                 CapDL.MakeModel.$wvalidObjPars ww1 ww2 ww3 }) -}
"SC:$sorderedSubset0" [ALWAYS] forall (sc :: [Data.Data.Constr])
                                      (sc1 :: Data.Data.ConstrRep)
                                      (sc2 :: [GHC.Types.Char])
                                      (sc3 :: [[GHC.Types.Char]])
                                      (sc4 :: Data.Data.Fixity)
                                      (sc5 :: Data.Data.DataType)
                                      (sc6 :: [Data.Data.Constr])
  CapDL.MakeModel.orderedSubset_$sorderedSubset (GHC.Types.:
                                                   @ Data.Data.Constr
                                                   (Data.Data.Constr sc1 sc2 sc3 sc4 sc5)
                                                   sc6)
                                                sc
  = CapDL.MakeModel.orderedSubset_$s$sorderedSubset
      sc
      sc1
      sc2
      sc3
      sc4
      sc5
      sc6
"SC:$w$sgo100" [0] forall (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                   (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                    GHC.Types.Word))
                          (sc1 :: (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                   GHC.Types.Word))
                          (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo1 @ (CapDL.Model.ObjID, GHC.Types.Word)
                          sc2
                          (GHC.Base.Nothing @ GHC.Types.Word)
                          sc1
                          sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo10 sc sc1 sc2
"SC:$w$sgo101" [0] forall @ a1
                          (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1)
                          (sc1 :: a1)
                          (sc2 :: GHC.Types.Word)
                          (sc3 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo1 @ a1
                          sc3
                          (GHC.Base.Just @ GHC.Types.Word sc2)
                          sc1
                          sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo4 @ a1 sc sc1 sc2 sc3
"SC:$w$sgo102" [0] forall @ a1
                          (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1)
                          (sc1 :: a1)
                          (sc2 :: GHC.Prim.Word#)
                          (sc3 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo1 @ a1
                          sc3
                          (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc2))
                          sc1
                          sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo3 @ a1 sc sc1 sc2 sc3
"SC:$w$sgo50" [0] forall (sc :: Data.Set.Base.Set
                                  ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word))
                         (sc1 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo5 sc1 (GHC.Base.Nothing @ GHC.Types.Word) sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo2 sc sc1
"SC:$w$sgo51" [0] forall (sc :: Data.Set.Base.Set
                                  ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word))
                         (sc1 :: GHC.Types.Word)
                         (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo5 sc2 (GHC.Base.Just @ GHC.Types.Word sc1) sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo1 sc sc1 sc2
"SC:$w$sgo52" [0] forall (sc :: Data.Set.Base.Set
                                  ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word))
                         (sc1 :: GHC.Prim.Word#)
                         (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$w$sgo5 sc2
                          (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc1))
                          sc
  = CapDL.MakeModel.$sinsert_$s$w$sgo5 sc sc1 sc2
"SC:$wpoly_go100" [0] forall (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                       GHC.Types.Word))
                             (sc1 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go1 @ (CapDL.Model.ObjID, GHC.Types.Word)
                             sc1
                             (GHC.Base.Nothing @ GHC.Types.Word)
                             sc
  = CapDL.MakeModel.$slookup_$s$wpoly_go1 sc sc1
"SC:$wpoly_go100" [0] forall (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                      (CapDL.Model.KernelObject GHC.Types.Word))
                             (sc1 :: GHC.Prim.Word#)
                             (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go2 @ (CapDL.Model.KernelObject
                                  GHC.Types.Word)
                             sc2
                             (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc1))
                             sc
  = CapDL.MakeModel.$smember_$s$wpoly_go1 sc sc1 sc2
"SC:$wpoly_go101" [0] forall (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                       GHC.Types.Word))
                             (sc1 :: GHC.Types.Word)
                             (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go1 @ (CapDL.Model.ObjID, GHC.Types.Word)
                             sc2
                             (GHC.Base.Just @ GHC.Types.Word sc1)
                             sc
  = CapDL.MakeModel.$slookup_$s$wpoly_go10 sc sc1 sc2
"SC:$wpoly_go101" [0] forall (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                      (CapDL.Model.KernelObject GHC.Types.Word))
                             (sc1 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go2 @ (CapDL.Model.KernelObject
                                  GHC.Types.Word)
                             sc1
                             (GHC.Base.Nothing @ GHC.Types.Word)
                             sc
  = CapDL.MakeModel.$smember_$s$wpoly_go10 sc sc1
"SC:$wpoly_go102" [0] forall (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                      (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                       GHC.Types.Word))
                             (sc1 :: GHC.Prim.Word#)
                             (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go1 @ (CapDL.Model.ObjID, GHC.Types.Word)
                             sc2
                             (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc1))
                             sc
  = CapDL.MakeModel.$slookup_$s$wpoly_go2 sc sc1 sc2
"SC:$wpoly_go102" [0] forall @ a
                             (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a)
                             (sc1 :: GHC.Types.Word)
                             (sc2 :: [GHC.Types.Char])
  CapDL.MakeModel.$wpoly_go2 @ a
                             sc2
                             (GHC.Base.Just @ GHC.Types.Word sc1)
                             sc
  = CapDL.MakeModel.$smember_$s$wpoly_go2 @ a sc sc1 sc2
"SC:addObject0" [ALWAYS] forall (sc :: CapDL.AST.KODecl)
                                (sc1 :: Data.Map.Base.Map
                                          ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                          (CapDL.Model.KernelObject GHC.Types.Word))
  CapDL.MakeModel.addObject sc1 (CapDL.AST.ObjDecl sc)
  = CapDL.MakeModel.addObject_$saddObject sc sc1
"SC:addUTCovers0" [ALWAYS] forall (sc :: ([GHC.Types.Char],
                                          GHC.Base.Maybe GHC.Types.Word))
                                  (sc1 :: [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)])
                                  (sc2 :: [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)])
                                  (sc3 :: Data.Map.Base.Map
                                            ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                            (Data.Set.Base.Set
                                               ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)))
                                  (sc4 :: Data.Map.Base.Map
                                            ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                            (CapDL.Model.KernelObject GHC.Types.Word))
  CapDL.MakeModel.addUTCovers sc4
                              sc3
                              sc2
                              (GHC.Types.: @ CapDL.Model.ObjID sc sc1)
  = CapDL.MakeModel.addUTCovers_$saddUTCovers sc sc1 sc2 sc3 sc4
"SC:addUTNames0" [ALWAYS] forall (sc :: ([GHC.Types.Char],
                                         GHC.Base.Maybe GHC.Types.Word))
                                 (sc1 :: [([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)])
                                 (sc2 :: Data.Map.Base.Map
                                           ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                           (CapDL.Model.KernelObject GHC.Types.Word))
  CapDL.MakeModel.addUTNames sc2
                             (GHC.Types.: @ CapDL.Model.ObjID sc sc1)
  = CapDL.MakeModel.addUTNames_$saddUTNames sc sc1 sc2
"SC:addUntyped0" [ALWAYS] forall (sc :: CapDL.AST.KODecl)
                                 (sc1 :: Data.Map.Base.Map
                                           ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                           (CapDL.Model.KernelObject GHC.Types.Word))
  CapDL.MakeModel.addUntyped sc1 (CapDL.AST.ObjDecl sc)
  = CapDL.MakeModel.addUntyped_$saddUntyped sc sc1
"SC:getCDTDecl0" [ALWAYS] forall (sc :: Data.Either.Either
                                          (([GHC.Types.Char], [CapDL.AST.Range]), GHC.Types.Word)
                                          ([GHC.Types.Char], [CapDL.AST.Range]))
                                 (sc1 :: [Data.Either.Either
                                            CapDL.AST.Decl
                                            (Data.Either.Either
                                               (([GHC.Types.Char], [CapDL.AST.Range]),
                                                GHC.Types.Word)
                                               ([GHC.Types.Char], [CapDL.AST.Range]))])
                                 (sc2 :: Data.Map.Base.Map
                                           (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                            GHC.Types.Word)
                                           (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                            GHC.Types.Word))
                                 (sc3 :: CapDL.Model.Idents
                                           ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word))
  CapDL.MakeModel.getCDTDecl sc3 sc2 (CapDL.AST.CDTDecl sc sc1)
  = CapDL.MakeModel.getCDTDecl_$sgetCDTDecl sc sc1 sc2 sc3
"SC:orderedSubset0" [ALWAYS] forall @ a
                                    (sc :: [a])
                                    (sc1 :: a)
                                    (sc2 :: [a])
                                    (sc3 :: GHC.Classes.Eq a)
  CapDL.MakeModel.orderedSubset @ a sc3 (GHC.Types.: @ a sc1 sc2) sc
  = CapDL.MakeModel.orderedSubset_$sorderedSubset1 @ a sc sc1 sc2 sc3
"SPEC orderedSubset @ Constr" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                         Data.Data.Constr)
  CapDL.MakeModel.orderedSubset @ Data.Data.Constr $dEq
  = CapDL.MakeModel.orderedSubset_$sorderedSubset
"SPEC sortConstrs @ CapParam" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                          CapDL.AST.CapParam)
                                              ($dData :: Data.Data.Data CapDL.AST.CapParam)
  CapDL.MakeModel.sortConstrs @ CapDL.AST.CapParam $dData $dOrd
  = CapDL.MakeModel.sortConstrs1
"SPEC sortConstrs @ ObjParam" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                          CapDL.AST.ObjParam)
                                              ($dData :: Data.Data.Data CapDL.AST.ObjParam)
  CapDL.MakeModel.sortConstrs @ CapDL.AST.ObjParam $dData $dOrd
  = CapDL.MakeModel.sortConstrs2
"SPEC subsetConstrs @ CapParam" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                            CapDL.AST.CapParam)
                                                ($dData :: Data.Data.Data CapDL.AST.CapParam)
  CapDL.MakeModel.subsetConstrs @ CapDL.AST.CapParam $dData $dOrd
  = CapDL.MakeModel.subsetConstrs_$ssubsetConstrs
"SPEC subsetConstrs @ ObjParam" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                            CapDL.AST.ObjParam)
                                                ($dData :: Data.Data.Data CapDL.AST.ObjParam)
  CapDL.MakeModel.subsetConstrs @ CapDL.AST.ObjParam $dData $dOrd
  = CapDL.MakeModel.subsetConstrs_$ssubsetConstrs1
"SPEC transMappingE @ CapRef" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                         CapDL.Model.CapRef)
                                              ($dShow :: GHC.Show.Show CapDL.Model.CapRef)
  CapDL.MakeModel.transMappingE @ (CapDL.Model.ObjID, GHC.Types.Word)
                                $dShow
                                $dEq
  = CapDL.MakeModel.getSrcCap_$stransMappingE
"SPEC/CapDL.MakeModel $fEq(,) @ (String, Maybe Word) @ Word" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                         GHC.Types.Word)
                                                                             ($dEq :: GHC.Classes.Eq
                                                                                        (GHC.Base.String,
                                                                                         GHC.Base.Maybe
                                                                                           GHC.Types.Word))
  GHC.Classes.$fEq(,) @ (GHC.Base.String,
                         GHC.Base.Maybe GHC.Types.Word)
                      @ GHC.Types.Word
                      $dEq
                      $dEq1
  = CapDL.MakeModel.$s$fEq(,)2
"SPEC/CapDL.MakeModel $fEq(,) @ [Char] @ (Maybe Word)" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                   (GHC.Base.Maybe
                                                                                      GHC.Types.Word))
                                                                       ($dEq :: GHC.Classes.Eq
                                                                                  [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ (GHC.Base.Maybe GHC.Types.Word)
                      $dEq
                      $dEq1
  = CapDL.MakeModel.$s$fEq(,)
"SPEC/CapDL.MakeModel $fEqMaybe @ Word" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                   GHC.Types.Word)
  GHC.Base.$fEqMaybe @ GHC.Types.Word $dEq
  = CapDL.MakeModel.$s$fEq(,)_$s$fEqMaybe
"SPEC/CapDL.MakeModel $fOrd(,)_$cp1Ord @ [Char] @ (Maybe Word)" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                                             (GHC.Base.Maybe
                                                                                                GHC.Types.Word))
                                                                                ($dOrd :: GHC.Classes.Ord
                                                                                            [GHC.Types.Char])
  GHC.Classes.$fOrd(,)_$cp1Ord @ [GHC.Types.Char]
                               @ (GHC.Base.Maybe GHC.Types.Word)
                               $dOrd
                               $dOrd1
  = CapDL.MakeModel.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
"SPEC/CapDL.MakeModel put @ Identity _" [ALWAYS] forall @ s
                                                        ($dMonad :: GHC.Base.Monad
                                                                      Data.Functor.Identity.Identity)
  Control.Monad.Trans.State.Lazy.put @ Data.Functor.Identity.Identity
                                     @ s
                                     $dMonad
  = CapDL.MakeModel.$sput @ s
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

