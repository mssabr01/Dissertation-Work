
==================== FINAL INTERFACE ====================
2018-12-23 21:11:40.409587 UTC

interface main@main:CapDL.State 8002
  interface hash: 6173ca6fceaf8808183142a932093790
  ABI hash: fa4e01b6464f59636102c2c595e82527
  export-list hash: ad43b37a513c35266b5b5dfd897c0f17
  orphan hash: 7d003576a1ca6b7d1f217170cdb0a178
  flag hash: a285d281843002008f986e4fe011c128
  sig of: Nothing
  used TH splices: False
  where
exports:
  CapDL.State.allCovers
  CapDL.State.allLevels
  CapDL.State.allM
  CapDL.State.allMappings
  CapDL.State.allObjs
  CapDL.State.allSlots
  CapDL.State.cNodeSlots
  CapDL.State.capLookup
  CapDL.State.capSpace
  CapDL.State.capSpaceLookup
  CapDL.State.capTyp
  CapDL.State.checkASID
  CapDL.State.checkCapArch
  CapDL.State.checkCovers
  CapDL.State.checkDuplicateMappedFrameCaps
  CapDL.State.checkIRQ
  CapDL.State.checkIRQNode
  CapDL.State.checkMappedFrameCaps
  CapDL.State.checkMappedFrameCapsOnlyInCNodes
  CapDL.State.checkMappedFrameCapsSanity
  CapDL.State.checkMapping
  CapDL.State.checkMappingSanity
  CapDL.State.checkMappingSlotSanity
  CapDL.State.checkMappings
  CapDL.State.checkModel
  CapDL.State.checkObj
  CapDL.State.checkObjArch
  CapDL.State.checkObjectContainsNoMappedFrameCap
  CapDL.State.checkObjs
  CapDL.State.checkPD
  CapDL.State.checkTypAt
  CapDL.State.checkUntyped
  CapDL.State.checkUntypedCover
  CapDL.State.checkUntypedCovers
  CapDL.State.checkUntypeds
  CapDL.State.checkValidCap
  CapDL.State.checkValidCaps
  CapDL.State.checkValidSlot
  CapDL.State.checkValidSlots
  CapDL.State.cspace
  CapDL.State.cspaceCap
  CapDL.State.findDuplicates
  CapDL.State.findSlotCaps
  CapDL.State.findSlotCapsWithRef
  CapDL.State.findSlots
  CapDL.State.flatten
  CapDL.State.flatten'
  CapDL.State.flattenCNodeSlots
  CapDL.State.flattenCnode
  CapDL.State.flattenIOPT
  CapDL.State.flattenPD
  CapDL.State.getCovered
  CapDL.State.getSlots
  CapDL.State.getSlotsFromKernelObject
  CapDL.State.hasTarget
  CapDL.State.ioptSlots
  CapDL.State.isASID
  CapDL.State.isCNode
  CapDL.State.isFrame
  CapDL.State.isIRQ
  CapDL.State.isMapped
  CapDL.State.isMappedFrameCap
  CapDL.State.isObject
  CapDL.State.isPD
  CapDL.State.koType
  CapDL.State.lookupOf
  CapDL.State.mapKeys
  CapDL.State.mapVals
  CapDL.State.mapWithKey
  CapDL.State.maxDepth
  CapDL.State.maybeObjID
  CapDL.State.maybeObject
  CapDL.State.maybeSlotCap
  CapDL.State.modifyObject
  CapDL.State.nextLevel
  CapDL.State.nextLookup
  CapDL.State.nullIntersections
  CapDL.State.objAt
  CapDL.State.objSlots
  CapDL.State.object
  CapDL.State.pdSlots
  CapDL.State.refSlots
  CapDL.State.removeCap
  CapDL.State.sameID
  CapDL.State.setCap
  CapDL.State.setCovered
  CapDL.State.setObject
  CapDL.State.setSlots
  CapDL.State.singleton
  CapDL.State.slotCap
  CapDL.State.slotsOf
  CapDL.State.slotsOfMaybe
  CapDL.State.snoc
  CapDL.State.typAt
  CapDL.State.uniqueASID
  CapDL.State.uniquePD
  CapDL.State.validCapArch
  CapDL.State.validIRQ
  CapDL.State.validObjArch
  CapDL.State.validObjCap
  CapDL.State.CapLookup
  CapDL.State.Kernel
  CapDL.State.Logger
  CapDL.State.SlotsLookup
module dependencies: CapDL.Model
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      pretty-1.1.3.3@pretty-1.1.3.3
                      transformers-0.5.2.0@transformers-0.5.2.0
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.Annotated.HughesPJ
                         pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Maybe d876c4ffe4b3c43755a781e8ad860d88
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22:Data.List.Compat 418dd9bb7e30a0545524709bdb407f11
import  -/  base-compat-0.9.3@base-compat-0.9.3-KeJp8zYMpcS9WibvTcxU22:Prelude.Compat 26d0dbb9ddc9475bb1179736f86de98b
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d432f6875983131473086af8cb290590
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 192db525847d66243089501d3ee84714
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  CapDL.Model 8e26b32fabef412aa2e46767667c26cb
  exports: 194cc77771ecdac5cfada74519b29912
  AARCH64 ff211425a2334cac250222f279c5cfee
  ARM11 8f179bddb716d335769c19533d0eaf6b
  ARMIODevice 8d08fd1166b8de2048c52e2b9ba46fc9
  ARMIODevice_T 599f9fcaf92961056c4cc646fbff4f97
  ARMIOSpaceCap 244266543b9bb53794fb556e30a4fa22
  ASIDControlCap a3104e7f04f2308bce70b72a9539f64c
  ASIDPool ba5104d1532a081bc49c891060909aeb
  ASIDPoolCap 220dabb0361563f94fe2205d48394fdd
  ASIDPool_T b671a907c79754d0df1e018dc6b8950d
  Arch 26cd7f1c4f2288b82107a65f43631900
  CNode 693211dc12ef4126b116f6e95fe7e75f
  CNodeCap 590fd2c6f6ecf22b2eeebcb996881e19
  CNode_T 468124b4eb5837ca3ee0b172e04091e4
  Cap 2a21d35a68336a201f9362f96f90a464
  CapMap 2b3c9fb77110f866f8b91e1409ce1aa7
  CapRef 577051ad5ff1ec257c722ca2a90ffb32
  DomainCap 206cd7d1fdbf05217e0afd4b921ec586
  Endpoint c7cea90dd68aeb74658e3b6beaf32a8c
  EndpointCap de93c9c099a382fb6d594d38dffc515f
  Endpoint_T 0103099ef460e7ce58411a9d0616b799
  Frame a1a72eb2098660223f462524f6d64cf1
  FrameCap 358500e6ad48a24c1af7b4eeb9abeeaa
  Frame_T 713a80bd39eafdccf4bd9a6d79beb900
  IA32 4a47723a0b2e7b28dfcc254a49b5bf41
  IOAPICIrq 9f24f8ed20ffbab428657aae84561aad
  IOAPICIrqSlot_T 80e0f7a144e9d7021dce388ca2ff895b
  IODevice f669911d54b94953bc180cecc4b80eea
  IODevice_T ab0566da36d763cc5c5a1a7313820aed
  IOPT 1988dd5bdc0c2470efd93a0d63e68922
  IOPTCap eeb4d7ba3197f880fcb4c3b77fe2bc10
  IOPT_T bfbcbf62586a2b16bef1ea108e5922b7
  IOPorts 49268bae7609d49418f5b50e0677c646
  IOPortsCap 377691fc07b5c1d255b3fc9dda6ec5ae
  IOPorts_T d4a31ca77a94ca320eef79df2bda4155
  IOSpaceCap 6673a14c764d87aa3a2ba80ca2d617d4
  IOSpaceMasterCap df07f42b3a4dffbb476c3f95a4616c55
  IRQControlCap babd09b93c0c2ddc43877f1de09ef9b3
  IRQHandlerCap 3f111314ce395ab293e006573af72663
  IRQIOAPICHandlerCap 7de4cff137d170defd36aaf06926d5ae
  IRQMSIHandlerCap 26b9b7fb929e0c2f4ebda5b275885208
  KOType f43d8405aa414b65a37ef3915650820e
  KernelObject 74facc4ab534e001bd4ca07a143628e7
  MSIIrq 7807e4bd04f2b57c12200eeed8d32cd1
  MSIIrqSlot_T e11b94044ec48c858435f8098ed9eeef
  MasterReplyCap 8d2e215096b21052f109b41a538449e6
  Model df1f00d4fc6384f8455b17f2f30da3ed
  Model 589b7c47d95fa3c92cab05c02d9ec104
  Notification 7bfb9587626e7f2e148fb306f316d71e
  NotificationCap 063382f0af99af375a364faf442ece26
  Notification_T 6e218f8732a4a2298542d80c713aa521
  NullCap 8c7613d0a705ef268c687dd8eecdf246
  ObjID 79624deef3a276329daf8841ec6c4e4b
  ObjMap 4211baa280b570e4c761bd30aa346582
  ObjSet 111c787764dac1efc754aa81b5769320
  PD a3f7eeb64b66c2523cdbb5294fc559f8
  PDCap a94a62f40927fc7b39a00d764e98d22d
  PDPT c05bab1de4197b6570ed51849b26fbe2
  PDPTCap da168249856e97a7ec7799fc57050a3d
  PDPT_T d90c90163da7b8d081d208a36bfd6c3a
  PD_T e601f2030044f920e821cf948c7c4890
  PGD c636cf4902f9f85b500efdb960d51164
  PGDCap 13b6ea7c08f70d272ef7dde0819f0eb7
  PGD_T 43727f9bf763053d937ae1e0aa9d8574
  PML4 9fb7f4f98ca95bc9722aa291c7cf87e8
  PML4Cap 3c7b81cf4fe38138c153a3ebec74925a
  PML4_T 0a9facae3d6263a15031bd9681ec63be
  PT 47267c52f19b6b6c3dc0112098310e54
  PTCap 1264048166584f595250e46b1190742c
  PT_T 1119ee50cfdd3c370e13d27f5e21dc9a
  PUD 6b9a2fb014f7e9737d85cbf5fa5b2a67
  PUDCap f060a900c8c1100c942bd75887e983cb
  PUD_T 3b00b8a3f3c76a89ab799c4689065ff3
  RTReply d0ea798641d6a73ce7571d1e08711c4c
  RTReplyCap 0c5f43140b19aae3ce24409078489145
  RTReply_T 2ed06a99420445f4cd797b757c11c36f
  ReplyCap a5ef6bb715de4ce692cfb4d00d75748a
  SC 281c858ee2e9992504088a82b2e1efe8
  SCCap 491f26c4528f4790d9f8d78bc359d796
  SC_T 815944868db889e6e2b25df1777c9cb5
  SchedControlCap 800551c2b0416e5048788d34d608fac4
  TCB 226edd638c439891141a4bdf9d407698
  TCBCap 381122f5a4889633fde5616ee62a3ac6
  TCB_T d63337a7c5175657c7e46b348ff4469d
  Untyped 1ea9c340003fffbd6472826ee10b2a82
  UntypedCap c2e82114d9b1d6f0e2c295de577bf108
  Untyped_T 7f14fc8ec45b426989dad4ee2feb0c9b
  VCPU a3f204f39160fa01138f5aaea2a49d4b
  VCPUCap a5d4385f5f4a97cb20ff1809b8ec787c
  VCPU_T c6aef7b7b19f6775a9484bcef06ea711
  X86_64 b19353a0ea56d0c35dfea24d1a7b3de7
  arch 32e3c3068e13b222d9685e4724bb6f5e
  hasObjID b301b2bfb3dd29b6a532e0aa3191fc04
  hasSlots 727f06887ba2c03ce0cad4cdb044263e
  irqNode 7afabcf522f7414a80a3e1deb35ca7bf
  objID abfcdc1e2c618062b0ee7459a1d8218c
  objects ac2298f1227ae2af95c3325fdda8b1c2
  slots 0503d6fc6bb18b62d855ae9d996073f2
  tcbCTableSlot 4071e42f1f8cc9e3ee9a45149cfee114
  untypedCovers ed6f75e50d685929c5f094392db9fae2
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Writer 32fa8ad98faefac55840c4de999bae23
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Writer.Class 5f90a2822e73687bf78c6013cd144b94
import  -/  pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint abe8aeb00d775221281f89090d9fbe2a
import  -/  pretty-1.1.3.3@pretty-1.1.3.3:Text.PrettyPrint.HughesPJ 5fd6ee2fcb3f4a1e810ed36714963e44
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Writer.Lazy 318e0ea1f5d7e430a880cfb1b1a207b6
43232547fa34cec43339cfa8ebe7b346
  $s$fEq(,) ::
    GHC.Classes.Eq ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                  (GHC.Classes.$fEq(,)_$c==
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     CapDL.State.$s$fEq(,)_$dEq
                     CapDL.State.$s$fEq(,)_$dEq1)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     CapDL.State.$s$fEq(,)_$dEq
                     CapDL.State.$s$fEq(,)_$dEq1) -}
8a17f6730683b3b0c9fdb922947602ed
  $s$fEq(,)1 ::
    GHC.Classes.Eq
      ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                     GHC.Types.Word)
                  (GHC.Classes.$fEq(,)_$c==
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
                     CapDL.State.$s$fEq(,)_$dEq2)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
                     CapDL.State.$s$fEq(,)_$dEq2) -}
066205796c1cd9c248dacc71673e3819
  $s$fEq(,)_$dEq :: GHC.Classes.Eq [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
a741c590be68c5ff8a3e324ea12cf30b
  $s$fEq(,)_$dEq1 :: GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.$s$fEq(,)_$s$fEqMaybe -}
6c9f31e1af12efcd67d7c19900013fdd
  $s$fEq(,)_$dEq2 :: GHC.Classes.Eq GHC.Types.Word
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) GHC.Classes.$fEqWord -}
b47cc12372cd335002f304cb33d16fd1
  $s$fEq(,)_$s$fEqMaybe ::
    GHC.Classes.Eq (GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Word)
                  CapDL.State.$s$fEq(,)_$s$fEqMaybe_$c==
                  (GHC.Base.$fEqMaybe_$c/= @ GHC.Types.Word GHC.Classes.$fEqWord) -}
bce5b70e79145dbfd71dfd0028f0286b
  $s$fEq(,)_$s$fEqMaybe_$c== ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: GHC.Base.Maybe GHC.Types.Word)
                   (ds1 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case ds of wild {
                   GHC.Base.Nothing
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a1
                   -> case ds1 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.eqWord a1 b1 } }) -}
264fe56925539a9712c3aa7859a33551
  $s$fEq(,)_$s$fOrd(,)_$cp1Ord ::
    GHC.Classes.Eq ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) CapDL.State.$s$fEq(,) -}
e1434940e449db24f633323c219b45a7
  $s$fEq[] :: GHC.Classes.Eq [GHC.Types.Word]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Types.Word]
                  (GHC.Classes.$fEq[]_$c==
                     @ GHC.Types.Word
                     CapDL.State.$s$fEq(,)_$dEq2)
                  CapDL.State.$s$fEq[]_$s$fEq[]_$c/= -}
3b74943ed7fcc3ca1a0665f1cc2f0dc2
  $s$fEq[]_$s$fEq[]_$c/= ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 GHC.Classes.not
                   (GHC.Classes.$fEq[]_$c==
                      @ GHC.Types.Word
                      CapDL.State.$s$fEq(,)_$dEq2
                      x
                      y)) -}
8b481880da9ac64bf33a705a37b56d8a
  $s$fOrd(,) ::
    GHC.Classes.Ord ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                  CapDL.State.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ [GHC.Types.Char]
                     @ (GHC.Base.Maybe GHC.Types.Word)
                     GHC.Classes.$fOrd[]_$s$fOrd[]1
                     CapDL.State.$s$fOrd(,)_$dOrd1) -}
6454b5c2bca85ea14e90922ec6a84300
  $s$fOrd(,)1 ::
    GHC.Classes.Ord
      ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                     GHC.Types.Word)
                  CapDL.State.$s$fOrd(,)_$s$fOrd(,)_$cp1Ord
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                     @ GHC.Types.Word
                     CapDL.State.$s$fOrd(,)_$dOrd
                     GHC.Classes.$fOrdWord) -}
a2ebc118a15274057adb8c8dc26661b4
  $s$fOrd(,)_$dOrd ::
    GHC.Classes.Ord (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) CapDL.State.$s$fOrd(,) -}
10be4e3ef7e43088b1bc927c574326c0
  $s$fOrd(,)_$dOrd1 ::
    GHC.Classes.Ord (GHC.Base.Maybe GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.$s$fOrd(,)_$s$fOrdMaybe -}
233567f7b71ff43cb09cdd350e9d6538
  $s$fOrd(,)_$s$fOrd(,)_$cp1Ord ::
    GHC.Classes.Eq
      ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) CapDL.State.$s$fEq(,)1 -}
20727f34cb015931db1e62ff49c7faf7
  $s$fOrd(,)_$s$fOrdMaybe ::
    GHC.Classes.Ord (GHC.Base.Maybe GHC.Types.Word)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Base.Maybe GHC.Types.Word)
                  CapDL.State.$s$fEq(,)_$dEq1
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$ccompare
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c<
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c<=
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c>
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c>=
                  CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$cmax
                  (GHC.Base.$fOrdMaybe_$cmin
                     @ GHC.Types.Word
                     GHC.Classes.$fOrdWord) -}
4212e8b2743517bb25649f10008e6524
  $s$fOrd(,)_$s$fOrdMaybe_$c< ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe GHC.Types.Word)
                   (b :: GHC.Base.Maybe GHC.Types.Word) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ipv -> GHC.Types.True }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.ltWord a2 b1 } }) -}
546cf69eb8c1079ce41b65513efc9aee
  $s$fOrd(,)_$s$fOrdMaybe_$c<= ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe GHC.Types.Word)
                   (b :: GHC.Base.Maybe GHC.Types.Word) ->
                 case a1 of wild {
                   GHC.Base.Nothing -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just b1 -> GHC.Classes.leWord a2 b1 } }) -}
fe623db84ae330bd9b1febef9490e267
  $s$fOrd(,)_$s$fOrdMaybe_$c> ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe GHC.Types.Word)
                   (b :: GHC.Base.Maybe GHC.Types.Word) ->
                 case a1 of wild {
                   GHC.Base.Nothing -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1 -> GHC.Classes.gtWord a2 b1 } }) -}
e574155e62ce9e762a276077962c1e02
  $s$fOrd(,)_$s$fOrdMaybe_$c>= ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe GHC.Types.Word)
                   (b :: GHC.Base.Maybe GHC.Types.Word) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just ipv -> GHC.Types.False }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.True
                        GHC.Base.Just b1 -> GHC.Classes.geWord a2 b1 } }) -}
04aee2f89cfa7fca7981f89912fa4c1d
  $s$fOrd(,)_$s$fOrdMaybe_$ccompare ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: GHC.Base.Maybe GHC.Types.Word)
                   (b :: GHC.Base.Maybe GHC.Types.Word) ->
                 case a1 of wild {
                   GHC.Base.Nothing
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.EQ
                        GHC.Base.Just ipv -> GHC.Types.LT }
                   GHC.Base.Just a2
                   -> case b of wild1 {
                        GHC.Base.Nothing -> GHC.Types.GT
                        GHC.Base.Just b1 -> GHC.Classes.compareWord a2 b1 } }) -}
6155fbb1a4f20a09068d5fb0091763b6
  $s$fOrd(,)_$s$fOrdMaybe_$cmax ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.Maybe GHC.Types.Word -> GHC.Base.Maybe GHC.Types.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Base.Maybe GHC.Types.Word)
                   (y :: GHC.Base.Maybe GHC.Types.Word) ->
                 case x of wild {
                   GHC.Base.Nothing -> y
                   GHC.Base.Just a1
                   -> case y of wild1 {
                        GHC.Base.Nothing -> wild
                        GHC.Base.Just b1
                        -> case GHC.Classes.leWord a1 b1 of wild2 {
                             GHC.Types.False -> wild GHC.Types.True -> wild1 } } }) -}
a6899f96dcadeabab9d8e7ecba19bd2f
  $s$fOrd[] :: GHC.Classes.Ord [GHC.Types.Word]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Types.Word]
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$cp1Ord
                  (GHC.Classes.$fOrd[]_$ccompare
                     @ GHC.Types.Word
                     GHC.Classes.$fOrdWord)
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$c<
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$c<=
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$c>
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$c>=
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$cmax
                  CapDL.State.$s$fOrd[]_$s$fOrd[]_$cmin -}
b9d11c06391cb1cf70bc6ba98c698217
  $s$fOrd[]_$s$fOrd[]_$c< ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.LT -> GHC.Types.True }) -}
bd31653cbcf53b831c8166823508f87f
  $s$fOrd[]_$s$fOrd[]_$c<= ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.GT -> GHC.Types.False }) -}
d3e156b90b456d91a03101eed012b071
  $s$fOrd[]_$s$fOrd[]_$c> ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.False GHC.Types.GT -> GHC.Types.True }) -}
8bba99465112e44a7cba723c494affba
  $s$fOrd[]_$s$fOrd[]_$c>= ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> GHC.Types.True GHC.Types.LT -> GHC.Types.False }) -}
d8cb3d6f09d53c0ba28e869eccbcb2fb
  $s$fOrd[]_$s$fOrd[]_$cmax ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> [GHC.Types.Word]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> y GHC.Types.GT -> x }) -}
97d96fc3abfa1d2516c844f10df73437
  $s$fOrd[]_$s$fOrd[]_$cmin ::
    [GHC.Types.Word] -> [GHC.Types.Word] -> [GHC.Types.Word]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: [GHC.Types.Word]) (y :: [GHC.Types.Word]) ->
                 case GHC.Classes.$fOrd[]_$ccompare
                        @ GHC.Types.Word
                        GHC.Classes.$fOrdWord
                        x
                        y of wild {
                   DEFAULT -> x GHC.Types.GT -> y }) -}
f85bcb2e72233ba15ae2f9cfea7fe67a
  $s$fOrd[]_$s$fOrd[]_$cp1Ord :: GHC.Classes.Eq [GHC.Types.Word]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) CapDL.State.$s$fEq[] -}
71b083fd943687b3e8a0597a5807fa63
  $sfromList ::
    [([GHC.Types.Word], a)] -> Data.Map.Base.Map [GHC.Types.Word] a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds :: [([GHC.Types.Word], a)]) ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ [GHC.Types.Word] @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ [GHC.Types.Word]
                             @ a
                             1#
                             dt
                             x
                             (Data.Map.Base.Tip @ [GHC.Types.Word] @ a)
                             (Data.Map.Base.Tip @ [GHC.Types.Word] @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$ccompare
                                  @ GHC.Types.Word
                                  GHC.Classes.$fOrdWord
                                  kx
                                  ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                CapDL.State.$sfromList_$spoly_go10
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Base.Bin
                                     @ [GHC.Types.Word]
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ [GHC.Types.Word] @ a)
                                     (Data.Map.Base.Tip @ [GHC.Types.Word] @ a)) }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                CapDL.State.$sfromList_$s$wpoly_go10
                                  @ a
                                  ky
                                  ds3
                                  ipv1
                                  (Data.Map.Base.Bin
                                     @ [GHC.Types.Word]
                                     @ a
                                     1#
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ [GHC.Types.Word] @ a)
                                     (Data.Map.Base.Tip @ [GHC.Types.Word] @ a))
                                  1# } } } } } }) -}
d8bbbbfc7c334abca401cbc8ee4ebb0f
  $sfromList_$s$wpoly_go10 ::
    [GHC.Types.Word]
    -> a
    -> [([GHC.Types.Word], a)]
    -> Data.Map.Base.Map [GHC.Types.Word] a
    -> GHC.Prim.Int#
    -> Data.Map.Base.Map [GHC.Types.Word] a
  {- Arity: 5, Strictness: <L,U><L,U><L,U><S,1*U><L,U> -}
d303fda9bb4bf2b1051c3fd10d99c143
  $sfromList_$spoly_go10 ::
    [GHC.Types.Word]
    -> a
    -> [([GHC.Types.Word], a)]
    -> Data.Map.Base.Map [GHC.Types.Word] a
    -> Data.Map.Base.Map [GHC.Types.Word] a
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U> -}
7890870b4fa82f66ed10995f69a2d181
  $sinsertWith_$s$w$sgo10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
      (CapDL.Model.KernelObject [GHC.Types.Word])
    -> CapDL.Model.KernelObject [GHC.Types.Word]
    -> GHC.Base.Maybe GHC.Types.Word
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map
         CapDL.Model.ObjID (CapDL.Model.KernelObject [GHC.Types.Word])
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
79e451f45fff6863fb6495fd0715bc0c
  $sinsert_$s$w$sgo1 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1
    -> a1
    -> GHC.Types.Word
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
5abe34e437ee69c607f3a92a23c44065
  $sinsert_$s$w$sgo10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1
    -> a1
    -> GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><L,U> -}
8530e38087e5ec38a5da758f584d711c
  $sinsert_$s$w$sgo2 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1
    -> a1 -> [GHC.Types.Char] -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
7af995095d298f611dec452e06d367a2
  $sinsert_$sgo10 ::
    CapDL.Model.ObjID
    -> a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 3, Strictness: <S,1*U(U,U)><L,U><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   (w :: CapDL.Model.ObjID)
                   (w1 :: a1)
                   (w2 :: Data.Map.Base.Map CapDL.Model.ObjID a1) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.State.$w$sgo1 @ a1 ww1 ww2 w1 w2 }) -}
0dda7d00e7eebb30a030215410e5da60
  $sinsert_$sgo2 ::
    [GHC.Types.Word]
    -> a1
    -> Data.Map.Base.Map [GHC.Types.Word] a1
    -> Data.Map.Base.Map [GHC.Types.Word] a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
83dd7a608346b81b5be58255b2b567e4
  $sinsert_go5 ::
    GHC.Classes.Ord a1 =>
    a1 -> Data.Set.Base.Set a1 -> Data.Set.Base.Set a1
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U> -}
e45252bb10abbe0ec2ae1476d029f8f5
  $slookup1 ::
    CapDL.Model.ObjID
    -> Data.Map.Base.Map CapDL.Model.ObjID a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: CapDL.Model.ObjID)
                   (w1 :: Data.Map.Base.Map CapDL.Model.ObjID a) ->
                 case w of ww { (,) ww1 ww2 ->
                 CapDL.State.$wpoly_go10 @ a ww1 ww2 w1 }) -}
433f9e91286bcc22763428135799022d
  $slookup3 ::
    GHC.Types.Word
    -> Data.Map.Base.Map GHC.Types.Word a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: GHC.Types.Word)
                   (w1 :: Data.Map.Base.Map GHC.Types.Word a) ->
                 case w of ww { GHC.Types.W# ww1 ->
                 CapDL.State.$wpoly_go1 @ a ww1 w1 }) -}
64a83aa37b380b3eb0e211b0d7b3ca2c
  $slookup5 ::
    [GHC.Types.Word]
    -> Data.Map.Base.Map [GHC.Types.Word] a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
1ad4b18f06793d3ebf2aa0e73f9ac7cb
  $slookup_$s$wpoly_go1 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a
    -> GHC.Types.Word -> [GHC.Types.Char] -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
143403086877ef7ac1119bf32f07747d
  $slookup_$s$wpoly_go10 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a
    -> GHC.Prim.Word# -> [GHC.Types.Char] -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U> -}
11c7b8a4d82af457f50eb091347b9bcf
  $slookup_$s$wpoly_go2 ::
    Data.Map.Base.Map
      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a
    -> [GHC.Types.Char] -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
eecb24f373298c528808a97697b6a8ab
  $smapKeys ::
    (k1 -> [GHC.Types.Word])
    -> Data.Map.Base.Map k1 a -> Data.Map.Base.Map [GHC.Types.Word] a
  {- Arity: 2, Strictness: <L,C(U)><S,1*U>,
     Unfolding: (\ @ k1
                   @ a
                   (f :: k1 -> [GHC.Types.Word])
                   (eta :: Data.Map.Base.Map k1 a) ->
                 letrec {
                   go1 :: [([GHC.Types.Word], a)]
                          -> Data.Map.Base.Map k1 a -> [([GHC.Types.Word], a)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [([GHC.Types.Word], a)])
                       (ds :: Data.Map.Base.Map k1 a) ->
                     case ds of wild {
                       Data.Map.Base.Bin dt kx x l r
                       -> go1 (GHC.Types.: @ ([GHC.Types.Word], a) (f kx, x) (go1 z' r)) l
                       Data.Map.Base.Tip -> z' }
                 } in
                 CapDL.State.$sfromList
                   @ a
                   (go1 (GHC.Types.[] @ ([GHC.Types.Word], a)) eta)) -}
a5c642f8c94139826281a6661a3e4237
  $sunions_$sgo5 ::
    [Data.Set.Base.Set
       ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 1, Strictness: <S,1*U> -}
f97022c69f661277f1283cda9e3e4c15
  $supdate_$sgo10 ::
    Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
    -> [GHC.Types.Word]
    -> GHC.Classes.Ord [GHC.Types.Word] =>
       Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
  {- Arity: 3,
     Strictness: <S,1*U><S,1*U><L,U(A,C(C1(U)),A,A,A,A,A,A)> -}
d6e28c47303afff84ed3656a8582b746
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   CapDL.State.$trModule2
                   CapDL.State.$trModule1) -}
0e41d4017e1c10107d575207ff7206f0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "CapDL.State"#) -}
94148334788292b3cdd7afa94c56ebe3
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
ade26e000786dff3d42402a0b5bda98c
  $w$sgo1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
    -> Data.Map.Base.Map CapDL.Model.ObjID a1
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U>, Inline: [0] -}
5b1d79c22035dc98ac4a688548f9068b
  $w$sgo10 ::
    GHC.Prim.Word#
    -> Data.Map.Base.Map GHC.Types.Word a1
    -> Data.Map.Base.Map GHC.Types.Word a1
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
aee4f64cd2dc967a299d92bf3d1568f1
  $w$sgo2 ::
    GHC.Prim.Word#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Word a1
    -> Data.Map.Base.Map GHC.Types.Word a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
4f917a2a39f62a9aa904d58074f7c962
  $wallCovers ::
    CapDL.Model.CoverMap -> [Data.Set.Base.Set CapDL.Model.ObjID]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.CoverMap) ->
                 CapDL.State.allCovers_go10
                   (GHC.Types.[] @ (Data.Set.Base.Set CapDL.Model.ObjID))
                   ww) -}
97f611e8ec970daa92aac064ae3f50a0
  $wallMappings ::
    CapDL.Model.ObjID
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjID)
                   (ww :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 letrec {
                   go1 :: [(CapDL.Model.ObjID,
                            CapDL.Model.KernelObject GHC.Types.Word)]
                          -> Data.Map.Base.Map
                               (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                               (CapDL.Model.KernelObject GHC.Types.Word)
                          -> [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [(CapDL.Model.ObjID,
                                CapDL.Model.KernelObject GHC.Types.Word)])
                       (ds :: Data.Map.Base.Map
                                (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                (CapDL.Model.KernelObject GHC.Types.Word)) ->
                     case ds of wild {
                       Data.Map.Base.Bin dt kx x l r
                       -> go1
                            (case CapDL.State.isMapped w x of wild1 {
                               GHC.Types.False -> go1 z' r
                               GHC.Types.True
                               -> GHC.Types.:
                                    @ (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
                                    (kx, x)
                                    (go1 z' r) })
                            l
                       Data.Map.Base.Tip -> z' }
                 } in
                 go1
                   (GHC.Types.[]
                      @ (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word))
                   ww) -}
fcfeb0942820dc4f501b6e3eda38f609
  $wallSlots ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 CapDL.State.allSlots_go10
                   (GHC.Types.[] @ (CapDL.Model.CapRef, CapDL.Model.Cap))
                   ww) -}
f1a025234cea8ea852ce177dad6f53c9
  $wcheckASID ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U(U,U)><L,1*U(A,1*U,A,A,A)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   valid :: GHC.Types.Bool
                   = case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                     case CapDL.State.$wgo
                            (CapDL.State.$wallMappings w ww2)
                            0# of ww6 { DEFAULT ->
                     GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# ww6 1#) } }
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> case w of ww { (,) ww1 ww2 ->
                         let {
                           s :: GHC.Base.String
                           = GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows7
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        ww1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows5
                                              (GHC.Show.$fShow(,)_$sgo
                                                 CapDL.State.checkASID2
                                                 (GHC.Show.$fShowMaybe_$cshowsPrec
                                                    @ GHC.Types.Word
                                                    GHC.Show.$fShowWord
                                                    GHC.Show.shows22
                                                    ww2)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))))))
                               CapDL.State.checkASID1
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww4 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww4)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
a1a5ec9d4e320cef31cfd7bb771315f9
  $wcheckCapArch ::
    CapDL.Model.Arch
    -> CapDL.Model.Cap
    -> CapDL.Model.ObjID
    -> GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 4, Strictness: <L,1*U><L,1*U><L,1*U(1*U,1*U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Cap)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: GHC.Types.Word) ->
                 let {
                   valid :: GHC.Types.Bool = CapDL.State.validCapArch w w1
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> let {
                           s :: GHC.Base.String
                           = GHC.CString.unpackAppendCString#
                               "The cap at slot "#
                               (case w3 of wild1 { GHC.Types.W# w4 ->
                                case GHC.Show.$wshowWord
                                       w4
                                       (GHC.Types.[] @ GHC.Types.Char) of ww { (#,#) ww1 ww2 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.: @ GHC.Types.Char ww1 ww2)
                                  (GHC.CString.unpackAppendCString#
                                     " in "#
                                     (case w2 of ww4 { (,) ww5 ww6 ->
                                      GHC.Base.++
                                        @ GHC.Types.Char
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows7
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows6
                                              (GHC.Show.showLitString
                                                 ww5
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.shows6
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.shows5
                                                       (GHC.Show.$fShow(,)_$sgo
                                                          CapDL.State.checkASID2
                                                          (GHC.Show.$fShowMaybe_$cshowsPrec
                                                             @ GHC.Types.Word
                                                             GHC.Show.$fShowWord
                                                             GHC.Show.shows22
                                                             ww6)
                                                          (GHC.Types.[] @ GHC.Show.ShowS)))))))
                                        CapDL.State.checkCapArch1 })) } })
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww2)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
54fcec2eca071c4b1d13dc24907c88ea
  $wcheckCovers ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,U(A,U,A,A,U)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   lvl62 :: CapDL.State.Logger GHC.Types.Bool
                   = case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                     case CapDL.State.$wcheckUntypedCovers
                            ww2
                            ww5 of ww6 { (#,#) ww7 ww8 ->
                     (ww7, ww8)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) } }
                 } in
                 let {
                   valid :: GHC.Types.Bool
                   = case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                     CapDL.State.checkCovers_$snullIntersections
                       (CapDL.State.allCovers_go10
                          (GHC.Types.[] @ (Data.Set.Base.Set CapDL.Model.ObjID))
                          ww5) }
                 } in
                 let {
                   ds :: CapDL.State.Logger GHC.Types.Bool
                   = case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                     case CapDL.State.$wcheckUntypeds ww2 ww5 of ww6 { (#,#) ww7 ww8 ->
                     (ww7, ww8)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) } }
                 } in
                 (# case valid of wild {
                      GHC.Types.False -> GHC.Types.False
                      GHC.Types.True
                      -> case lvl62
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild1 { (,) a1 w2 ->
                         case a1 of wild2 {
                           GHC.Types.False -> GHC.Types.False
                           GHC.Types.True
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild3 { (,) a2 w1 ->
                              a2 } } } },
                    case lvl62
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    case w2 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild1 {
                      DEFAULT
                      -> case ds
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w1 ->
                         case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case valid of wild4 {
                                GHC.Types.False
                                -> case CapDL.State.checkCovers1
                                          `cast`
                                        (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                     DEFAULT
                                     -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                           @ ()
                                           wild5
                                           GHC.Types.False
                                           (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild3
                                              GHC.Types.False
                                              wild1))
                                          `cast`
                                        (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                     Text.PrettyPrint.Annotated.HughesPJ.Empty
                                     -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                           @ ()
                                           wild3
                                           GHC.Types.False
                                           wild1)
                                          `cast`
                                        (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                                GHC.Types.True
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild3
                                      GHC.Types.False
                                      wild1)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case valid of wild4 {
                                GHC.Types.False
                                -> case CapDL.State.checkCovers1
                                          `cast`
                                        (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                     DEFAULT
                                     -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                           @ ()
                                           wild5
                                           GHC.Types.False
                                           wild1)
                                          `cast`
                                        (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                     Text.PrettyPrint.Annotated.HughesPJ.Empty
                                     -> wild1 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                                GHC.Types.True
                                -> wild1 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } } }
                      Text.PrettyPrint.Annotated.HughesPJ.Empty
                      -> case ds
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w1 ->
                         case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case valid of wild4 {
                                GHC.Types.False
                                -> case CapDL.State.checkCovers1
                                          `cast`
                                        (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                     DEFAULT
                                     -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                           @ ()
                                           wild5
                                           GHC.Types.False
                                           wild3)
                                          `cast`
                                        (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                     Text.PrettyPrint.Annotated.HughesPJ.Empty
                                     -> wild3 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                                GHC.Types.True
                                -> wild3 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case valid of wild4 {
                                GHC.Types.False -> CapDL.State.checkCovers1
                                GHC.Types.True
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } } } } } #)) -}
7aecc0c35b0770a8054bf9743df85873
  $wcheckDuplicateMappedFrameCaps ::
    [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (w :: [(CapDL.Model.ObjID, GHC.Types.Word)]) ->
                 let {
                   duplicates :: [(CapDL.Model.ObjID, GHC.Types.Word)]
                   = CapDL.State.checkDuplicateMappedFrameCaps_$sfindDuplicates w
                 } in
                 let {
                   valid :: GHC.Types.Bool
                   = case duplicates of wild {
                       [] -> GHC.Types.True : ds1 ds2 -> GHC.Types.False }
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> let {
                           s :: GHC.Base.String
                           = GHC.CString.unpackAppendCString#
                               "Mappings referenced by multiple frame caps:\n"#
                               (case GHC.Base.map
                                       @ (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                                          GHC.Types.Word)
                                       @ [GHC.Types.Char]
                                       CapDL.State.checkDuplicateMappedFrameCaps2
                                       duplicates of wild1 {
                                  [] -> CapDL.State.checkDuplicateMappedFrameCaps1
                                  : x xs1
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (Data.OldList.intercalate_$spoly_go
                                          @ GHC.Types.Char
                                          x
                                          (Data.OldList.prependToAll
                                             @ [GHC.Types.Char]
                                             CapDL.State.checkDuplicateMappedFrameCaps1
                                             xs1))
                                       CapDL.State.checkDuplicateMappedFrameCaps1 })
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww2)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
2541dba820ede61c017c99221db7156c
  $wcheckIRQ ::
    CapDL.Model.Model GHC.Types.Word
    -> GHC.Types.Word
    -> CapDL.Model.ObjID
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 3, Strictness: <L,1*U(A,1*U,A,A,A)><L,1*U(U)><L,U(U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (ww :: GHC.Types.Word)
                   (ww1 :: CapDL.Model.ObjID) ->
                 let {
                   valid :: GHC.Types.Bool
                   = case ww1 of ww2 { (,) ww3 ww4 ->
                     case w of ww5 { CapDL.Model.Model ww6 ww7 ww8 ww9 ww10 ->
                     case CapDL.State.$wpoly_go10
                            @ (CapDL.Model.KernelObject GHC.Types.Word)
                            ww3
                            ww4
                            ww7 of wild {
                       GHC.Base.Nothing
                       -> case CapDL.State.checkCovers4 ww4 ww3
                          ret_ty GHC.Types.Bool
                          of {}
                       GHC.Base.Just obj
                       -> case obj of wild1 {
                            DEFAULT -> GHC.Types.False
                            CapDL.Model.CNode ds ds1
                            -> case ds1 of wild2 { GHC.Types.W# ds2 ->
                               case ds2 of ds3 {
                                 DEFAULT -> GHC.Types.False 0## -> GHC.Types.True } }
                            CapDL.Model.IOAPICIrq ds ds1 ds2 ds3 ds4 -> GHC.Types.True
                            CapDL.Model.MSIIrq ds ds1 ds2 ds3 ds4 -> GHC.Types.True } } } }
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> let {
                           s :: GHC.Base.String
                           = GHC.CString.unpackAppendCString#
                               "The object mapped by irq "#
                               (case ww of wild1 { GHC.Types.W# w1 ->
                                case GHC.Show.$wshowWord
                                       w1
                                       (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                                  CapDL.State.checkIRQ1 } })
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww2)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
7f6c0d74b6b5d9c1eb98cc9ce7b197d0
  $wcheckIRQNode ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,1*U(A,U,1*U,A,A)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: ([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)
                   = case w of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                     letrec {
                       $wgo5 :: [(GHC.Types.Word, CapDL.Model.ObjID)]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w1 :: [(GHC.Types.Word, CapDL.Model.ObjID)]) ->
                         case w1 of wild1 {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds7 :: CapDL.State.Logger GHC.Types.Bool
                                = case y of ww { (,) ww1 ww2 ->
                                  case CapDL.State.$wcheckIRQ wild ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                                  (ww4, ww5)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool,
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <GHC.Types.Bool>_N))) } }
                              } in
                              let {
                                ds8 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww { (#,#) ww1 ww2 ->
                                  (ww1, ww2)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds7
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a1 w2 ->
                                    a1 })
                                   (case ds8
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                    b1 }),
                                 case ds8
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                                   DEFAULT
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w2 ->
                                      case w2 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild5
                                              GHC.Types.False
                                              wild3)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild3
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w2 ->
                                      w2 } } } #) }
                     } in
                     case $wgo5
                            (Data.Map.Base.toAscList
                               @ GHC.Types.Word
                               @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                               ds3) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) } }
                 } in
                 (# case ds of wild { (,) a1 w2 ->
                    (CapDL.State.checkIRQNode_go a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds of wild { (,) a1 w2 -> w2 } #)) -}
5e31a942c3aac2223e6eb4dd9a161c9f
  $wcheckMappedFrameCaps ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,U(A,U,A,A,A)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   lvl62 :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckMappedFrameCapsOnlyInCNodes
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 let {
                   mappings :: [(CapDL.Model.ObjID, GHC.Types.Word)]
                   = case w of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                     CapDL.State.checkMappedFrameCaps_go1
                       (CapDL.State.flattenCNodeSlots
                          (Data.Map.Base.toAscList
                             @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                             @ (CapDL.Model.KernelObject GHC.Types.Word)
                             ds2)) }
                 } in
                 let {
                   lvl63 :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckMappedFrameCapsSanity
                            w
                            mappings of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 let {
                   ds :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckDuplicateMappedFrameCaps
                            mappings of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    case a1 of wild1 {
                      GHC.Types.False -> GHC.Types.False
                      GHC.Types.True
                      -> case lvl63
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w1 ->
                         case a2 of wild3 {
                           GHC.Types.False -> GHC.Types.False
                           GHC.Types.True
                           -> case lvl62
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w3 ->
                              a3 } } } } },
                    case lvl62
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    case w2 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild1 {
                      DEFAULT
                      -> case lvl63
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w1 ->
                         case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w3 ->
                              case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                         @ ()
                                         wild3
                                         GHC.Types.False
                                         wild1))
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild3
                                      GHC.Types.False
                                      wild1)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w3 ->
                              case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      wild1)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> wild1 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } } } }
                      Text.PrettyPrint.Annotated.HughesPJ.Empty
                      -> case lvl63
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w1 ->
                         case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w3 ->
                              case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      wild3)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> wild3 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w3 ->
                              w3 } } } } } #)) -}
0e00772b08323a53a7c73da347be5050
  $wcheckMappedFrameCapsOnlyInCNodes ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,1*U(A,1*U,A,A,A)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Text.PrettyPrint.HughesPJ.Doc
                           Data.Functor.Identity.Identity
                           [GHC.Types.Bool]
                   = case w of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                     case CapDL.State.$wgo3
                            (CapDL.State.checkMappedFrameCaps_go10
                               (GHC.Types.[]
                                  @ (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word))
                               ds2) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[GHC.Types.Bool]>_N))) } }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    (CapDL.State.checkMappedFrameCaps_go2 a1)
                      `cast`
                    (Data.Monoid.N:All[0]) },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    w2 } #)) -}
0bc8aa7b6ec9ea884d28056353a669bf
  $wcheckMappedFrameCapsSanity ::
    CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U(A,U,A,A,A)><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: [(CapDL.Model.ObjID, GHC.Types.Word)]) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Text.PrettyPrint.HughesPJ.Doc
                           Data.Functor.Identity.Identity
                           [GHC.Types.Bool]
                   = case CapDL.State.$wgo2
                            (GHC.Base.map
                               @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                                  GHC.Types.Word)
                               @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                                  CapDL.Model.KernelObject GHC.Types.Word, GHC.Types.Word)
                               (\ (ds1 :: ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                                           GHC.Types.Word)) ->
                                case ds1 of wild { (,) objID slot ->
                                (objID, CapDL.State.object objID w, slot) })
                               w1) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[GHC.Types.Bool]>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    (CapDL.State.checkMappedFrameCaps_go a1)
                      `cast`
                    (Data.Monoid.N:All[0]) },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    w2 } #)) -}
05ad6bf9b1c624fd7bf2de14978dee2d
  $wcheckMappingSanity ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 3, Strictness: <L,1*U(1*U,A)><S,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjID)
                   (ww1 :: CapDL.Model.KernelObject GHC.Types.Word)
                   (ww2 :: GHC.Types.Word) ->
                 case ww1 of wild {
                   DEFAULT
                   -> (# GHC.Types.False,
                         let {
                           s :: GHC.Base.String
                           = GHC.CString.unpackAppendCString#
                               "Object specified in mapping("#
                               (case ww of wild1 { (,) x ds1 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  x
                                  (GHC.CString.unpackAppendCString#
                                     ", "#
                                     (case ww2 of wild2 { GHC.Types.W# w ->
                                      case GHC.Show.$wshowWord
                                             w
                                             (GHC.Types.[]
                                                @ GHC.Types.Char) of ww3 { (#,#) ww4 ww5 ->
                                      GHC.Base.++
                                        @ GHC.Types.Char
                                        (GHC.Types.: @ GHC.Types.Char ww4 ww5)
                                        CapDL.State.checkMappingSanity5 } })) })
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww3 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww3)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)
                   CapDL.Model.PT slots
                   -> case ww2 of ww3 { GHC.Types.W# ww4 ->
                      case CapDL.State.$wpoly_go1 @ CapDL.Model.Cap ww4 slots of wild1 {
                        GHC.Base.Nothing
                        -> (# GHC.Types.False, CapDL.State.checkMappingSanity3 #)
                        GHC.Base.Just ds
                        -> case ds of wild2 {
                             DEFAULT -> (# GHC.Types.False, CapDL.State.checkMappingSanity1 #)
                             CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                             -> (# GHC.Types.True,
                                   (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #) } } }
                   CapDL.Model.PD slots
                   -> case ww2 of ww3 { GHC.Types.W# ww4 ->
                      case CapDL.State.$wpoly_go1 @ CapDL.Model.Cap ww4 slots of wild1 {
                        GHC.Base.Nothing
                        -> (# GHC.Types.False, CapDL.State.checkMappingSanity3 #)
                        GHC.Base.Just ds
                        -> case ds of wild2 {
                             DEFAULT -> (# GHC.Types.False, CapDL.State.checkMappingSanity1 #)
                             CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                             -> (# GHC.Types.True,
                                   (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #) } } } }) -}
32fbcb7a1313769453d3dd16aaedd4ea
  $wcheckMappings ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,1*U(A,U,A,A,A)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: ([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)
                   = case w of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                     letrec {
                       $wgo5 :: [(CapDL.Model.ObjID,
                                  CapDL.Model.KernelObject GHC.Types.Word)]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w1 :: [(CapDL.Model.ObjID,
                                    CapDL.Model.KernelObject GHC.Types.Word)]) ->
                         case w1 of wild1 {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds7 :: CapDL.State.Logger GHC.Types.Bool
                                = case y of ww { (,) ww1 ww2 ->
                                  case ww2 of wild2 {
                                    DEFAULT
                                    -> CapDL.State.checkMappingSlotSanity1
                                         `cast`
                                       (Trans
                                            (Sym (Data.Functor.Identity.N:Identity[0]
                                                      <(GHC.Types.Bool,
                                                        Text.PrettyPrint.HughesPJ.Doc)>_R))
                                            (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                      <Text.PrettyPrint.HughesPJ.Doc>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <GHC.Types.Bool>_N)))
                                    CapDL.Model.PT ds8
                                    -> case CapDL.State.$wcheckPD ww1 wild of ww3 { (#,#) ww4 ww5 ->
                                       (ww4, ww5)
                                         `cast`
                                       (Trans
                                            (Sym (Data.Functor.Identity.N:Identity[0]
                                                      <(GHC.Types.Bool,
                                                        Text.PrettyPrint.HughesPJ.Doc)>_R))
                                            (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                      <Text.PrettyPrint.HughesPJ.Doc>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <GHC.Types.Bool>_N))) }
                                    CapDL.Model.PD ds8
                                    -> case CapDL.State.$wcheckASID
                                              ww1
                                              wild of ww3 { (#,#) ww4 ww5 ->
                                       (ww4, ww5)
                                         `cast`
                                       (Trans
                                            (Sym (Data.Functor.Identity.N:Identity[0]
                                                      <(GHC.Types.Bool,
                                                        Text.PrettyPrint.HughesPJ.Doc)>_R))
                                            (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                      <Text.PrettyPrint.HughesPJ.Doc>_N
                                                      <Data.Functor.Identity.Identity>_R
                                                      <GHC.Types.Bool>_N))) } } }
                              } in
                              let {
                                ds8 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww { (#,#) ww1 ww2 ->
                                  (ww1, ww2)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds7
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a1 w2 ->
                                    a1 })
                                   (case ds8
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                    b1 }),
                                 case ds8
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                                   DEFAULT
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w2 ->
                                      case w2 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild5
                                              GHC.Types.False
                                              wild3)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild3
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w2 ->
                                      w2 } } } #) }
                     } in
                     case $wgo5
                            (Data.Map.Base.toAscList
                               @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                               @ (CapDL.Model.KernelObject GHC.Types.Word)
                               ds2) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) } }
                 } in
                 (# case ds of wild { (,) a1 w2 ->
                    (CapDL.State.checkMappings_go a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds of wild { (,) a1 w2 -> w2 } #)) -}
2c2f86aa4a4bbbb00a58427b2feb6adb
  $wcheckModel ::
    CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <L,U(1*U,U,1*U,A,U)>, Inline: [0] -}
caec297a62bc98780698d184b8461f12
  $wcheckObj ::
    CapDL.Model.Arch
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 4, Strictness: <L,U><L,U(A,U,A,A,A)><L,U(U,U)><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Model GHC.Types.Word)
                   (ww :: CapDL.Model.ObjID)
                   (ww1 :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 let {
                   lvl62 :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckValidCaps
                            w
                            ww1
                            ww
                            w1 of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 let {
                   lvl63 :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckValidSlots
                            ww1
                            ww of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 let {
                   ds :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckObjArch
                            w
                            ww1
                            ww of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    case a1 of wild1 {
                      GHC.Types.False -> GHC.Types.False
                      GHC.Types.True
                      -> case lvl62
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w3 ->
                         case a2 of wild3 {
                           GHC.Types.False -> GHC.Types.False
                           GHC.Types.True
                           -> case lvl63
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w4 ->
                              a3 } } } } },
                    case lvl63
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    case w2 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild1 {
                      DEFAULT
                      -> case lvl62
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w3 ->
                         case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w4 ->
                              case w4 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                         @ ()
                                         wild3
                                         GHC.Types.False
                                         wild1))
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild3
                                      GHC.Types.False
                                      wild1)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w4 ->
                              case w4 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      wild1)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> wild1 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } } } }
                      Text.PrettyPrint.Annotated.HughesPJ.Empty
                      -> case lvl62
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w3 ->
                         case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w4 ->
                              case w4 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                DEFAULT
                                -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                      @ ()
                                      wild5
                                      GHC.Types.False
                                      wild3)
                                     `cast`
                                   (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                Text.PrettyPrint.Annotated.HughesPJ.Empty
                                -> wild3 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> case ds
                                     `cast`
                                   (Trans
                                        (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                             <Text.PrettyPrint.HughesPJ.Doc>_N
                                             <Data.Functor.Identity.Identity>_R
                                             <GHC.Types.Bool>_N)
                                        (Data.Functor.Identity.N:Identity[0]
                                             <(GHC.Types.Bool,
                                               Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a3 w4 ->
                              w4 } } } } } #)) -}
cb937be6f85648a2536ed1631da97938
  $wcheckObjArch ::
    CapDL.Model.Arch
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U(1*U,1*U)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID) ->
                 let {
                   valid :: GHC.Types.Bool = CapDL.State.validObjArch w w1
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> case w2 of ww { (,) ww1 ww2 ->
                         let {
                           s :: GHC.Base.String
                           = GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows7
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        ww1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows5
                                              (GHC.Show.$fShow(,)_$sgo
                                                 CapDL.State.checkASID2
                                                 (GHC.Show.$fShowMaybe_$cshowsPrec
                                                    @ GHC.Types.Word
                                                    GHC.Show.$fShowWord
                                                    GHC.Show.shows22
                                                    ww2)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))))))
                               CapDL.State.checkObj1
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww4 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww4)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
06daf5517df6cda746d0f50c01846c3c
  $wcheckObjectContainsNoMappedFrameCap ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,1*U(1*U,A)><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjID)
                   (ww1 :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 let {
                   $w$j :: CapDL.Model.CapMap GHC.Types.Word
                           -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
                     {- Arity: 1, Strictness: <L,1*U>, Inline: [0] -}
                   = \ (w :: CapDL.Model.CapMap GHC.Types.Word)[OneShot] ->
                     let {
                       valid :: Data.Monoid.All
                       = CapDL.State.checkObjectContainsNoMappedFrameCap_go10
                           GHC.Types.True `cast` (Sym (Data.Monoid.N:All[0]))
                           w
                     } in
                     (# valid `cast` (Data.Monoid.N:All[0]),
                        case valid `cast` (Data.Monoid.N:All[0]) of wild {
                          GHC.Types.False
                          -> let {
                               s :: GHC.Base.String
                               = GHC.CString.unpackAppendCString#
                                   "Non-CNode object '"#
                                   (case ww of wild1 { (,) x ds1 ->
                                    GHC.Base.++
                                      @ GHC.Types.Char
                                      x
                                      CapDL.State.checkObjectContainsNoMappedFrameCap1 })
                             } in
                             case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                             (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                                @ ()
                                (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                                   @ ()
                                   (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                                   ww2)
                                (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                               `cast`
                             (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                          GHC.Types.True
                          -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                               `cast`
                             (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)
                 } in
                 case ww1 of wild {
                   DEFAULT
                   -> (# GHC.Types.True,
                         (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                   CapDL.Model.TCB slots ds ds1 ds2 ds3 -> $w$j slots
                   CapDL.Model.CNode slots ds -> $w$j slots
                   CapDL.Model.ASIDPool slots -> $w$j slots
                   CapDL.Model.PT slots -> $w$j slots
                   CapDL.Model.PD slots -> $w$j slots
                   CapDL.Model.PDPT slots -> $w$j slots
                   CapDL.Model.PML4 slots -> $w$j slots
                   CapDL.Model.PUD slots -> $w$j slots
                   CapDL.Model.PGD slots -> $w$j slots
                   CapDL.Model.ARMIODevice slots ds -> $w$j slots
                   CapDL.Model.IODevice slots ds ds1 -> $w$j slots
                   CapDL.Model.IOPT slots ds -> $w$j slots }) -}
e22a31dd105b68ae6c535d9a027b8909
  $wcheckObjs ::
    CapDL.Model.Arch
    -> CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U><L,1*U(A,U,A,A,A)>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: ([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)
                   = case w1 of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                     letrec {
                       $wgo5 :: [(CapDL.Model.ObjID,
                                  CapDL.Model.KernelObject GHC.Types.Word)]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w2 :: [(CapDL.Model.ObjID,
                                    CapDL.Model.KernelObject GHC.Types.Word)]) ->
                         case w2 of wild1 {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds7 :: CapDL.State.Logger GHC.Types.Bool
                                = case y of ww { (,) ww1 ww2 ->
                                  case CapDL.State.$wcheckObj
                                         w
                                         wild
                                         ww1
                                         ww2 of ww3 { (#,#) ww4 ww5 ->
                                  (ww4, ww5)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool,
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <GHC.Types.Bool>_N))) } }
                              } in
                              let {
                                ds8 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww { (#,#) ww1 ww2 ->
                                  (ww1, ww2)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds7
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a1 w3 ->
                                    a1 })
                                   (case ds8
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                    b1 }),
                                 case ds8
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                                   DEFAULT
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w3 ->
                                      case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild5
                                              GHC.Types.False
                                              wild3)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild3
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds7
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w3 ->
                                      w3 } } } #) }
                     } in
                     case $wgo5
                            (Data.Map.Base.toAscList
                               @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                               @ (CapDL.Model.KernelObject GHC.Types.Word)
                               ds2) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) } }
                 } in
                 (# case ds of wild { (,) a1 w2 ->
                    (CapDL.State.checkObjs_go a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds of wild { (,) a1 w2 -> w2 } #)) -}
038c7ae282f8ad09b2174c5aad24cda8
  $wcheckPD ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U(U,U)><L,1*U(A,1*U,A,A,A)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   valid :: GHC.Types.Bool
                   = case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                     case CapDL.State.$wgo4
                            (CapDL.State.$wallMappings w ww2)
                            0# of ww6 { DEFAULT ->
                     GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# ww6 1#) } }
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> case w of ww { (,) ww1 ww2 ->
                         let {
                           s :: GHC.Base.String
                           = GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows7
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        ww1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows5
                                              (GHC.Show.$fShow(,)_$sgo
                                                 CapDL.State.checkASID2
                                                 (GHC.Show.$fShowMaybe_$cshowsPrec
                                                    @ GHC.Types.Word
                                                    GHC.Show.$fShowWord
                                                    GHC.Show.shows22
                                                    ww2)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))))))
                               CapDL.State.checkMapping1
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww4 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww4)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
202d44882a89bf9848e9efafdb30bb36
  $wcheckTypAt ::
    CapDL.Model.Cap
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 4,
     Strictness: <L,1*U><L,1*U(A,1*U,A,A,A)><L,1*U(1*U,1*U)><L,1*U(U)>,
     Inline: [0] -}
f39813f5de3997bb548c299e14be1a9a
  $wcheckUntyped ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A,A,A)><L,U(U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID) ->
                 let {
                   valid :: GHC.Types.Bool
                   = case w1 of ww { (,) ww1 ww2 ->
                     case w of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                     case CapDL.State.$wpoly_go10
                            @ (CapDL.Model.KernelObject GHC.Types.Word)
                            ww1
                            ww2
                            ww5 of wild {
                       GHC.Base.Nothing
                       -> case CapDL.State.checkCovers4 ww2 ww1
                          ret_ty GHC.Types.Bool
                          of {}
                       GHC.Base.Just obj
                       -> case obj of wild1 {
                            DEFAULT -> GHC.Types.False
                            CapDL.Model.Untyped ds ds1 -> GHC.Types.True } } } }
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> case w1 of ww { (,) ww1 ww2 ->
                         let {
                           s :: GHC.Base.String
                           = GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows7
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        ww1
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows5
                                              (GHC.Show.$fShow(,)_$sgo
                                                 CapDL.State.checkASID2
                                                 (GHC.Show.$fShowMaybe_$cshowsPrec
                                                    @ GHC.Types.Word
                                                    GHC.Show.$fShowWord
                                                    GHC.Show.shows22
                                                    ww2)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))))))
                               CapDL.State.checkCovers3
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww4 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww4)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
301246a6c1dbff73616a5cb1735098e8
  $wcheckUntypedCover ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> [CapDL.Model.ObjID]
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 3, Strictness: <L,U(A,U,A,A,A)><L,1*U(1*U,1*U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (ww :: CapDL.Model.ObjID)
                   (ww1 :: [CapDL.Model.ObjID]) ->
                 let {
                   x :: Data.Monoid.All
                   = CapDL.State.checkCovers_go4 (CapDL.State.checkCovers_go3 ww1 w)
                 } in
                 (# x `cast` (Data.Monoid.N:All[0]),
                    case x `cast` (Data.Monoid.N:All[0]) of wild {
                      GHC.Types.False
                      -> case ww of ww2 { (,) ww3 ww4 ->
                         let {
                           s :: GHC.Base.String
                           = GHC.Base.++
                               @ GHC.Types.Char
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows7
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Show.showLitString
                                        ww3
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows6
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows5
                                              (GHC.Show.$fShow(,)_$sgo
                                                 CapDL.State.checkASID2
                                                 (GHC.Show.$fShowMaybe_$cshowsPrec
                                                    @ GHC.Types.Word
                                                    GHC.Show.$fShowWord
                                                    GHC.Show.shows22
                                                    ww4)
                                                 (GHC.Types.[] @ GHC.Show.ShowS)))))))
                               CapDL.State.checkCovers8
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww5 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww5)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
dba4cf779b8f263653d3f0c4ac90acd9
  $wcheckUntypedCovers ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww1 :: CapDL.Model.CoverMap) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Text.PrettyPrint.HughesPJ.Doc
                           Data.Functor.Identity.Identity
                           [GHC.Types.Bool]
                   = let {
                       wild :: CapDL.Model.Model GHC.Types.Word
                       = CapDL.Model.Model
                           @ GHC.Types.Word
                           CapDL.State.checkCovers7
                           ww
                           CapDL.State.checkCovers6
                           CapDL.State.checkCovers5
                           ww1
                     } in
                     letrec {
                       $wgo5 :: [(CapDL.Model.ObjID, [CapDL.Model.ObjID])]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w :: [(CapDL.Model.ObjID, [CapDL.Model.ObjID])]) ->
                         case w of wild1 {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds1 :: CapDL.State.Logger GHC.Types.Bool
                                = case y of ww2 { (,) ww3 ww4 ->
                                  case CapDL.State.$wcheckUntypedCover
                                         wild
                                         ww3
                                         ww4 of ww5 { (#,#) ww6 ww7 ->
                                  (ww6, ww7)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool,
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <GHC.Types.Bool>_N))) } }
                              } in
                              let {
                                ds2 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww2 { (#,#) ww3 ww4 ->
                                  (ww3, ww4)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds1
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a1 w1 ->
                                    a1 })
                                   (case ds2
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                    b1 }),
                                 case ds2
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                                   DEFAULT
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w1 ->
                                      case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild5
                                              GHC.Types.False
                                              wild3)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild3
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w1 ->
                                      w1 } } } #) }
                     } in
                     case $wgo5
                            (CapDL.State.checkCovers_go2
                               (GHC.Types.[] @ (CapDL.Model.ObjID, [CapDL.Model.ObjID]))
                               ww1) of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[GHC.Types.Bool]>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    (CapDL.State.checkCovers_go1 a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    w2 } #)) -}
8dcbb4c0289046a9716eb09ba9356609
  $wcheckUntypeds ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.CoverMap
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww1 :: CapDL.Model.CoverMap) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Text.PrettyPrint.HughesPJ.Doc
                           Data.Functor.Identity.Identity
                           [GHC.Types.Bool]
                   = let {
                       wild :: CapDL.Model.Model GHC.Types.Word
                       = CapDL.Model.Model
                           @ GHC.Types.Word
                           CapDL.State.checkCovers7
                           ww
                           CapDL.State.checkCovers6
                           CapDL.State.checkCovers5
                           ww1
                     } in
                     letrec {
                       $wgo5 :: [CapDL.Model.ObjID]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w :: [CapDL.Model.ObjID]) ->
                         case w of wild1 {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds1 :: CapDL.State.Logger GHC.Types.Bool
                                = case CapDL.State.$wcheckUntyped wild y of ww2 { (#,#) ww3 ww4 ->
                                  (ww3, ww4)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool,
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <GHC.Types.Bool>_N))) }
                              } in
                              let {
                                ds2 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww2 { (#,#) ww3 ww4 ->
                                  (ww3, ww4)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds1
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a1 w1 ->
                                    a1 })
                                   (case ds2
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                    b1 }),
                                 case ds2
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                                   DEFAULT
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w1 ->
                                      case w1 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild5 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild5
                                              GHC.Types.False
                                              wild3)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild3
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild4 { (,) a1 w1 ->
                                      w1 } } } #) }
                     } in
                     case $wgo5
                            (CapDL.State.checkCovers_go10
                               (GHC.Types.[] @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))
                               ww1) of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[GHC.Types.Bool]>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    (CapDL.State.checkCovers_go a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w2 ->
                    w2 } #)) -}
4ba211404d5acad8be8d1bf6c6af7d93
  $wcheckValidCap ::
    CapDL.Model.Arch
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Types.Word
    -> CapDL.Model.Cap
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 5,
     Strictness: <L,1*U><L,U(U,U)><L,1*U(A,1*U,A,A,A)><L,U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.Model GHC.Types.Word)
                   (ww :: GHC.Types.Word)
                   (ww1 :: CapDL.Model.Cap) ->
                 let {
                   lvl62 :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckTypAt
                            ww1
                            w2
                            w1
                            ww of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 let {
                   ds :: CapDL.State.Logger GHC.Types.Bool
                   = case CapDL.State.$wcheckCapArch
                            w
                            ww1
                            w1
                            ww of ww2 { (#,#) ww3 ww4 ->
                     (ww3, ww4)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w3 ->
                    case a1 of wild1 {
                      GHC.Types.False -> GHC.Types.False
                      GHC.Types.True
                      -> case lvl62
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w4 ->
                         a2 } } },
                    case lvl62
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <GHC.Types.Bool>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <(GHC.Types.Bool,
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w3 ->
                    case w3 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild1 {
                      DEFAULT
                      -> case ds
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w4 ->
                         case w4 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild3 {
                           DEFAULT
                           -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                 @ ()
                                 wild3
                                 GHC.Types.False
                                 wild1)
                                `cast`
                              (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                           Text.PrettyPrint.Annotated.HughesPJ.Empty
                           -> wild1 `cast` (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                      Text.PrettyPrint.Annotated.HughesPJ.Empty
                      -> case ds
                                `cast`
                              (Trans
                                   (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                        <Text.PrettyPrint.HughesPJ.Doc>_N
                                        <Data.Functor.Identity.Identity>_R
                                        <GHC.Types.Bool>_N)
                                   (Data.Functor.Identity.N:Identity[0]
                                        <(GHC.Types.Bool,
                                          Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild2 { (,) a2 w4 ->
                         w4 } } } #)) -}
3086104e4a4dad1a15a3fd036507a265
  $wcheckValidCaps ::
    CapDL.Model.Arch
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U(U,U)><L,U(A,U,A,A,A)>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: Control.Monad.Trans.Writer.Lazy.WriterT
                           Text.PrettyPrint.HughesPJ.Doc
                           Data.Functor.Identity.Identity
                           [GHC.Types.Bool]
                   = letrec {
                       $wgo5 :: [(GHC.Types.Word, CapDL.Model.Cap)]
                                -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
                         {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                       = \ (w4 :: [(GHC.Types.Word, CapDL.Model.Cap)]) ->
                         case w4 of wild {
                           []
                           -> (# GHC.Types.[] @ GHC.Types.Bool,
                                 (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                                   `cast`
                                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) #)
                           : y ys
                           -> let {
                                ds1 :: CapDL.State.Logger GHC.Types.Bool
                                = case y of ww { (,) ww1 ww2 ->
                                  case CapDL.State.$wcheckValidCap
                                         w
                                         w2
                                         w3
                                         ww1
                                         ww2 of ww3 { (#,#) ww4 ww5 ->
                                  (ww4, ww5)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool,
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <GHC.Types.Bool>_N))) } }
                              } in
                              let {
                                ds2 :: Control.Monad.Trans.Writer.Lazy.WriterT
                                         Text.PrettyPrint.HughesPJ.Doc
                                         Data.Functor.Identity.Identity
                                         [GHC.Types.Bool]
                                = case $wgo5 ys of ww { (#,#) ww1 ww2 ->
                                  (ww1, ww2)
                                    `cast`
                                  (Trans
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <([GHC.Types.Bool],
                                                   Text.PrettyPrint.HughesPJ.Doc)>_R))
                                       (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                 <Text.PrettyPrint.HughesPJ.Doc>_N
                                                 <Data.Functor.Identity.Identity>_R
                                                 <[GHC.Types.Bool]>_N))) }
                              } in
                              (# GHC.Types.:
                                   @ GHC.Types.Bool
                                   (case ds1
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <GHC.Types.Bool>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <(GHC.Types.Bool,
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild1 { (,) a1 w5 ->
                                    a1 })
                                   (case ds2
                                           `cast`
                                         (Trans
                                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                                   <Data.Functor.Identity.Identity>_R
                                                   <[GHC.Types.Bool]>_N)
                                              (Data.Functor.Identity.N:Identity[0]
                                                   <([GHC.Types.Bool],
                                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild1 { (,) b1 w' ->
                                    b1 }),
                                 case ds2
                                        `cast`
                                      (Trans
                                           (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                                <Data.Functor.Identity.Identity>_R
                                                <[GHC.Types.Bool]>_N)
                                           (Data.Functor.Identity.N:Identity[0]
                                                <([GHC.Types.Bool],
                                                  Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild1 { (,) b1 w' ->
                                 case w' `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild2 {
                                   DEFAULT
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild3 { (,) a1 w5 ->
                                      case w5 `cast` (Text.PrettyPrint.HughesPJ.N:Doc[0]) of wild4 {
                                        DEFAULT
                                        -> (Text.PrettyPrint.Annotated.HughesPJ.Beside
                                              @ ()
                                              wild4
                                              GHC.Types.False
                                              wild2)
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0]))
                                        Text.PrettyPrint.Annotated.HughesPJ.Empty
                                        -> wild2
                                             `cast`
                                           (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } }
                                   Text.PrettyPrint.Annotated.HughesPJ.Empty
                                   -> case ds1
                                             `cast`
                                           (Trans
                                                (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                                     <Data.Functor.Identity.Identity>_R
                                                     <GHC.Types.Bool>_N)
                                                (Data.Functor.Identity.N:Identity[0]
                                                     <(GHC.Types.Bool,
                                                       Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild3 { (,) a1 w5 ->
                                      w5 } } } #) }
                     } in
                     case $wgo5
                            (Data.Map.Base.toAscList1
                               @ GHC.Types.Word
                               @ CapDL.Model.Cap
                               (GHC.Types.[] @ (GHC.Types.Word, CapDL.Model.Cap))
                               (CapDL.State.objSlots w1)) of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Trans
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <([GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc)>_R))
                          (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                    <Text.PrettyPrint.HughesPJ.Doc>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[GHC.Types.Bool]>_N))) }
                 } in
                 (# case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w4 ->
                    (CapDL.State.checkObj_go a1) `cast` (Data.Monoid.N:All[0]) },
                    case ds
                           `cast`
                         (Trans
                              (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                   <Text.PrettyPrint.HughesPJ.Doc>_N
                                   <Data.Functor.Identity.Identity>_R
                                   <[GHC.Types.Bool]>_N)
                              (Data.Functor.Identity.N:Identity[0]
                                   <([GHC.Types.Bool],
                                     Text.PrettyPrint.HughesPJ.Doc)>_R)) of wild { (,) a1 w4 ->
                    w4 } #)) -}
12c115cd39697cfff04821c4d4cd16af
  $wcheckValidSlot ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> GHC.Types.Word
    -> CapDL.Model.Cap
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 4, Strictness: <L,1*U><L,1*U(1*U,1*U)><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (ww :: GHC.Types.Word)
                   (ww1 :: CapDL.Model.Cap) ->
                 let {
                   valid :: GHC.Types.Bool = CapDL.State.validObjCap w ww1
                 } in
                 (# valid,
                    case valid of wild {
                      GHC.Types.False
                      -> let {
                           s :: GHC.Base.String
                           = GHC.CString.unpackAppendCString#
                               "The cap at slot "#
                               (case ww of wild1 { GHC.Types.W# w2 ->
                                case GHC.Show.$wshowWord
                                       w2
                                       (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.: @ GHC.Types.Char ww3 ww4)
                                  (GHC.CString.unpackAppendCString#
                                     " in "#
                                     (case w1 of ww5 { (,) ww6 ww7 ->
                                      GHC.Base.++
                                        @ GHC.Types.Char
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows7
                                           (GHC.Types.:
                                              @ GHC.Types.Char
                                              GHC.Show.shows6
                                              (GHC.Show.showLitString
                                                 ww6
                                                 (GHC.Types.:
                                                    @ GHC.Types.Char
                                                    GHC.Show.shows6
                                                    (GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.shows5
                                                       (GHC.Show.$fShow(,)_$sgo
                                                          CapDL.State.checkASID2
                                                          (GHC.Show.$fShowMaybe_$cshowsPrec
                                                             @ GHC.Types.Word
                                                             GHC.Show.$fShowWord
                                                             GHC.Show.shows22
                                                             ww7)
                                                          (GHC.Types.[] @ GHC.Show.ShowS)))))))
                                        CapDL.State.checkValidSlot1 })) } })
                         } in
                         case GHC.List.$wlenAcc @ GHC.Types.Char s 0# of ww2 { DEFAULT ->
                         (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                            @ ()
                            (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                               @ ()
                               (Text.PrettyPrint.Annotated.HughesPJ.Str s)
                               ww2)
                            (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }
                      GHC.Types.True
                      -> (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                           `cast`
                         (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) } #)) -}
9c8c1a86459fa520b7d28f4afdb23962
  $wcheckValidSlots ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> (# GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U)>, Inline: [0] -}
f532d9dbddb061c9274462ed4cdb2523
  $wcspace ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
  {- Arity: 7, Strictness: <L,U><L,U><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0] -}
682fad750feb7a3cfa0c6871b364c440
  $wcspaceCap ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.Cap
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wpoly_go10
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        ww2 of wild {
                   GHC.Base.Nothing
                   -> case CapDL.State.checkCovers4 ww1 ww
                      ret_ty CapDL.Model.Cap
                      of {}
                   GHC.Base.Just obj
                   -> case CapDL.State.$wpoly_go1
                             @ CapDL.Model.Cap
                             0##
                             (CapDL.Model.slots @ GHC.Types.Word obj) of wild1 {
                        GHC.Base.Nothing -> Data.Maybe.fromJust1 @ CapDL.Model.Cap
                        GHC.Base.Just x -> x } }) -}
1a945b34eb86bbbfcb33df4a39cc4796
  $wfindSlots ::
    (CapDL.Model.Cap -> GHC.Types.Bool)
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> [(CapDL.Model.ObjID, GHC.Types.Word)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.Cap -> GHC.Types.Bool)
                   (ww :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 letrec {
                   go1 :: [(CapDL.Model.CapRef, CapDL.Model.Cap)]
                          -> [(CapDL.Model.ObjID, GHC.Types.Word)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(CapDL.Model.CapRef, CapDL.Model.Cap)]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (CapDL.Model.ObjID, GHC.Types.Word)
                       : y ys
                       -> case w (case y of wild1 { (,) ds1 y1 -> y1 }) of wild1 {
                            GHC.Types.False -> go1 ys
                            GHC.Types.True
                            -> GHC.Types.:
                                 @ (CapDL.Model.ObjID, GHC.Types.Word)
                                 (Data.Tuple.fst @ CapDL.Model.CapRef @ CapDL.Model.Cap y)
                                 (go1 ys) } }
                 } in
                 go1 (CapDL.State.$wallSlots ww)) -}
1f7f1829c2392b4c93fb26378e8db245
  $wflatten ::
    CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# CapDL.Model.Arch, CapDL.Model.ObjMap [GHC.Types.Word],
          CapDL.Model.IRQMap, CapDL.Model.CDT, CapDL.Model.CoverMap #)
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.Arch)
                   (ww1 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww2 :: CapDL.Model.IRQMap)
                   (ww3 :: CapDL.Model.CDT)
                   (ww4 :: CapDL.Model.CoverMap) ->
                 (# ww,
                    let {
                      wild :: CapDL.Model.Model GHC.Types.Word
                      = CapDL.Model.Model @ GHC.Types.Word ww ww1 ww2 ww3 ww4
                    } in
                    letrec {
                      go1 :: (CapDL.Model.ObjMap [GHC.Types.Word]
                              -> CapDL.Model.ObjMap [GHC.Types.Word])
                             -> Data.Map.Base.Map
                                  (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                  (CapDL.Model.KernelObject GHC.Types.Word)
                             -> CapDL.Model.ObjMap [GHC.Types.Word]
                             -> CapDL.Model.ObjMap [GHC.Types.Word]
                        {- Arity: 3, Strictness: <C(S),1*C1(U)><S,1*U><L,U> -}
                      = \ (z' :: CapDL.Model.ObjMap [GHC.Types.Word]
                                 -> CapDL.Model.ObjMap [GHC.Types.Word])
                          (ds :: Data.Map.Base.Map
                                   (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                                   (CapDL.Model.KernelObject GHC.Types.Word))
                          (eta :: CapDL.Model.ObjMap [GHC.Types.Word]) ->
                        case ds of wild1 {
                          Data.Map.Base.Bin dt kx x l r
                          -> case kx of ww5 { (,) ww6 ww7 ->
                             go1
                               (\ (tpl :: CapDL.Model.ObjMap [GHC.Types.Word])[OneShot] ->
                                go1 z' r (CapDL.State.$wflatten' wild tpl ww6 ww7 x))
                               l
                               eta }
                          Data.Map.Base.Tip -> z' eta }
                    } in
                    go1
                      (GHC.Base.id @ (CapDL.Model.ObjMap [GHC.Types.Word]))
                      ww1
                      (Data.Map.Base.Tip
                         @ CapDL.Model.ObjID
                         @ (CapDL.Model.KernelObject [GHC.Types.Word])),
                    ww2, ww3, ww4 #)) -}
db8b0c8026960a2558819f977fdedde6
  $wflatten' ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjMap [GHC.Types.Word]
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjMap [GHC.Types.Word]
  {- Arity: 5, Strictness: <L,U(U,U,U,U,U)><S,1*U><L,U><L,U><S,U>,
     Inline: [0] -}
3f773ad759e16a2e9c76839319da4f0c
  $wflattenCnode ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> (# CapDL.Model.ObjID,
          CapDL.Model.KernelObject [GHC.Types.Word] #)
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U,U,U)>, Inline: [0] -}
8f4a27018ae4e123b4dcdfa2a571c899
  $wgo ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
    -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
a36135549330ca008c1cfad5e69f58ca
  $wgo1 ::
    [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> (CapDL.Model.ObjID, GHC.Types.Word)
    -> Data.Set.Base.Set (CapDL.Model.ObjID, GHC.Types.Word)
    -> (# (CapDL.Model.ObjID, GHC.Types.Word),
          Data.Set.Base.Set (CapDL.Model.ObjID, GHC.Types.Word) #)
  {- Arity: 3, Strictness: <S,1*U><L,U(U(U,U),U(U))><L,U>,
     Inline: [0] -}
6c526f309ef2abc7243fce276e2df7d9
  $wgo2 ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word,
      GHC.Types.Word)]
    -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
62ec6daf702252465f2a857e6912b5d7
  $wgo3 ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
    -> (# [GHC.Types.Bool], Text.PrettyPrint.HughesPJ.Doc #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
1301c3fd96396ea7442eefe55a5d265d
  $wgo4 ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
    -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
3bc63d3ee0d0722210cb33d52eb581fe
  $wlvl :: [GHC.Types.Char] -> GHC.Types.Word -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Char]) (ww1 :: GHC.Types.Word) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   ww
                   (GHC.CString.unpackAppendCString#
                      ", slot "#
                      (case ww1 of wild { GHC.Types.W# w ->
                       case GHC.Show.$wshowWord
                              w
                              (GHC.Types.[] @ GHC.Types.Char) of ww2 { (#,#) ww3 ww4 ->
                       GHC.Types.: @ GHC.Types.Char ww3 ww4 } }))) -}
51cd5506aefd7263d41059e65a000468
  $wlvl1 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Prim.Word#
    -> Control.Monad.Trans.State.Lazy.StateT
         (CapDL.Model.Model GHC.Types.Word)
         Data.Functor.Identity.Identity
         ()
  {- Arity: 3, Strictness: <B,1*U><B,1*U><B,U>x, Inline: [0] -}
52d89dd927c79b6d041dcbc40e0467a7
  $wmaybeSlotCap ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Prim.Word#
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> GHC.Base.Maybe CapDL.Model.Cap
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: GHC.Prim.Word#)
                   (ww3 :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wpoly_go10
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        ww3 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ CapDL.Model.Cap
                   GHC.Base.Just x
                   -> CapDL.State.$wpoly_go1
                        @ CapDL.Model.Cap
                        ww2
                        (CapDL.State.objSlots x) }) -}
26fa652171f79f3ef03c79931be1276c
  $wobject ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wpoly_go10
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        ww2 of wild {
                   GHC.Base.Nothing -> CapDL.State.checkCovers4 ww1 ww
                   GHC.Base.Just obj -> obj }) -}
615801fbf96ff060c8d845eb1c558ec1
  $wpoly_go1 ::
    GHC.Prim.Word#
    -> Data.Map.Base.Map GHC.Types.Word a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
adcce1cf8778352b472780dfed24c66a
  $wpoly_go10 ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> Data.Map.Base.Map CapDL.Model.ObjID a
    -> GHC.Base.Maybe a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Inline: [0] -}
b5e6f766476e616a14eb71ec4e2ad2ba
  $wrefSlots ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjID)
                   (ww1 :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 letrec {
                   go1 :: [((CapDL.Model.ObjID, GHC.Types.Word), CapDL.Model.Cap)]
                          -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap
                          -> [((CapDL.Model.ObjID, GHC.Types.Word), CapDL.Model.Cap)]
                     {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                   = \ (z' :: [((CapDL.Model.ObjID, GHC.Types.Word),
                                CapDL.Model.Cap)])
                       (ds :: Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap) ->
                     case ds of wild {
                       Data.Map.Base.Bin dt kx x l r
                       -> go1
                            (GHC.Types.:
                               @ ((CapDL.Model.ObjID, GHC.Types.Word), CapDL.Model.Cap)
                               ((ww, kx), x)
                               (go1 z' r))
                            l
                       Data.Map.Base.Tip -> z' }
                 } in
                 go1
                   (GHC.Types.[]
                      @ ((CapDL.Model.ObjID, GHC.Types.Word), CapDL.Model.Cap))
                   (CapDL.State.objSlots ww1)) -}
71ecbfd7d88fddcac558623d1f011d54
  $wremoveCap ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Types.Word
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# (), CapDL.Model.Model GHC.Types.Word #)
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*U(U)><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: GHC.Types.Word)
                   (ww3 :: CapDL.Model.Arch)
                   (ww4 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww5 :: CapDL.Model.IRQMap)
                   (ww6 :: CapDL.Model.CDT)
                   (ww7 :: CapDL.Model.CoverMap) ->
                 CapDL.State.$wsetSlots
                   ww
                   ww1
                   (case ww2 of ww8 { GHC.Types.W# ww9 ->
                    case CapDL.State.$wpoly_go10
                           @ (CapDL.Model.KernelObject GHC.Types.Word)
                           ww
                           ww1
                           ww4 of wild {
                      GHC.Base.Nothing
                      -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                      GHC.Base.Just x
                      -> CapDL.State.$w$sgo10
                           @ CapDL.Model.Cap
                           ww9
                           (CapDL.State.objSlots x) } })
                   ww3
                   ww4
                   ww5
                   ww6
                   ww7) -}
7bad5bdf1d7ed7be71d0430610bb1843
  $wsetCap ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Prim.Word#
    -> CapDL.Model.Cap
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# (), CapDL.Model.Model GHC.Types.Word #)
  {- Arity: 9,
     Strictness: <L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: GHC.Prim.Word#)
                   (w :: CapDL.Model.Cap)
                   (ww3 :: CapDL.Model.Arch)
                   (ww4 :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww5 :: CapDL.Model.IRQMap)
                   (ww6 :: CapDL.Model.CDT)
                   (ww7 :: CapDL.Model.CoverMap) ->
                 let {
                   ds :: CapDL.Model.CapMap GHC.Types.Word
                   = case CapDL.State.$wpoly_go10
                            @ (CapDL.Model.KernelObject GHC.Types.Word)
                            ww
                            ww1
                            ww4 of wild {
                       GHC.Base.Nothing
                       -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                       GHC.Base.Just x -> CapDL.State.objSlots x }
                 } in
                 case CapDL.State.$wpoly_go1 @ CapDL.Model.Cap ww2 ds of wild {
                   GHC.Base.Nothing
                   -> CapDL.State.$wsetSlots
                        ww
                        ww1
                        (CapDL.State.$w$sgo2 @ CapDL.Model.Cap ww2 w ds)
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case CapDL.State.$wlvl1 ww ww1 ww2
                           ret_ty (# (), CapDL.Model.Model GHC.Types.Word #)
                           of {}
                        CapDL.Model.NullCap
                        -> CapDL.State.$wsetSlots
                             ww
                             ww1
                             (CapDL.State.$w$sgo2 @ CapDL.Model.Cap ww2 w ds)
                             ww3
                             ww4
                             ww5
                             ww6
                             ww7 } }) -}
5683d30281dd41b95804cdeac64c1251
  $wsetSlots ::
    GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.CapMap GHC.Types.Word
    -> CapDL.Model.Arch
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> CapDL.Model.IRQMap
    -> CapDL.Model.CDT
    -> CapDL.Model.CoverMap
    -> (# (), CapDL.Model.Model GHC.Types.Word #)
  {- Arity: 8, Strictness: <L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U>,
     Inline: [0] -}
045eef9bca878335dd90c04dc597426e
  $wtypAt ::
    CapDL.Model.KOType
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> CapDL.Model.ObjMap GHC.Types.Word
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs, Strictness: <L,1*U><L,U><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.KOType)
                   (ww :: GHC.Base.String)
                   (ww1 :: GHC.Base.Maybe GHC.Types.Word)
                   (ww2 :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wpoly_go10
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww
                        ww1
                        ww2 of wild {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just x
                   -> case case x of wild1 {
                             CapDL.Model.Endpoint -> CapDL.Model.Endpoint_T
                             CapDL.Model.Notification -> CapDL.Model.Notification_T
                             CapDL.Model.TCB ds ds1 ds2 ds3 ds4 -> CapDL.Model.TCB_T
                             CapDL.Model.CNode ds ds1 -> CapDL.Model.CNode_T
                             CapDL.Model.Untyped ds ds1 -> CapDL.Model.Untyped_T
                             CapDL.Model.SC ds ds1 -> CapDL.Model.SC_T
                             CapDL.Model.RTReply -> CapDL.Model.RTReply_T
                             CapDL.Model.ASIDPool ds -> CapDL.Model.ASIDPool_T
                             CapDL.Model.PT ds -> CapDL.Model.PT_T
                             CapDL.Model.PD ds -> CapDL.Model.PD_T
                             CapDL.Model.PDPT ds -> CapDL.Model.PDPT_T
                             CapDL.Model.PML4 ds -> CapDL.Model.PML4_T
                             CapDL.Model.PUD ds -> CapDL.Model.PUD_T
                             CapDL.Model.PGD ds -> CapDL.Model.PGD_T
                             CapDL.Model.Frame ds ds1 ds2 -> CapDL.Model.Frame_T
                             CapDL.Model.ARMIODevice ds ds1 -> CapDL.Model.ARMIODevice_T
                             CapDL.Model.IOPorts ds -> CapDL.Model.IOPorts_T
                             CapDL.Model.IODevice ds ds1 ds2 -> CapDL.Model.IODevice_T
                             CapDL.Model.IOPT ds ds1 -> CapDL.Model.IOPT_T
                             CapDL.Model.VCPU -> CapDL.Model.VCPU_T
                             CapDL.Model.IOAPICIrq ds ds1 ds2 ds3 ds4
                             -> CapDL.Model.IOAPICIrqSlot_T
                             CapDL.Model.MSIIrq ds ds1 ds2 ds3 ds4
                             -> CapDL.Model.MSIIrqSlot_T } of x2 { DEFAULT ->
                      GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==#
                           (GHC.Prim.dataToTag# @ CapDL.Model.KOType w)
                           (GHC.Prim.dataToTag# @ CapDL.Model.KOType x2)) } }) -}
2e9c93fed7d48bf88be0d98f45575015
  $wuniqueASID ::
    CapDL.Model.ObjID
    -> CapDL.Model.ObjMap GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjID)
                   (ww :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wgo
                        (CapDL.State.$wallMappings w ww)
                        0# of ww1 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# ww1 1#) }) -}
2da741cbb62a81e53f6cc41cab2197fd
  $wuniquePD ::
    CapDL.Model.ObjID
    -> CapDL.Model.ObjMap GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U>, Inline: [0],
     Unfolding: (\ (w :: CapDL.Model.ObjID)
                   (ww :: CapDL.Model.ObjMap GHC.Types.Word) ->
                 case CapDL.State.$wgo4
                        (CapDL.State.$wallMappings w ww)
                        0# of ww1 { DEFAULT ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# ww1 1#) }) -}
b112b871fb65733c296df12490c28ac2
  $wvalidIRQ ::
    CapDL.Model.ObjMap GHC.Types.Word
    -> GHC.Base.String
    -> GHC.Base.Maybe GHC.Types.Word
    -> GHC.Types.Bool
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: CapDL.Model.ObjMap GHC.Types.Word)
                   (ww1 :: GHC.Base.String)
                   (ww2 :: GHC.Base.Maybe GHC.Types.Word) ->
                 case CapDL.State.$wpoly_go10
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ww1
                        ww2
                        ww of wild {
                   GHC.Base.Nothing
                   -> case CapDL.State.checkCovers4 ww2 ww1
                      ret_ty GHC.Types.Bool
                      of {}
                   GHC.Base.Just obj
                   -> case obj of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.CNode ds ds1
                        -> case ds1 of wild2 { GHC.Types.W# ds2 ->
                           case ds2 of ds3 {
                             DEFAULT -> GHC.Types.False 0## -> GHC.Types.True } }
                        CapDL.Model.IOAPICIrq ds ds1 ds2 ds3 ds4 -> GHC.Types.True
                        CapDL.Model.MSIIrq ds ds1 ds2 ds3 ds4 -> GHC.Types.True } }) -}
8d72de654497abf160779b3645c66c47
  type CapLookup = [([GHC.Types.Word], CapDL.Model.Cap)]
aee630495a609646d47c556da8070d10
  type Kernel a =
    Control.Monad.Trans.State.Lazy.State
      (CapDL.Model.Model GHC.Types.Word) a
370c306fc560ec08bde44f1b6633ba07
  type Logger a =
    Control.Monad.Trans.Writer.Lazy.Writer
      Text.PrettyPrint.HughesPJ.Doc a
0b05f3a7d9f304923f53c3f9180bf241
  type SlotsLookup =
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.CapMap GHC.Types.Word
840bd1780f5215a822998ff7d69691e0
  allCovers ::
    CapDL.Model.Model GHC.Types.Word
    -> [Data.Set.Base.Set CapDL.Model.ObjID]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLLS),1*U(A,A,A,A,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wallCovers ww5 }) -}
da6d08444c8ce6fc741fac4ace225dad
  allCovers_go10 ::
    [Data.Set.Base.Set CapDL.Model.ObjID]
    -> Data.Map.Base.Map
         (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
         (Data.Set.Base.Set CapDL.Model.ObjID)
    -> [Data.Set.Base.Set CapDL.Model.ObjID]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
d298fc5b413c520621f2c732a4edffe9
  allLevels ::
    CapDL.State.CapLookup
    -> GHC.Types.Int
    -> CapDL.State.SlotsLookup
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.CapLookup
  {- Arity: 4, Strictness: <S,1*U><L,1*U(1*U)><L,C(C1(U))><L,U>,
     Unfolding: (\ (ds :: [([GHC.Types.Word], CapDL.Model.Cap)])
                   (ds1 :: GHC.Types.Int)
                   (ds2 :: CapDL.State.SlotsLookup)
                   (ds3 :: CapDL.Model.Model GHC.Types.Word) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap)
                   : ipv ipv1
                   -> case ds1 of wild1 { GHC.Types.I# ds4 ->
                      case ds4 of ds5 {
                        DEFAULT
                        -> GHC.Base.++
                             @ ([GHC.Types.Word], CapDL.Model.Cap)
                             wild
                             (CapDL.State.allLevels_$sallLevels
                                ds3
                                ds2
                                (GHC.Prim.-# ds5 1#)
                                (CapDL.State.nextLevel ds3 wild ds2))
                        0# -> GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap) } } }) -}
797cd5547abdd01024dcc5d2ced1c297
  allLevels_$sallLevels ::
    CapDL.Model.Model GHC.Types.Word
    -> (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
        -> CapDL.Model.Model GHC.Types.Word
        -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap)
    -> GHC.Prim.Int#
    -> [([GHC.Types.Word], CapDL.Model.Cap)]
    -> CapDL.State.CapLookup
  {- Arity: 4, Strictness: <L,U><L,C(C1(U))><L,1*U><S,1*U> -}
9cb0c08b228bce2bdb22b71e56fd7566
  allM ::
    (Data.Traversable.Traversable t, GHC.Base.Monad m) =>
    (a -> m GHC.Types.Bool) -> t a -> m GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,1*U,A,A,1*C1(C1(C1(U))),A)><S(LC(C(S))LLL),U(U,U,U,U,U)><L,U><L,U>,
     Unfolding: (\ @ (t :: * -> *)
                   @ (m :: * -> *)
                   @ a
                   ($dTraversable :: Data.Traversable.Traversable t)
                   ($dMonad :: GHC.Base.Monad m)
                   (eta :: a -> m GHC.Types.Bool)
                   (eta1 :: t a) ->
                 let {
                   lvl62 :: GHC.Types.Bool -> m GHC.Types.Bool
                   = GHC.Base.return @ m $dMonad @ GHC.Types.Bool
                 } in
                 let {
                   $dFoldable :: Data.Foldable.Foldable t
                   = Data.Traversable.$p2Traversable @ t $dTraversable
                 } in
                 GHC.Base.>>=
                   @ m
                   $dMonad
                   @ (t GHC.Types.Bool)
                   @ GHC.Types.Bool
                   (Data.Traversable.mapM
                      @ t
                      $dTraversable
                      @ m
                      @ a
                      @ GHC.Types.Bool
                      $dMonad
                      eta
                      eta1)
                   (\ (bs :: t GHC.Types.Bool) ->
                    lvl62
                      (Data.Foldable.foldMap
                         @ t
                         $dFoldable
                         @ Data.Monoid.All
                         @ GHC.Types.Bool
                         Data.Monoid.$fMonoidAll
                         Data.Foldable.and2
                           `cast`
                         (<GHC.Types.Bool>_R ->_R Sym (Data.Monoid.N:All[0]))
                         bs)
                        `cast`
                      (Data.Monoid.N:All[0]))) -}
827e372854152f0161121b1dca6d9212
  allMappings ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
  {- Arity: 2, Strictness: <L,U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wallMappings w ww2 }) -}
e75643f02a7318e1faab47c4f6d05965
  allObjs ::
    CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: CapDL.Model.Model GHC.Types.Word) ->
                 case x of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 GHC.Base.build
                   @ ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                      CapDL.Model.KernelObject GHC.Types.Word)
                   (\ @ b
                      (c :: ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                             CapDL.Model.KernelObject GHC.Types.Word)
                            -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    Data.Map.Base.foldrFB
                      @ (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
                      @ (CapDL.Model.KernelObject GHC.Types.Word)
                      @ b
                      (\ (k1 :: (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word))
                         (x1 :: CapDL.Model.KernelObject GHC.Types.Word)[OneShot]
                         (xs :: b)[OneShot] ->
                       c (k1, x1) xs)
                      n
                      ds2) }) -}
64f7055dd28d58adfd4255348ef00156
  allSlots ::
    CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wallSlots ww2 }) -}
2db26ede9588706ec7c3838de5818b97
  allSlots_go10 ::
    [(CapDL.Model.CapRef, CapDL.Model.Cap)]
    -> Data.Map.Base.Map
         (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
e1dc1c81f57f62f108642515c6fcd130
  cNodeSlots :: CapDL.State.SlotsLookup
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (m :: CapDL.Model.Model GHC.Types.Word) ->
                 case m of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing
                   -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   GHC.Base.Just ds
                   -> case ds of wild2 {
                        DEFAULT -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                        CapDL.Model.CNode slots ds7 -> slots } } }) -}
1e546bf290d1c0644dc0c1a515a8900a
  capLookup ::
    [GHC.Types.Word]
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Base.Maybe CapDL.Model.Cap
  {- Arity: 3, Strictness: <S,1*U><S,U(U,U)><S(LSLLL),U(U,U,U,U,U)>,
     Unfolding: InlineRule (3, True, False)
                (\ (ref :: [GHC.Types.Word])
                   (tcb_ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 CapDL.State.$slookup5
                   @ CapDL.Model.Cap
                   ref
                   (CapDL.State.cspace tcb_ref eta)) -}
8070089679b6907bb3982d9886d84905
  capSpace ::
    CapDL.Model.CapMap GHC.Types.Word
    -> CapDL.State.SlotsLookup
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.CapMap [GHC.Types.Word]
  {- Arity: 2, Strictness: <L,1*U><L,C(C1(U))>,
     Unfolding: (\ (caps :: CapDL.Model.CapMap GHC.Types.Word)
                   (lookup :: CapDL.State.SlotsLookup) ->
                 let {
                   g :: [([GHC.Types.Word], CapDL.Model.Cap)]
                   = Data.Map.Base.toAscList1
                       @ [GHC.Types.Word]
                       @ CapDL.Model.Cap
                       (GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap))
                       (CapDL.State.$smapKeys
                          @ GHC.Types.Word
                          @ CapDL.Model.Cap
                          (CapDL.State.singleton @ GHC.Types.Word)
                          caps)
                 } in
                 \ (x :: CapDL.Model.Model GHC.Types.Word) ->
                 CapDL.State.$sfromList
                   @ CapDL.Model.Cap
                   (CapDL.State.allLevels_$sallLevels x lookup 4# g)) -}
56d91702a010ff91020f85e6333525d3
  capSpaceLookup ::
    CapDL.Model.CapMap GHC.Types.Word
    -> CapDL.State.SlotsLookup
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.CapLookup
  {- Arity: 2, Strictness: <L,1*U><L,C(C1(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (caps :: CapDL.Model.CapMap GHC.Types.Word)
                   (lookup :: CapDL.State.SlotsLookup) ->
                 CapDL.State.allLevels
                   (CapDL.State.capSpaceLookup1 caps)
                   CapDL.State.maxDepth
                   lookup) -}
c9f94c09a80c0ea9f46355760ce63d4e
  capSpaceLookup1 ::
    Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap
    -> [([GHC.Types.Word], CapDL.Model.Cap)]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap) ->
                 Data.Map.Base.toAscList1
                   @ [GHC.Types.Word]
                   @ CapDL.Model.Cap
                   (GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap))
                   (CapDL.State.$smapKeys
                      @ GHC.Types.Word
                      @ CapDL.Model.Cap
                      (CapDL.State.singleton @ GHC.Types.Word)
                      x)) -}
1bf0420add9665dd696c4d90d33d5d7f
  capTyp :: CapDL.Model.Cap -> CapDL.Model.KOType
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.Cap) ->
                 case ds of wild {
                   DEFAULT -> CapDL.State.capTyp1
                   CapDL.Model.UntypedCap ds1 -> CapDL.Model.Untyped_T
                   CapDL.Model.EndpointCap ds1 ds2 ds3 -> CapDL.Model.Endpoint_T
                   CapDL.Model.NotificationCap ds1 ds2 ds3
                   -> CapDL.Model.Notification_T
                   CapDL.Model.ReplyCap ds1 -> CapDL.Model.TCB_T
                   CapDL.Model.MasterReplyCap ds1 -> CapDL.Model.TCB_T
                   CapDL.Model.CNodeCap ds1 ds2 ds3 -> CapDL.Model.CNode_T
                   CapDL.Model.TCBCap ds1 -> CapDL.Model.TCB_T
                   CapDL.Model.IRQHandlerCap ds1 -> CapDL.Model.CNode_T
                   CapDL.Model.IRQIOAPICHandlerCap ds1 -> CapDL.Model.IOAPICIrqSlot_T
                   CapDL.Model.IRQMSIHandlerCap ds1 -> CapDL.Model.MSIIrqSlot_T
                   CapDL.Model.SCCap ds1 -> CapDL.Model.SC_T
                   CapDL.Model.RTReplyCap ds1 -> CapDL.Model.RTReply_T
                   CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5 -> CapDL.Model.Frame_T
                   CapDL.Model.PTCap ds1 ds2 -> CapDL.Model.PT_T
                   CapDL.Model.PDCap ds1 ds2 -> CapDL.Model.PD_T
                   CapDL.Model.PDPTCap ds1 ds2 -> CapDL.Model.PDPT_T
                   CapDL.Model.PML4Cap ds1 ds2 -> CapDL.Model.PML4_T
                   CapDL.Model.PUDCap ds1 ds2 -> CapDL.Model.PUD_T
                   CapDL.Model.PGDCap ds1 ds2 -> CapDL.Model.PGD_T
                   CapDL.Model.ASIDPoolCap ds1 ds2 -> CapDL.Model.ASIDPool_T
                   CapDL.Model.ARMIOSpaceCap ds1 -> CapDL.Model.ARMIODevice_T
                   CapDL.Model.IOPortsCap ds1 -> CapDL.Model.IOPorts_T
                   CapDL.Model.IOSpaceCap ds1 -> CapDL.Model.IODevice_T
                   CapDL.Model.IOPTCap ds1 -> CapDL.Model.IOPT_T
                   CapDL.Model.VCPUCap ds1 -> CapDL.Model.VCPU_T }) -}
25a5b2a53335b3fca950a2e78b318a0f
  capTyp1 :: CapDL.Model.KOType
  {- Strictness: x -}
6322ae2d27ff203018d5b15315e469d3
  checkASID ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><L,1*U(A,1*U,A,A,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckASID w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
6b8648893b0c07a0552d6820c729cbdb
  checkASID1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is mapped into multiple ASID's\n"#) -}
1dbc639ba62335c3f78605ce71b69ae0
  checkASID2 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c1fd5db0a9fd214f55caf29a94281a3d
  checkCapArch ::
    CapDL.Model.Arch
    -> CapDL.Model.Cap
    -> CapDL.Model.ObjID
    -> GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 4, Strictness: <L,1*U><L,1*U><L,1*U(1*U,1*U)><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Cap)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: GHC.Types.Word) ->
                 case CapDL.State.$wcheckCapArch w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
9ea40dfa6990bdceeaf289a04551c287
  checkCapArch1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is not valid for this architecture\n"#) -}
e8e009ddc628bcb71bb73931ecf4618f
  checkCovers ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U(A,U,A,A,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckCovers w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
f8256c6c26d033e8cdce2c9e94b6e360
  checkCovers1 :: Text.PrettyPrint.HughesPJ.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        CapDL.State.checkCovers_s
                        0# of ww2 { DEFAULT ->
                 (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                    @ ()
                    (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                       @ ()
                       CapDL.State.checkCovers2
                       ww2)
                    (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                   `cast`
                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }) -}
da77f3ff911b47b16c5774146748783c
  checkCovers2 :: Text.PrettyPrint.Annotated.HughesPJ.TextDetails
  {- Unfolding: (Text.PrettyPrint.Annotated.HughesPJ.Str
                   CapDL.State.checkCovers_s) -}
780dbea9c5bcf317d835bcec923e854b
  checkCovers3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " covers objects but is not an untyped\n"#) -}
365ae2f511048263565d4586734fa231
  checkCovers4 ::
    GHC.Base.Maybe GHC.Types.Word
    -> GHC.Base.String -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <L,U><L,U>x -}
e18a585dd48f45fb5f5d1bacc84a33e9
  checkCovers5 :: CapDL.Model.CDT
  {- Strictness: x -}
d52fe4b88aeb45ce79f699b73919b4e5
  checkCovers6 :: CapDL.Model.IRQMap
  {- Strictness: x -}
99aa8d7d938f8b15f7f2adf7a4d648c5
  checkCovers7 :: CapDL.Model.Arch
  {- Strictness: x -}
1d238a12e007b15b380f29a07af065a1
  checkCovers8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " covers a non-existant object\n"#) -}
c985fb5f62bf3f73d38d558193905769
  checkCovers_$s$snullIntersections ::
    Data.Set.Base.Set ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> [Data.Set.Base.Set
          ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,U> -}
8d5b6228db6564982a399a949e1dce84
  checkCovers_$sgo5 ::
    Data.Set.Base.Set ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
    -> [Data.Set.Base.Set
          ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)]
    -> Data.Set.Base.Set CapDL.Model.ObjID
  {- Arity: 2, Strictness: <L,U><L,U> -}
8b7828e9d121b8d108de3c5f05070eb2
  checkCovers_$snullIntersections ::
    [Data.Set.Base.Set CapDL.Model.ObjID] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Data.Set.Base.Set CapDL.Model.ObjID]) ->
                 case ds of wild {
                   [] -> GHC.Types.True
                   : ds1 ds2
                   -> case ds2 of wild1 {
                        [] -> GHC.Types.True
                        : ipv ipv1
                        -> case ds1 of wild2 {
                             Data.Set.Base.Bin ipv2 ipv3 ipv4 ipv5
                             -> case CapDL.State.checkCovers_$sgo5 ipv ipv1 of wild3 {
                                  Data.Set.Base.Bin ipv6 ipv7 ipv8 ipv9
                                  -> case Data.Set.Base.intersection_$shedgeInt
                                            @ CapDL.Model.ObjID
                                            ipv6
                                            ipv7
                                            ipv8
                                            ipv9
                                            ipv2
                                            ipv3
                                            ipv4
                                            ipv5
                                            (Data.Set.Base.NothingS @ CapDL.Model.ObjID)
                                            (Data.Set.Base.NothingS @ CapDL.Model.ObjID)
                                            CapDL.State.$s$fOrd(,) of wild4 {
                                       Data.Set.Base.Bin dt ds3 ds4 ds5 -> GHC.Types.False
                                       Data.Set.Base.Tip
                                       -> CapDL.State.checkCovers_$s$snullIntersections ipv ipv1 }
                                  Data.Set.Base.Tip
                                  -> CapDL.State.checkCovers_$s$snullIntersections ipv ipv1 }
                             Data.Set.Base.Tip
                             -> CapDL.State.checkCovers_$s$snullIntersections ipv ipv1 } } }) -}
6527955dbbd6359fbd8e8e13cb93f21d
  checkCovers_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
85dc399d00b41c974e38b345d8486d62
  checkCovers_go1 :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
6cc5304cc88e066f1ae450275a794116
  checkCovers_go10 ::
    [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
    -> Data.Map.Base.Map
         (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
         (Data.Set.Base.Set CapDL.Model.ObjID)
    -> [(GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
e87db820ac5e265e2650bf95996ca6ec
  checkCovers_go2 ::
    [(CapDL.Model.ObjID, [CapDL.Model.ObjID])]
    -> Data.Map.Base.Map
         (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
         (Data.Set.Base.Set CapDL.Model.ObjID)
    -> [(CapDL.Model.ObjID, [CapDL.Model.ObjID])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
3546ce4eb59091a0fe7dbac90b187eb0
  checkCovers_go3 ::
    [CapDL.Model.ObjID]
    -> CapDL.Model.Model GHC.Types.Word -> [GHC.Types.Bool]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(A,U,A,A,A)> -}
e00c6d9489e0eb48ed7a99aa01bb2dd1
  checkCovers_go4 :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
25736882c0b3078e695f821a48fff1b9
  checkCovers_s :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "At least two untypeds have intersecting covers\n"#) -}
11299e9b48b5125bb6cd3c2177f648d9
  checkDuplicateMappedFrameCaps ::
    [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [(CapDL.Model.ObjID, GHC.Types.Word)]) ->
                 case CapDL.State.$wcheckDuplicateMappedFrameCaps
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
8cd423d45d5b44f67eeecc340ce4f8f0
  checkDuplicateMappedFrameCaps1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "\n"#) -}
36923d19412b8463d33f0ff1d9f20243
  checkDuplicateMappedFrameCaps2 ::
    (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SL)L),1*U(1*U(1*U,A),1*U(U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word),
                          GHC.Types.Word)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 -> CapDL.State.$wlvl ww4 ww2 } }) -}
b41d14a355133e436666128369b37fb9
  checkDuplicateMappedFrameCaps3 ::
    ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word), GHC.Types.Word)
    -> ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
        GHC.Types.Word)
    -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (w2 :: ((GHC.Base.String,
                            GHC.Base.Maybe GHC.Types.Word),
                           GHC.Types.Word))
                   (w3 :: ((GHC.Base.String, GHC.Base.Maybe GHC.Types.Word),
                           GHC.Types.Word))[OneShot] ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case w3 of ww3 { (,) ww4 ww5 ->
                 case ww1 of ww7 { (,) ww8 ww9 ->
                 case ww4 of ww10 { (,) ww11 ww12 ->
                 case GHC.Classes.$fOrd[]_$s$ccompare1 ww8 ww11 of wild {
                   GHC.Types.LT -> GHC.Types.LT
                   GHC.Types.EQ
                   -> case ww9 of wild1 {
                        GHC.Base.Nothing
                        -> case ww12 of wild2 {
                             GHC.Base.Nothing -> GHC.Classes.compareWord ww2 ww5
                             GHC.Base.Just ipv -> GHC.Types.LT }
                        GHC.Base.Just a2
                        -> case ww12 of wild2 {
                             GHC.Base.Nothing -> GHC.Types.GT
                             GHC.Base.Just b1
                             -> case a2 of wild3 { GHC.Types.W# x# ->
                                case b1 of wild4 { GHC.Types.W# y# ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.ltWord# x# y#) of wild5 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.eqWord# x# y#) of wild6 {
                                       GHC.Types.False -> GHC.Types.GT
                                       GHC.Types.True -> GHC.Classes.compareWord ww2 ww5 }
                                  GHC.Types.True -> GHC.Types.LT } } } } }
                   GHC.Types.GT -> GHC.Types.GT } } } } }) -}
4b29b2a5da8cac95154e71383dea6815
  checkDuplicateMappedFrameCaps_$sfindDuplicates ::
    [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> [(CapDL.Model.ObjID, GHC.Types.Word)]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (eta :: [(CapDL.Model.ObjID, GHC.Types.Word)]) ->
                 case eta of wild {
                   [] -> GHC.Types.[] @ (CapDL.Model.ObjID, GHC.Types.Word)
                   : ipv ipv1
                   -> case Data.OldList.sortBy
                             @ (CapDL.Model.ObjID, GHC.Types.Word)
                             CapDL.State.checkDuplicateMappedFrameCaps3
                             wild of wild1 {
                        []
                        -> case GHC.List.scanl2
                           ret_ty [(CapDL.Model.ObjID, GHC.Types.Word)]
                           of {}
                        : ds1 xs
                        -> case CapDL.State.$wgo1
                                  xs
                                  ds1
                                  (Data.Set.Base.Tip
                                     @ (CapDL.Model.ObjID, GHC.Types.Word)) of ww { (#,#) ww1 ww2 ->
                           Data.Set.Base.toAscList
                             @ (CapDL.Model.ObjID, GHC.Types.Word)
                             ww2 } } }) -}
086ac529d35d6c3d2b1b4751216a11c7
  checkIRQ ::
    CapDL.Model.Model GHC.Types.Word
    -> (GHC.Types.Word, CapDL.Model.ObjID)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U,A,A,A)><S,1*U(1*U(U),U(U,U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: (GHC.Types.Word, CapDL.Model.ObjID)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckIRQ w ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
bb30f403b54f3d65d816ab246396e6d3
  checkIRQ1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " in the irqNode is not a valid irq_slot\n"#) -}
6faed095147c664549401a2ba4f4e086
  checkIRQNode ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U(A,U,1*U,A,A)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckIRQNode w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
b5818224e2d70d98e42a823adafd0121
  checkIRQNode_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c4ada19559f3a3e2341248ec0097f938
  checkMappedFrameCaps ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U(A,U,A,A,A)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckMappedFrameCaps w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
7ef8054f0bebf756b9b57c29c92f7051
  checkMappedFrameCapsOnlyInCNodes ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U(A,1*U,A,A,A)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckMappedFrameCapsOnlyInCNodes
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
35386d93f97a3f8caa76c72b3f97c9ef
  checkMappedFrameCapsSanity ::
    CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.ObjID, GHC.Types.Word)]
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(A,U,A,A,A)><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: [(CapDL.Model.ObjID, GHC.Types.Word)]) ->
                 case CapDL.State.$wcheckMappedFrameCapsSanity
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
0ac0eda923bcbbdb57079fbdadcacfdc
  checkMappedFrameCaps_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b32ca0f532ce32223e9576ad7ca80554
  checkMappedFrameCaps_go1 ::
    [CapDL.Model.Cap] -> [(CapDL.Model.ObjID, GHC.Types.Word)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
13dcc5c5af391fad058be53d9b9d1ce8
  checkMappedFrameCaps_go10 ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
    -> Data.Map.Base.Map
         (GHC.Base.String, GHC.Base.Maybe GHC.Types.Word)
         (CapDL.Model.KernelObject GHC.Types.Word)
    -> [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
8bceeb9734daff1d02eb15f0c7b669e3
  checkMappedFrameCaps_go2 :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
e6930552ece949e4919e10fb3ecf4659
  checkMapping ::
    CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,1*U(A,1*U,A,A,A)><S(LS),1*U(U(U,U),1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: (CapDL.Model.ObjID,
                           CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww2 of wild {
                   DEFAULT
                   -> (GHC.Types.True,
                       (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                         `cast`
                       (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])))
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Types.Bool>_N)))
                   CapDL.Model.PT ds
                   -> case CapDL.State.$wcheckPD ww1 w of ww3 { (#,#) ww4 ww5 ->
                      (ww4, ww5)
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Types.Bool>_N))) }
                   CapDL.Model.PD ds
                   -> case CapDL.State.$wcheckASID ww1 w of ww3 { (#,#) ww4 ww5 ->
                      (ww4, ww5)
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Types.Bool>_N))) } } }) -}
eeeb08145bc02f6bb56845129b5657c7
  checkMapping1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is mapped into multiple PD's\n"#) -}
26dcb1dba6410f7ec755f3666a697b50
  checkMappingSanity ::
    (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word,
     GHC.Types.Word)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LSL),1*U(1*U(1*U,A),1*U,1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (CapDL.Model.ObjID,
                          CapDL.Model.KernelObject GHC.Types.Word, GHC.Types.Word)) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case CapDL.State.$wcheckMappingSanity
                        ww1
                        ww2
                        ww3 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
be4952de611d7fa2ecaf9dd8ee113600
  checkMappingSanity1 :: Text.PrettyPrint.HughesPJ.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        CapDL.State.checkMappingSanity_s
                        0# of ww2 { DEFAULT ->
                 (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                    @ ()
                    (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                       @ ()
                       CapDL.State.checkMappingSanity2
                       ww2)
                    (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                   `cast`
                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }) -}
584ee4fbdf3c9b8bc72733eab828cc6c
  checkMappingSanity2 ::
    Text.PrettyPrint.Annotated.HughesPJ.TextDetails
  {- Unfolding: (Text.PrettyPrint.Annotated.HughesPJ.Str
                   CapDL.State.checkMappingSanity_s) -}
4946ca55587773aab3cb0d343e9e85f8
  checkMappingSanity3 :: Text.PrettyPrint.HughesPJ.Doc
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ GHC.Types.Char
                        CapDL.State.checkMappingSanity_s1
                        0# of ww2 { DEFAULT ->
                 (Text.PrettyPrint.Annotated.HughesPJ.TextBeside
                    @ ()
                    (Text.PrettyPrint.Annotated.HughesPJ.NoAnnot
                       @ ()
                       CapDL.State.checkMappingSanity4
                       ww2)
                    (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ()))
                   `cast`
                 (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])) }) -}
616cdfd7f66d7108ebf76fc7e3924764
  checkMappingSanity4 ::
    Text.PrettyPrint.Annotated.HughesPJ.TextDetails
  {- Unfolding: (Text.PrettyPrint.Annotated.HughesPJ.Str
                   CapDL.State.checkMappingSanity_s1) -}
87253245774e7888ed1417dd88583aad
  checkMappingSanity5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ") is neither page table nor page directory\n"#) -}
8d8e790e629eb26d9ec2217fd1991d55
  checkMappingSanity_s :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "Frame references mapping to object other than a frame\n"#) -}
732657aff39defb932ffcfb016106ee9
  checkMappingSanity_s1 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "Frame references mapping in empty or non-existent slot\n"#) -}
5d2314cbcf3a7e0e042a5100760bd928
  checkMappingSlotSanity ::
    CapDL.Model.CapMap GHC.Types.Word
    -> GHC.Types.Word -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (slots :: CapDL.Model.CapMap GHC.Types.Word)
                   (slot :: GHC.Types.Word) ->
                 case CapDL.State.$slookup3 @ CapDL.Model.Cap slot slots of wild {
                   GHC.Base.Nothing
                   -> CapDL.State.checkMappingSlotSanity3
                        `cast`
                      (Trans
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                           (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                     <Text.PrettyPrint.HughesPJ.Doc>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Types.Bool>_N)))
                   GHC.Base.Just ds
                   -> case ds of wild1 {
                        DEFAULT
                        -> CapDL.State.checkMappingSlotSanity2
                             `cast`
                           (Trans
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                                (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                          <Text.PrettyPrint.HughesPJ.Doc>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <GHC.Types.Bool>_N)))
                        CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                        -> CapDL.State.checkMappingSlotSanity1
                             `cast`
                           (Trans
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                                (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                          <Text.PrettyPrint.HughesPJ.Doc>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <GHC.Types.Bool>_N))) } }) -}
edca2b281a1d33701a6c3baa0d5b60f1
  checkMappingSlotSanity1 ::
    (GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((GHC.Types.True,
                  (Text.PrettyPrint.Annotated.HughesPJ.Empty @ ())
                    `cast`
                  (Sym (Text.PrettyPrint.HughesPJ.N:Doc[0])))) -}
d3d6f4754202e4991ab9c36b01cafbc8
  checkMappingSlotSanity2 ::
    (GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)
  {- Strictness: m,
     Unfolding: ((GHC.Types.False, CapDL.State.checkMappingSanity1)) -}
cf71b1ab489b52869b9de57bc0a0de61
  checkMappingSlotSanity3 ::
    (GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)
  {- Strictness: m,
     Unfolding: ((GHC.Types.False, CapDL.State.checkMappingSanity3)) -}
d30860876ac21e28d53427ee6a4ea78b
  checkMappings ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,1*U(A,U,A,A,A)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckMappings w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
017e61c05543a6343aae595aff6a17ad
  checkMappings_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d8e4f14d755cf526785d6d0991ed52be
  checkModel ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U(1*U,U,1*U,A,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckModel w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
8897bc932676a4d7b0eee9a794e7fd20
  checkObj ::
    CapDL.Model.Arch
    -> CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U><L,U(A,U,A,A,A)><S,1*U(U(U,U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Model GHC.Types.Word)
                   (w2 :: (CapDL.Model.ObjID,
                           CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckObj w w1 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
26199dc419177b275c374a978268378b
  checkObj1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is not a valid object for this architecture\n"#) -}
38f050664ed65b98e3869f9f6cb1ea86
  checkObjArch ::
    CapDL.Model.Arch
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U><L,1*U><L,1*U(1*U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID) ->
                 case CapDL.State.$wcheckObjArch w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
33c784d3313305700700a202469cd0ee
  checkObj_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c15ca7456487f77e4efad03c6f75a35a
  checkObjectContainsNoMappedFrameCap ::
    (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <S(LS),1*U(1*U(1*U,A),1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (CapDL.Model.ObjID,
                          CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case w of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckObjectContainsNoMappedFrameCap
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
40f13f236d84011a30acda57f9167ed6
  checkObjectContainsNoMappedFrameCap1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "' contains frame cap with mapping\n"#) -}
44fb7692409c8de12083903d59b0d036
  checkObjectContainsNoMappedFrameCap_go10 ::
    Data.Monoid.All
    -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap
    -> Data.Monoid.All
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U> -}
33fda1ae22b5649803aa4ccb1146a406
  checkObjs ::
    CapDL.Model.Arch
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U><L,1*U(A,U,A,A,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckObjs w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
c4720311b38d99ba9b388085043d04f6
  checkObjs_go :: [GHC.Types.Bool] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
1d9ed5a05c2d4ba94f52e9e4af973bdd
  checkPD ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><L,1*U(A,1*U,A,A,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckPD w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
0b3b103e4c564bc15e7d63f183f2afc0
  checkTypAt ::
    CapDL.Model.Cap
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID
    -> GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,1*U><L,1*U(A,1*U,A,A,A)><L,1*U(1*U,1*U)><L,1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Cap)
                   (w1 :: CapDL.Model.Model GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: GHC.Types.Word) ->
                 case CapDL.State.$wcheckTypAt w w1 w2 w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
3da1c1af9108faea4763d7258e1963bf
  checkUntyped ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U(A,1*U,A,A,A)><L,U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID) ->
                 case CapDL.State.$wcheckUntyped w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
28d31e498e9ae02e1a94b52728413fd8
  checkUntypedCover ::
    CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.ObjID, [CapDL.Model.ObjID])
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,U(A,U,A,A,A)><S,1*U(1*U(1*U,1*U),1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: (CapDL.Model.ObjID, [CapDL.Model.ObjID])) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckUntypedCover
                        w
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
0f0bdefe3649f78cb9fea80dcdee05f5
  checkUntypedCovers ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U(A,U,A,A,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.State.$wcheckUntypedCovers
                        ww2
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
717f53113090fc27f4db7f7102e6b2c2
  checkUntypeds ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U(A,U,A,A,1*U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.State.$wcheckUntypeds ww2 ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
2f912e55baec61a58a29defcefbe288d
  checkValidCap ::
    CapDL.Model.Arch
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> (GHC.Types.Word, CapDL.Model.Cap)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 4,
     Strictness: <L,1*U><L,U(U,U)><L,1*U(A,1*U,A,A,A)><S,1*U(U(U),U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.Model GHC.Types.Word)
                   (w3 :: (GHC.Types.Word, CapDL.Model.Cap)) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckValidCap
                        w
                        w1
                        w2
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
4827c6f36cff3ae226b56054887401d2
  checkValidCaps ::
    CapDL.Model.Arch
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 4, Strictness: <L,U><L,1*U><L,U(U,U)><L,U(A,U,A,A,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: CapDL.Model.Arch)
                   (w1 :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w2 :: CapDL.Model.ObjID)
                   (w3 :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wcheckValidCaps
                        w
                        w1
                        w2
                        w3 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
ab20cae0584e667e0116302bd5219faf
  checkValidSlot ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID
    -> (GHC.Types.Word, CapDL.Model.Cap)
    -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,1*U><L,1*U(1*U,1*U)><S,1*U(1*U(U),1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: (GHC.Types.Word, CapDL.Model.Cap)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case CapDL.State.$wcheckValidSlot
                        w
                        w1
                        ww1
                        ww2 of ww3 { (#,#) ww4 ww5 ->
                 (ww4, ww5)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) } }) -}
a39a9533ed60265c42b75c1c11d73d4b
  checkValidSlot1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " is not valid for this object\n"#) -}
e6b2352989f94e74ea546d8a2f7abe47
  checkValidSlots ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.ObjID -> CapDL.State.Logger GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U(U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID) ->
                 case CapDL.State.$wcheckValidSlots w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Trans
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Bool, Text.PrettyPrint.HughesPJ.Doc)>_R))
                      (Sym (Control.Monad.Trans.Writer.Lazy.N:WriterT[0]
                                <Text.PrettyPrint.HughesPJ.Doc>_N
                                <Data.Functor.Identity.Identity>_R
                                <GHC.Types.Bool>_N))) }) -}
28694ebc2395b82c58fdd886eb23fd21
  cspace ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.CapMap [GHC.Types.Word]
  {- Arity: 2, Strictness: <S,U(U,U)><S(LSLLL),U(U,U,U,U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 CapDL.State.$wcspace ww1 ww2 ww4 ww5 ww6 ww7 ww8 } }) -}
a10f809ff59482c30f5ac6945abf220e
  cspaceCap ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word -> CapDL.Model.Cap
  {- Arity: 2, Strictness: <S,U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 CapDL.State.$wcspaceCap ww1 ww2 ww5 } }) -}
8827852d0d0c98209b9b59d2f66d3d88
  findDuplicates :: GHC.Classes.Ord a => [a] -> [a]
  {- Arity: 2, Strictness: <L,U(1*U,C(C1(U)),A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a ($dOrd :: GHC.Classes.Ord a) (eta :: [a]) ->
                 case eta of wild {
                   [] -> GHC.Types.[] @ a
                   : ipv ipv1
                   -> case Data.OldList.sortBy
                             @ a
                             (GHC.Classes.compare @ a $dOrd)
                             wild of wild1 {
                        [] -> case GHC.List.scanl2 ret_ty [a] of {}
                        : ds1 xs
                        -> let {
                             $dEq :: GHC.Classes.Eq a = GHC.Classes.$p1Ord @ a $dOrd
                           } in
                           letrec {
                             $wgo5 :: [a]
                                      -> a -> Data.Set.Base.Set a -> (# a, Data.Set.Base.Set a #)
                               {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
                             = \ (w :: [a]) (ww :: a) (ww1 :: Data.Set.Base.Set a) ->
                               case w of wild2 {
                                 [] -> (# ww, ww1 #)
                                 : y ys
                                 -> case GHC.Classes.== @ a $dEq y ww of wild3 {
                                      GHC.Types.False -> $wgo5 ys y ww1
                                      GHC.Types.True
                                      -> $wgo5 ys y (Data.Set.Base.insert @ a $dOrd y ww1) } }
                           } in
                           case $wgo5 xs ds1 (Data.Set.Base.Tip @ a) of ww { (#,#) ww1 ww2 ->
                           Data.Set.Base.toAscList @ a ww2 } } }) -}
349f14caf3c0bd975132e21ef2c700fc
  findSlotCaps ::
    (CapDL.Model.Cap -> GHC.Types.Bool)
    -> CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: CapDL.Model.Cap -> GHC.Types.Bool)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 GHC.Base.build
                   @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                   (\ @ b
                      (c :: (CapDL.Model.CapRef, CapDL.Model.Cap) -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                      @ b
                      (GHC.List.filterFB
                         @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                         @ b
                         c
                         (\ (p1 :: (CapDL.Model.CapRef, CapDL.Model.Cap)) ->
                          p (case p1 of wild { (,) ds y -> y })))
                      n
                      (CapDL.State.allSlots eta))) -}
1a8035e867c6aeab9b77a8df194b1557
  findSlotCapsWithRef ::
    (CapDL.Model.CapRef -> CapDL.Model.Cap -> GHC.Types.Bool)
    -> CapDL.Model.Model GHC.Types.Word
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(C1(U))><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (p :: CapDL.Model.CapRef -> CapDL.Model.Cap -> GHC.Types.Bool)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 GHC.Base.build
                   @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                   (\ @ b
                      (c :: (CapDL.Model.CapRef, CapDL.Model.Cap) -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                      @ b
                      (GHC.List.filterFB
                         @ (CapDL.Model.CapRef, CapDL.Model.Cap)
                         @ b
                         c
                         (Data.Tuple.uncurry
                            @ CapDL.Model.CapRef
                            @ CapDL.Model.Cap
                            @ GHC.Types.Bool
                            p))
                      n
                      (CapDL.State.allSlots eta))) -}
7e2d2e3f63ed818b24ec698478244062
  findSlots ::
    (CapDL.Model.Cap -> GHC.Types.Bool)
    -> CapDL.Model.Model GHC.Types.Word -> [CapDL.Model.CapRef]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,C(U)><S(LSLLL),1*U(A,1*U,A,A,A)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Cap -> GHC.Types.Bool)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wfindSlots w ww2 }) -}
1fc420a323b6abbe1f2c3c9d7f947feb
  flatten ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.Model [GHC.Types.Word]
  {- Arity: 1, Strictness: <S,1*U(U,U,U,U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case CapDL.State.$wflatten
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5 of ww6 { (#,,,,#) ww7 ww8 ww9 ww10 ww11 ->
                 CapDL.Model.Model @ [GHC.Types.Word] ww7 ww8 ww9 ww10 ww11 } }) -}
39b3f977995b1949e713452a75f14c2b
  flatten' ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjMap [GHC.Types.Word]
    -> (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.ObjMap [GHC.Types.Word]
  {- Arity: 3,
     Strictness: <L,U(U,U,U,U,U)><S,1*U><S(SS),1*U(1*U(U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjMap [GHC.Types.Word])
                   (w2 :: (CapDL.Model.ObjID,
                           CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 CapDL.State.$wflatten' w w1 ww4 ww5 ww2 } }) -}
07e061c5218999b1ecba45fe1048a58d
  flattenCNodeSlots ::
    [(CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)]
    -> [CapDL.Model.Cap]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
22fcae470bd5d22e5232dd88c946358e
  flattenCnode ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.ObjID, CapDL.Model.KernelObject [GHC.Types.Word])
  {- Arity: 2, Strictness: <L,1*U><L,U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.KernelObject GHC.Types.Word)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.$wflattenCnode w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
d311ecd9b116384ab7bc9c94da53f066
  flattenIOPT ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.KernelObject [GHC.Types.Word]
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (m :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: CapDL.Model.CapMap [GHC.Types.Word]
                   = let {
                       newSlots :: CapDL.Model.CapMap [GHC.Types.Word]
                       = CapDL.State.$sfromList
                           @ CapDL.Model.Cap
                           (CapDL.State.allLevels_$sallLevels
                              m
                              CapDL.State.ioptSlots
                              4#
                              (Data.Map.Base.toAscList1
                                 @ [GHC.Types.Word]
                                 @ CapDL.Model.Cap
                                 (GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap))
                                 (CapDL.State.$smapKeys
                                    @ GHC.Types.Word
                                    @ CapDL.Model.Cap
                                    (CapDL.State.singleton @ GHC.Types.Word)
                                    (CapDL.Model.slots @ GHC.Types.Word obj))))
                     } in
                     CapDL.State.flattenIOPT_go10
                       (GHC.Base.id
                          @ (Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap))
                       newSlots
                       newSlots
                 } in
                 case obj of wild {
                   DEFAULT -> CapDL.State.flattenIOPT1
                   CapDL.Model.TCB ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.TCB @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5
                   CapDL.Model.CNode ds1 ds2
                   -> CapDL.Model.CNode @ [GHC.Types.Word] ds ds2
                   CapDL.Model.ASIDPool ds1
                   -> CapDL.Model.ASIDPool @ [GHC.Types.Word] ds
                   CapDL.Model.PT ds1 -> CapDL.Model.PT @ [GHC.Types.Word] ds
                   CapDL.Model.PD ds1 -> CapDL.Model.PD @ [GHC.Types.Word] ds
                   CapDL.Model.PDPT ds1 -> CapDL.Model.PDPT @ [GHC.Types.Word] ds
                   CapDL.Model.PML4 ds1 -> CapDL.Model.PML4 @ [GHC.Types.Word] ds
                   CapDL.Model.PUD ds1 -> CapDL.Model.PUD @ [GHC.Types.Word] ds
                   CapDL.Model.PGD ds1 -> CapDL.Model.PGD @ [GHC.Types.Word] ds
                   CapDL.Model.ARMIODevice ds1 ds2
                   -> CapDL.Model.ARMIODevice @ [GHC.Types.Word] ds ds2
                   CapDL.Model.IODevice ds1 ds2 ds3
                   -> CapDL.Model.IODevice @ [GHC.Types.Word] ds ds2 ds3
                   CapDL.Model.IOPT ds1 ds2
                   -> CapDL.Model.IOPT @ [GHC.Types.Word] ds ds2
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.IOAPICIrq @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.MSIIrq @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5 }) -}
241ce7f2cb159dfac651bffc5dd5149e
  flattenIOPT1 :: CapDL.Model.KernelObject [GHC.Types.Word]
  {- Strictness: x -}
942b4a30f12e24915f7c237352f76e0b
  flattenIOPT_go10 ::
    (Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
     -> Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap)
    -> Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
    -> Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
    -> Data.Map.Base.Map [GHC.Types.Word] CapDL.Model.Cap
  {- Arity: 3, Strictness: <C(S),1*C1(U)><S,1*U><L,U> -}
cb04f76dbd0112a78407ca512a64e262
  flattenPD ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.KernelObject [GHC.Types.Word]
  {- Arity: 2, Strictness: <S,U><L,U>,
     Unfolding: (\ (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (m :: CapDL.Model.Model GHC.Types.Word) ->
                 let {
                   ds :: CapDL.Model.CapMap [GHC.Types.Word]
                   = case CapDL.State.$sfromList
                            @ CapDL.Model.Cap
                            (CapDL.State.allLevels_$sallLevels
                               m
                               CapDL.State.pdSlots
                               4#
                               (Data.Map.Base.toAscList1
                                  @ [GHC.Types.Word]
                                  @ CapDL.Model.Cap
                                  (GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap))
                                  (CapDL.State.$smapKeys
                                     @ GHC.Types.Word
                                     @ CapDL.Model.Cap
                                     (CapDL.State.singleton @ GHC.Types.Word)
                                     (CapDL.Model.slots @ GHC.Types.Word obj)))) of wild {
                       Data.Map.Base.Bin ipv ipv1 ipv2 ipv3 ipv4
                       -> case CapDL.State.$smapKeys
                                 @ GHC.Types.Word
                                 @ CapDL.Model.Cap
                                 (CapDL.State.singleton @ GHC.Types.Word)
                                 (CapDL.Model.slots @ GHC.Types.Word obj) of wild1 {
                            Data.Map.Base.Bin ipv5 ipv6 ipv7 ipv8 ipv9
                            -> Data.Map.Base.difference_$shedgeDiff
                                 @ CapDL.Model.Cap
                                 @ CapDL.Model.Cap
                                 @ [GHC.Types.Word]
                                 ipv5
                                 ipv6
                                 ipv7
                                 ipv8
                                 ipv9
                                 ipv
                                 ipv1
                                 ipv2
                                 ipv3
                                 ipv4
                                 (Data.Map.Base.NothingS @ [GHC.Types.Word])
                                 (Data.Map.Base.NothingS @ [GHC.Types.Word])
                                 CapDL.State.$s$fOrd[]
                            Data.Map.Base.Tip -> wild }
                       Data.Map.Base.Tip
                       -> Data.Map.Base.Tip @ [GHC.Types.Word] @ CapDL.Model.Cap }
                 } in
                 case obj of wild {
                   DEFAULT -> CapDL.State.flattenPD1
                   CapDL.Model.TCB ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.TCB @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5
                   CapDL.Model.CNode ds1 ds2
                   -> CapDL.Model.CNode @ [GHC.Types.Word] ds ds2
                   CapDL.Model.ASIDPool ds1
                   -> CapDL.Model.ASIDPool @ [GHC.Types.Word] ds
                   CapDL.Model.PT ds1 -> CapDL.Model.PT @ [GHC.Types.Word] ds
                   CapDL.Model.PD ds1 -> CapDL.Model.PD @ [GHC.Types.Word] ds
                   CapDL.Model.PDPT ds1 -> CapDL.Model.PDPT @ [GHC.Types.Word] ds
                   CapDL.Model.PML4 ds1 -> CapDL.Model.PML4 @ [GHC.Types.Word] ds
                   CapDL.Model.PUD ds1 -> CapDL.Model.PUD @ [GHC.Types.Word] ds
                   CapDL.Model.PGD ds1 -> CapDL.Model.PGD @ [GHC.Types.Word] ds
                   CapDL.Model.ARMIODevice ds1 ds2
                   -> CapDL.Model.ARMIODevice @ [GHC.Types.Word] ds ds2
                   CapDL.Model.IODevice ds1 ds2 ds3
                   -> CapDL.Model.IODevice @ [GHC.Types.Word] ds ds2 ds3
                   CapDL.Model.IOPT ds1 ds2
                   -> CapDL.Model.IOPT @ [GHC.Types.Word] ds ds2
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.IOAPICIrq @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.MSIIrq @ [GHC.Types.Word] ds ds2 ds3 ds4 ds5 }) -}
8ce58b71b6466b9a03abdd7e602531d9
  flattenPD1 :: CapDL.Model.KernelObject [GHC.Types.Word]
  {- Strictness: x -}
b88fc09beffdb1e713ffdb45b3ad12a9
  getCovered ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word -> CapDL.Model.ObjSet
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LLLLS),1*U(A,A,A,A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ut_ref :: CapDL.Model.ObjID)
                   (ds :: CapDL.Model.Model GHC.Types.Word) ->
                 case ds of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 covers ->
                 case CapDL.State.$slookup1
                        @ (Data.Set.Base.Set CapDL.Model.ObjID)
                        ut_ref
                        covers of wild1 {
                   GHC.Base.Nothing -> Data.Set.Base.Tip @ CapDL.Model.ObjID
                   GHC.Base.Just cov -> cov } }) -}
c55bfcf0ff5a08f0aabbc188ba91b12e
  getSlots ::
    CapDL.Model.ObjID
    -> CapDL.State.Kernel (CapDL.Model.CapMap GHC.Types.Word)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U,U)><L,U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.getSlots1
                  `cast`
                (<CapDL.Model.ObjID>_R
                 ->_R Trans
                          (<CapDL.Model.Model GHC.Types.Word>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(CapDL.Model.CapMap GHC.Types.Word,
                                           CapDL.Model.Model GHC.Types.Word)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CapDL.Model.Model GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <CapDL.Model.CapMap GHC.Types.Word>_N))) -}
989ffe7e2e68e1c0be24f8114e86c215
  getSlots1 ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> (CapDL.Model.CapMap GHC.Types.Word,
        CapDL.Model.Model GHC.Types.Word)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(U,U)><L,U(U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 (CapDL.State.slotsOf ref eta, eta)) -}
1e802cfec191b4be3ff8a4c50c8e4c6a
  getSlotsFromKernelObject ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> GHC.Base.Maybe (CapDL.Model.CapMap GHC.Types.Word)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Base.Nothing @ (CapDL.Model.CapMap GHC.Types.Word)
                   CapDL.Model.TCB slots ds1 ds2 ds3 ds4
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.CNode slots ds1
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.ASIDPool slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PT slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PD slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PDPT slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PML4 slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PUD slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.PGD slots
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.ARMIODevice slots ds1
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.IODevice slots ds1 ds2
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots
                   CapDL.Model.IOPT slots ds1
                   -> GHC.Base.Just @ (CapDL.Model.CapMap GHC.Types.Word) slots }) -}
23ce4f0244d1aa77215a2a796977a3c2
  hasTarget :: CapDL.Model.ObjID -> CapDL.Model.Cap -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U,1*U)><S,1*U> -}
046f97bb9f54134c547c4294760a7f37
  ioptSlots :: CapDL.State.SlotsLookup
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (m :: CapDL.Model.Model GHC.Types.Word) ->
                 case m of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing
                   -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   GHC.Base.Just ds
                   -> case ds of wild2 {
                        DEFAULT -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                        CapDL.Model.IOPT slots ds7 -> slots } } }) -}
0ce0e941940e825136f8d43cf67df51f
  isASID :: CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.ASIDPool ds1 -> GHC.Types.True }) -}
fc0dcf264686424c790ffc719dd51b6a
  isCNode ::
    CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.CNode ds1 ds2 -> GHC.Types.True }) -}
de1d316414abb91e9754c7aaf3f710b6
  isFrame :: CapDL.Model.Cap -> GHC.Base.Maybe CapDL.Model.Cap
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (cap :: CapDL.Model.Cap) ->
                 case cap of wild {
                   DEFAULT -> GHC.Base.Nothing @ CapDL.Model.Cap
                   CapDL.Model.FrameCap ds ds1 ds2 ds3 ds4
                   -> GHC.Base.Just @ CapDL.Model.Cap wild }) -}
1baf740523197b2d14ef6212e7380e43
  isIRQ :: CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.CNode ds1 ds2
                   -> case ds2 of wild1 { GHC.Types.W# ds3 ->
                      case ds3 of ds4 {
                        DEFAULT -> GHC.Types.False 0## -> GHC.Types.True } }
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5 -> GHC.Types.True
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5 -> GHC.Types.True }) -}
c994d5fb7d52ecaeb3420a8a39e69355
  isMapped ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S,U>,
     Unfolding: (\ (id :: CapDL.Model.ObjID)
                   (obj :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     letrec {
                       go1 :: Data.Monoid.Any
                              -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap
                              -> Data.Monoid.Any
                         {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
                       = \ (z' :: Data.Monoid.Any)
                           (ds :: Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap) ->
                         case ds of wild {
                           Data.Map.Base.Bin dt kx x l r
                           -> go1
                                (case CapDL.State.sameID id x of wild1 {
                                   GHC.Types.False -> go1 z' r
                                   GHC.Types.True
                                   -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) })
                                l
                           Data.Map.Base.Tip -> z' }
                     } in
                     (go1
                        GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                        (CapDL.Model.slots @ GHC.Types.Word obj))
                       `cast`
                     (Data.Monoid.N:Any[0])
                 } in
                 case obj of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.TCB ds1 ds2 ds3 ds4 ds5 -> $j GHC.Prim.void#
                   CapDL.Model.CNode ds1 ds2 -> $j GHC.Prim.void#
                   CapDL.Model.ASIDPool ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PT ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PD ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PDPT ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PML4 ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PUD ds1 -> $j GHC.Prim.void#
                   CapDL.Model.PGD ds1 -> $j GHC.Prim.void#
                   CapDL.Model.ARMIODevice ds1 ds2 -> $j GHC.Prim.void#
                   CapDL.Model.IODevice ds1 ds2 ds3 -> $j GHC.Prim.void#
                   CapDL.Model.IOPT ds1 ds2 -> $j GHC.Prim.void#
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5 -> $j GHC.Prim.void#
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5 -> $j GHC.Prim.void# }) -}
38385b974fac8413776b67173fa0009b
  isMappedFrameCap :: CapDL.Model.Cap -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.Cap) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5
                   -> case ds5 of wild1 {
                        GHC.Base.Nothing -> GHC.Types.False
                        GHC.Base.Just ds6 -> GHC.Types.True } }) -}
41993d977ae4b177bbaf25c7b3ad9873
  isObject ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 case eta of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing -> GHC.Types.False
                   GHC.Base.Just ipv -> GHC.Types.True } }) -}
cc5de43ad7efd97d9c645cff7a58c866
  isPD :: CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   CapDL.Model.PD ds1 -> GHC.Types.True }) -}
14feff8f092ee5f3b26db6e59a106af1
  koType ::
    CapDL.Model.KernelObject GHC.Types.Word -> CapDL.Model.KOType
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds of wild {
                   CapDL.Model.Endpoint -> CapDL.Model.Endpoint_T
                   CapDL.Model.Notification -> CapDL.Model.Notification_T
                   CapDL.Model.TCB ds1 ds2 ds3 ds4 ds5 -> CapDL.Model.TCB_T
                   CapDL.Model.CNode ds1 ds2 -> CapDL.Model.CNode_T
                   CapDL.Model.Untyped ds1 ds2 -> CapDL.Model.Untyped_T
                   CapDL.Model.SC ds1 ds2 -> CapDL.Model.SC_T
                   CapDL.Model.RTReply -> CapDL.Model.RTReply_T
                   CapDL.Model.ASIDPool ds1 -> CapDL.Model.ASIDPool_T
                   CapDL.Model.PT ds1 -> CapDL.Model.PT_T
                   CapDL.Model.PD ds1 -> CapDL.Model.PD_T
                   CapDL.Model.PDPT ds1 -> CapDL.Model.PDPT_T
                   CapDL.Model.PML4 ds1 -> CapDL.Model.PML4_T
                   CapDL.Model.PUD ds1 -> CapDL.Model.PUD_T
                   CapDL.Model.PGD ds1 -> CapDL.Model.PGD_T
                   CapDL.Model.Frame ds1 ds2 ds3 -> CapDL.Model.Frame_T
                   CapDL.Model.ARMIODevice ds1 ds2 -> CapDL.Model.ARMIODevice_T
                   CapDL.Model.IOPorts ds1 -> CapDL.Model.IOPorts_T
                   CapDL.Model.IODevice ds1 ds2 ds3 -> CapDL.Model.IODevice_T
                   CapDL.Model.IOPT ds1 ds2 -> CapDL.Model.IOPT_T
                   CapDL.Model.VCPU -> CapDL.Model.VCPU_T
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.IOAPICIrqSlot_T
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5
                   -> CapDL.Model.MSIIrqSlot_T }) -}
a22f97969b0d99ee37e99f0d9a87a5ab
  lookupOf ::
    CapDL.Model.Cap
    -> CapDL.State.SlotsLookup
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.CapMap GHC.Types.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: (\ (cap :: CapDL.Model.Cap)
                   (lookup :: CapDL.State.SlotsLookup) ->
                 case cap of wild {
                   DEFAULT
                   -> lookup
                        (case wild of wild1 {
                           CapDL.Model.UntypedCap ds1 -> ds1
                           CapDL.Model.EndpointCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.NotificationCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.ReplyCap ds1 -> ds1
                           CapDL.Model.MasterReplyCap ds1 -> ds1
                           CapDL.Model.CNodeCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.TCBCap ds1 -> ds1
                           CapDL.Model.IRQHandlerCap ds1 -> ds1
                           CapDL.Model.IRQIOAPICHandlerCap ds1 -> ds1
                           CapDL.Model.IRQMSIHandlerCap ds1 -> ds1
                           CapDL.Model.SCCap ds1 -> ds1
                           CapDL.Model.RTReplyCap ds1 -> ds1
                           CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5 -> ds1
                           CapDL.Model.PTCap ds1 ds2 -> ds1
                           CapDL.Model.PDCap ds1 ds2 -> ds1
                           CapDL.Model.PDPTCap ds1 ds2 -> ds1
                           CapDL.Model.PML4Cap ds1 ds2 -> ds1
                           CapDL.Model.PUDCap ds1 ds2 -> ds1
                           CapDL.Model.PGDCap ds1 ds2 -> ds1
                           CapDL.Model.ASIDPoolCap ds1 ds2 -> ds1
                           CapDL.Model.ARMIOSpaceCap ds1 -> ds1
                           CapDL.Model.IOPortsCap ds1 -> ds1
                           CapDL.Model.IOSpaceCap ds1 -> ds1
                           CapDL.Model.IOPTCap ds1 -> ds1
                           CapDL.Model.VCPUCap ds1 -> ds1 })
                   CapDL.Model.NullCap -> CapDL.State.lookupOf1
                   CapDL.Model.IRQControlCap -> CapDL.State.lookupOf1
                   CapDL.Model.DomainCap -> CapDL.State.lookupOf1
                   CapDL.Model.SchedControlCap ds1 -> CapDL.State.lookupOf1
                   CapDL.Model.ASIDControlCap -> CapDL.State.lookupOf1
                   CapDL.Model.IOSpaceMasterCap -> CapDL.State.lookupOf1 }) -}
46fb16d679bd4b7654b7e055b6d78422
  lookupOf1 ::
    CapDL.Model.Model GHC.Types.Word
    -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: CapDL.Model.Model GHC.Types.Word) ->
                 Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap) -}
5e092ed7d7b97d0ef64880e6022c7bb5
  mapKeys :: (a -> b) -> [(a, c)] -> [(b, c)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ c (f :: a -> b) (eta :: [(a, c)]) ->
                 GHC.Base.build
                   @ (b, c)
                   (\ @ b1 (c1 :: (b, c) -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (a, c)
                      @ b1
                      (GHC.Base.mapFB
                         @ (b, c)
                         @ b1
                         @ (a, c)
                         c1
                         (\ (ds :: (a, c)) -> case ds of wild { (,) a1 b2 -> (f a1, b2) }))
                      n
                      eta)) -}
ad6afd5fbf1aa0441536261dbd85a21c
  mapVals :: (b -> c) -> [(a, b)] -> [(a, c)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(U)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b @ c @ a (f :: b -> c) (eta :: [(a, b)]) ->
                 GHC.Base.build
                   @ (a, c)
                   (\ @ b1 (c1 :: (a, c) -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (a, b)
                      @ b1
                      (GHC.Base.mapFB
                         @ (a, c)
                         @ b1
                         @ (a, b)
                         c1
                         (\ (ds :: (a, b)) -> case ds of wild { (,) a1 b2 -> (a1, f b2) }))
                      n
                      eta)) -}
9f3e89c2a7316e5815be0ac9fb7eda8d
  mapWithKey :: (a -> b -> c) -> [(a, b)] -> [c]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b @ c (f :: a -> b -> c) (eta :: [(a, b)]) ->
                 GHC.Base.build
                   @ c
                   (\ @ b1 (c1 :: c -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ (a, b)
                      @ b1
                      (GHC.Base.mapFB
                         @ c
                         @ b1
                         @ (a, b)
                         c1
                         (\ (ds :: (a, b)) -> case ds of wild { (,) a1 b2 -> f a1 b2 }))
                      n
                      eta)) -}
6a9572cb3e3ff639cf8380a2ede36dff
  maxDepth :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4#) -}
a9febc39f7aec601e46fae265869dcb1
  maybeObjID :: CapDL.Model.Cap -> GHC.Base.Maybe CapDL.Model.ObjID
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (cap :: CapDL.Model.Cap) ->
                 case cap of wild {
                   DEFAULT
                   -> GHC.Base.Just
                        @ CapDL.Model.ObjID
                        (case wild of wild1 {
                           CapDL.Model.UntypedCap ds1 -> ds1
                           CapDL.Model.EndpointCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.NotificationCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.ReplyCap ds1 -> ds1
                           CapDL.Model.MasterReplyCap ds1 -> ds1
                           CapDL.Model.CNodeCap ds1 ds2 ds3 -> ds1
                           CapDL.Model.TCBCap ds1 -> ds1
                           CapDL.Model.IRQHandlerCap ds1 -> ds1
                           CapDL.Model.IRQIOAPICHandlerCap ds1 -> ds1
                           CapDL.Model.IRQMSIHandlerCap ds1 -> ds1
                           CapDL.Model.SCCap ds1 -> ds1
                           CapDL.Model.RTReplyCap ds1 -> ds1
                           CapDL.Model.FrameCap ds1 ds2 ds3 ds4 ds5 -> ds1
                           CapDL.Model.PTCap ds1 ds2 -> ds1
                           CapDL.Model.PDCap ds1 ds2 -> ds1
                           CapDL.Model.PDPTCap ds1 ds2 -> ds1
                           CapDL.Model.PML4Cap ds1 ds2 -> ds1
                           CapDL.Model.PUDCap ds1 ds2 -> ds1
                           CapDL.Model.PGDCap ds1 ds2 -> ds1
                           CapDL.Model.ASIDPoolCap ds1 ds2 -> ds1
                           CapDL.Model.ARMIOSpaceCap ds1 -> ds1
                           CapDL.Model.IOPortsCap ds1 -> ds1
                           CapDL.Model.IOSpaceCap ds1 -> ds1
                           CapDL.Model.IOPTCap ds1 -> ds1
                           CapDL.Model.VCPUCap ds1 -> ds1 })
                   CapDL.Model.NullCap -> GHC.Base.Nothing @ CapDL.Model.ObjID
                   CapDL.Model.IRQControlCap -> GHC.Base.Nothing @ CapDL.Model.ObjID
                   CapDL.Model.DomainCap -> GHC.Base.Nothing @ CapDL.Model.ObjID
                   CapDL.Model.SchedControlCap ds1
                   -> GHC.Base.Nothing @ CapDL.Model.ObjID
                   CapDL.Model.ASIDControlCap -> GHC.Base.Nothing @ CapDL.Model.ObjID
                   CapDL.Model.IOSpaceMasterCap
                   -> GHC.Base.Nothing @ CapDL.Model.ObjID }) -}
df418c223c0ac031b9f0f98beb81c618
  maybeObject ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Base.Maybe (CapDL.Model.KernelObject GHC.Types.Word)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 case eta of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 CapDL.State.$slookup1
                   @ (CapDL.Model.KernelObject GHC.Types.Word)
                   ref
                   ds2 }) -}
fd5f7bd0d6fbfb6bea5598fb1f6bb54e
  maybeSlotCap ::
    CapDL.Model.CapRef
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Base.Maybe CapDL.Model.Cap
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SS),1*U(1*U(U,U),1*U(U))><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.CapRef)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case ww2 of ww6 { GHC.Types.W# ww7 ->
                 case w1 of ww8 { CapDL.Model.Model ww9 ww10 ww11 ww12 ww13 ->
                 CapDL.State.$wmaybeSlotCap ww4 ww5 ww7 ww10 } } } }) -}
9b4f2f6d7776c9a14682b36095a0b565
  modifyObject ::
    CapDL.Model.ObjID
    -> (CapDL.Model.KernelObject GHC.Types.Word
        -> CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.State.Kernel ()
  {- Arity: 3, Strictness: <L,U(U,U)><L,1*C1(U)><L,1*U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.modifyObject1
                  `cast`
                (<CapDL.Model.ObjID>_R
                 ->_R <CapDL.Model.KernelObject GHC.Types.Word
                       -> CapDL.Model.KernelObject GHC.Types.Word>_R
                 ->_R Trans
                          (<CapDL.Model.Model GHC.Types.Word>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CapDL.Model.Model GHC.Types.Word)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CapDL.Model.Model GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_N))) -}
672117fb40304fec38aad477d595d760
  modifyObject1 ::
    CapDL.Model.ObjID
    -> (CapDL.Model.KernelObject GHC.Types.Word
        -> CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.Model GHC.Types.Word
    -> ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 3, Strictness: <L,U(U,U)><L,1*C1(U)><L,1*U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.KernelObject GHC.Types.Word
                          -> CapDL.Model.KernelObject GHC.Types.Word)
                   (w2 :: CapDL.Model.Model GHC.Types.Word) ->
                 (GHC.Tuple.(),
                  case w2 of wild { CapDL.Model.Model ds ds1 ds2 ds3 ds4 ->
                  CapDL.Model.Model
                    @ GHC.Types.Word
                    ds
                    (case w of ww { (,) ww1 ww2 ->
                     CapDL.State.$w$sgo1
                       @ (CapDL.Model.KernelObject GHC.Types.Word)
                       ww1
                       ww2
                       (w1
                          (case CapDL.State.$wpoly_go10
                                  @ (CapDL.Model.KernelObject GHC.Types.Word)
                                  ww1
                                  ww2
                                  ds1 of wild1 {
                             GHC.Base.Nothing -> CapDL.State.checkCovers4 ww2 ww1
                             GHC.Base.Just obj -> obj }))
                       ds1 })
                    ds2
                    ds3
                    ds4 })) -}
3439156a87b186e755dbb00691222089
  nextLevel ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.CapLookup
    -> CapDL.State.SlotsLookup
    -> CapDL.State.CapLookup
  {- Arity: 3, Strictness: <L,U><S,1*U><L,C(C1(U))>,
     Unfolding: (\ (m :: CapDL.Model.Model GHC.Types.Word)
                   (cl :: CapDL.State.CapLookup)
                   (lookup :: CapDL.State.SlotsLookup) ->
                 letrec {
                   go1 :: [([GHC.Types.Word], CapDL.Model.Cap)]
                          -> [([GHC.Types.Word], CapDL.Model.Cap)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [([GHC.Types.Word], CapDL.Model.Cap)]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ ([GHC.Types.Word], CapDL.Model.Cap)
                       : y ys
                       -> case y of wild1 { (,) a b ->
                          GHC.Base.++
                            @ ([GHC.Types.Word], CapDL.Model.Cap)
                            (CapDL.State.nextLookup m lookup a b)
                            (go1 ys) } }
                 } in
                 go1 cl) -}
0aad72957b69067122ae03d2ac6f8e4e
  nextLookup ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.State.SlotsLookup
    -> [GHC.Types.Word]
    -> CapDL.Model.Cap
    -> CapDL.State.CapLookup
  {- Arity: 4, Strictness: <L,U><L,1*C1(C1(U))><L,U><S,1*U> -}
14f53d4778b1b6b42a1c3b58d605450b
  nullIntersections ::
    GHC.Classes.Ord a => [Data.Set.Base.Set a] -> GHC.Types.Bool
  {- Arity: 2,
     Strictness: <L,U(A,C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dOrd :: GHC.Classes.Ord a)
                   (ds :: [Data.Set.Base.Set a]) ->
                 case ds of wild {
                   [] -> GHC.Types.True
                   : ds1 ds2
                   -> case ds2 of wild1 {
                        [] -> GHC.Types.True
                        : ipv ipv1
                        -> case ds1 of wild2 {
                             Data.Set.Base.Bin ipv2 ipv3 ipv4 ipv5
                             -> case Data.Set.Base.unions @ a $dOrd wild1 of wild3 {
                                  Data.Set.Base.Bin ipv6 ipv7 ipv8 ipv9
                                  -> case Data.Set.Base.intersection_$shedgeInt
                                            @ a
                                            ipv6
                                            ipv7
                                            ipv8
                                            ipv9
                                            ipv2
                                            ipv3
                                            ipv4
                                            ipv5
                                            (Data.Set.Base.NothingS @ a)
                                            (Data.Set.Base.NothingS @ a)
                                            $dOrd of wild4 {
                                       Data.Set.Base.Bin dt ds3 ds4 ds5 -> GHC.Types.False
                                       Data.Set.Base.Tip
                                       -> CapDL.State.nullIntersections_$snullIntersections
                                            @ a
                                            ipv
                                            ipv1
                                            $dOrd }
                                  Data.Set.Base.Tip
                                  -> CapDL.State.nullIntersections_$snullIntersections
                                       @ a
                                       ipv
                                       ipv1
                                       $dOrd }
                             Data.Set.Base.Tip
                             -> CapDL.State.nullIntersections_$snullIntersections
                                  @ a
                                  ipv
                                  ipv1
                                  $dOrd } } }) -}
e218d1e19d6399c2a6a8c5d6094feee1
  nullIntersections_$snullIntersections ::
    Data.Set.Base.Set a
    -> [Data.Set.Base.Set a] -> GHC.Classes.Ord a => GHC.Types.Bool
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(A,C(C1(U)),A,C(C1(U)),A,C(C1(U)),A,A)> -}
855f1587366d524b0913b4526780e864
  objAt ::
    (CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool)
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*C1(U)><S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (3, True, False)
                (\ (p :: CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool)
                   (ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 case eta of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing -> GHC.Types.False GHC.Base.Just x -> p x } }) -}
a97d8f5c85f09cdc2149e27321c42545
  objSlots ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.CapMap GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (obj :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case obj of wild {
                   DEFAULT -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   CapDL.Model.TCB ds1 ds2 ds3 ds4 ds5 -> ds1
                   CapDL.Model.CNode ds1 ds2 -> ds1
                   CapDL.Model.ASIDPool ds1 -> ds1
                   CapDL.Model.PT ds1 -> ds1
                   CapDL.Model.PD ds1 -> ds1
                   CapDL.Model.PDPT ds1 -> ds1
                   CapDL.Model.PML4 ds1 -> ds1
                   CapDL.Model.PUD ds1 -> ds1
                   CapDL.Model.PGD ds1 -> ds1
                   CapDL.Model.ARMIODevice ds1 ds2 -> ds1
                   CapDL.Model.IODevice ds1 ds2 ds3 -> ds1
                   CapDL.Model.IOPT ds1 ds2 -> ds1
                   CapDL.Model.IOAPICIrq ds1 ds2 ds3 ds4 ds5 -> ds1
                   CapDL.Model.MSIIrq ds1 ds2 ds3 ds4 ds5 -> ds1 }) -}
4a88867970a20b886796a7ea9b3f156b
  object ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.KernelObject GHC.Types.Word
  {- Arity: 2, Strictness: <S,U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w1 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 CapDL.State.$wobject ww1 ww2 ww5 } }) -}
0bd66328cd38f3b5182852f1bc2a2ce6
  pdSlots :: CapDL.State.SlotsLookup
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (m :: CapDL.Model.Model GHC.Types.Word) ->
                 case m of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing
                   -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   GHC.Base.Just ds
                   -> case ds of wild2 {
                        DEFAULT -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                        CapDL.Model.PT slots -> slots
                        CapDL.Model.PD slots -> slots } } }) -}
08aa8ec25ddc77fadb69d9eab403d770
  refSlots ::
    (CapDL.Model.ObjID, CapDL.Model.KernelObject GHC.Types.Word)
    -> [(CapDL.Model.CapRef, CapDL.Model.Cap)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (CapDL.Model.ObjID,
                          CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case w of ww { (,) ww1 ww2 -> CapDL.State.$wrefSlots ww1 ww2 }) -}
41089ca7ccbe65e82095c8aed3834e0c
  removeCap :: CapDL.Model.CapRef -> CapDL.State.Kernel ()
  {- Arity: 2,
     Strictness: <S(SL),1*U(U(U,U),1*U(U))><S(LSLLL),U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.removeCap1
                  `cast`
                (<(CapDL.Model.ObjID, GHC.Types.Word)>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <CapDL.Model.Model GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
e5f2e00c729810fb77d591eb51b3cbac
  removeCap1 ::
    (CapDL.Model.ObjID, GHC.Types.Word)
    -> CapDL.Model.Model GHC.Types.Word
    -> Data.Functor.Identity.Identity
         ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 2,
     Strictness: <S(SL),1*U(U(U,U),1*U(U))><S(LSLLL),U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (CapDL.Model.ObjID, GHC.Types.Word))
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case w1 of ww6 { CapDL.Model.Model ww7 ww8 ww9 ww10 ww11 ->
                 case CapDL.State.$wremoveCap
                        ww4
                        ww5
                        ww2
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11 of ww12 { (#,#) ww13 ww14 ->
                 (ww13, ww14)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), CapDL.Model.Model GHC.Types.Word)>_R)) } } } }) -}
8a3d402676769bd56f7d5928131813d9
  sameID :: CapDL.Model.ObjID -> CapDL.Model.Cap -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(1*U,1*U)><S,1*U> -}
f20304c3b2438b6f6b38737a670970d6
  setCap ::
    CapDL.Model.CapRef -> CapDL.Model.Cap -> CapDL.State.Kernel ()
  {- Arity: 3,
     Strictness: <S(SS),1*U(U(U,U),U(U))><L,U><S(LSLLL),U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.setCap1
                  `cast`
                (<(CapDL.Model.ObjID, GHC.Types.Word)>_R
                 ->_R <CapDL.Model.Cap>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <CapDL.Model.Model GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
cbbfc8d5263cdf4765d257ddab071f68
  setCap1 ::
    (CapDL.Model.ObjID, GHC.Types.Word)
    -> CapDL.Model.Cap
    -> CapDL.Model.Model GHC.Types.Word
    -> Data.Functor.Identity.Identity
         ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 3,
     Strictness: <S(SS),1*U(U(U,U),U(U))><L,U><S(LSLLL),U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: (CapDL.Model.ObjID, GHC.Types.Word))
                   (w1 :: CapDL.Model.Cap)
                   (w2 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { (,) ww4 ww5 ->
                 case ww2 of ww6 { GHC.Types.W# ww7 ->
                 case w2 of ww8 { CapDL.Model.Model ww9 ww10 ww11 ww12 ww13 ->
                 case CapDL.State.$wsetCap
                        ww4
                        ww5
                        ww7
                        w1
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13 of ww14 { (#,#) ww15 ww16 ->
                 (ww15, ww16)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), CapDL.Model.Model GHC.Types.Word)>_R)) } } } } }) -}
cfbdba2085d31a37b3f418e78df78112
  setCovered ::
    CapDL.Model.ObjID -> CapDL.Model.ObjSet -> CapDL.State.Kernel ()
  {- Arity: 3, Strictness: <L,1*U(U,U)><L,U><L,1*U(U,U,U,U,1*U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.setCovered1
                  `cast`
                (<CapDL.Model.ObjID>_R
                 ->_R <CapDL.Model.ObjSet>_R
                 ->_R Trans
                          (<CapDL.Model.Model GHC.Types.Word>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CapDL.Model.Model GHC.Types.Word)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CapDL.Model.Model GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_N))) -}
3fd193efbb620c4c1d1145aedc31b270
  setCovered1 ::
    CapDL.Model.ObjID
    -> CapDL.Model.ObjSet
    -> CapDL.Model.Model GHC.Types.Word
    -> ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 3, Strictness: <L,1*U(U,U)><L,U><L,1*U(U,U,U,U,1*U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ut_ref :: CapDL.Model.ObjID)
                   (covers :: CapDL.Model.ObjSet)
                   (s1 :: CapDL.Model.Model GHC.Types.Word) ->
                 (GHC.Tuple.(),
                  case s1 of wild { CapDL.Model.Model ds ds1 ds2 ds3 ds4 ->
                  CapDL.Model.Model
                    @ GHC.Types.Word
                    ds
                    ds1
                    ds2
                    ds3
                    (CapDL.State.$sinsert_$sgo10
                       @ (Data.Set.Base.Set CapDL.Model.ObjID)
                       ut_ref
                       covers
                       ds4) })) -}
afc6c12dcef300133d13796292b2d5e8
  setObject ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word -> CapDL.State.Kernel ()
  {- Arity: 3, Strictness: <L,1*U(U,U)><L,U><L,1*U(U,1*U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.setObject1
                  `cast`
                (<CapDL.Model.ObjID>_R
                 ->_R <CapDL.Model.KernelObject GHC.Types.Word>_R
                 ->_R Trans
                          (<CapDL.Model.Model GHC.Types.Word>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), CapDL.Model.Model GHC.Types.Word)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <CapDL.Model.Model GHC.Types.Word>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <()>_N))) -}
5f1c95eda09d26776085bfd3245647b1
  setObject1 ::
    CapDL.Model.ObjID
    -> CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 3, Strictness: <L,1*U(U,U)><L,U><L,1*U(U,1*U,U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (obj :: CapDL.Model.KernelObject GHC.Types.Word)
                   (eta1 :: CapDL.Model.Model GHC.Types.Word) ->
                 (GHC.Tuple.(),
                  case eta1 of wild { CapDL.Model.Model ds ds1 ds2 ds3 ds4 ->
                  CapDL.Model.Model
                    @ GHC.Types.Word
                    ds
                    (CapDL.State.$sinsert_$sgo10
                       @ (CapDL.Model.KernelObject GHC.Types.Word)
                       ref
                       obj
                       ds1)
                    ds2
                    ds3
                    ds4 })) -}
2138ebb39f1fa1957a469674b7ce10b4
  setSlots ::
    CapDL.Model.ObjID
    -> CapDL.Model.CapMap GHC.Types.Word -> CapDL.State.Kernel ()
  {- Arity: 3, Strictness: <S,U(U,U)><L,U><S(LSLLL),U(U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                CapDL.State.setSlots1
                  `cast`
                (<CapDL.Model.ObjID>_R
                 ->_R <CapDL.Model.CapMap GHC.Types.Word>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <CapDL.Model.Model GHC.Types.Word>_N
                               <Data.Functor.Identity.Identity>_R
                               <()>_N)) -}
100b48a223765cfed4afc0e6bfe09d1d
  setSlots1 ::
    CapDL.Model.ObjID
    -> CapDL.Model.CapMap GHC.Types.Word
    -> CapDL.Model.Model GHC.Types.Word
    -> Data.Functor.Identity.Identity
         ((), CapDL.Model.Model GHC.Types.Word)
  {- Arity: 3, Strictness: <S,U(U,U)><L,U><S(LSLLL),U(U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.CapMap GHC.Types.Word)
                   (w2 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w of ww { (,) ww1 ww2 ->
                 case w2 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 case CapDL.State.$wsetSlots
                        ww1
                        ww2
                        w1
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8 of ww9 { (#,#) ww10 ww11 ->
                 (ww10, ww11)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), CapDL.Model.Model GHC.Types.Word)>_R)) } } }) -}
9e74e9554b6840943911b5faf6f82dc5
  singleton :: a -> [a]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: a) -> GHC.Types.: @ a x (GHC.Types.[] @ a)) -}
840c0309b2cb7fc2ca25ff8cf5d58a4d
  slotCap ::
    CapDL.Model.CapRef
    -> CapDL.Model.Model GHC.Types.Word -> CapDL.Model.Cap
  {- Arity: 2,
     Strictness: <S(SS),1*U(1*U(U,U),1*U(U))><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (cref :: CapDL.Model.CapRef)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 case CapDL.State.maybeSlotCap cref eta of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ CapDL.Model.Cap
                   GHC.Base.Just x -> x }) -}
75e7936e61eb19eb3692bb9660b7790d
  slotsOf ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.CapMap GHC.Types.Word
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ref :: CapDL.Model.ObjID)
                   (eta :: CapDL.Model.Model GHC.Types.Word) ->
                 case eta of wild { CapDL.Model.Model ds1 ds2 ds3 ds4 ds5 ->
                 case CapDL.State.$slookup1
                        @ (CapDL.Model.KernelObject GHC.Types.Word)
                        ref
                        ds2 of wild1 {
                   GHC.Base.Nothing
                   -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   GHC.Base.Just x -> CapDL.State.objSlots x } }) -}
836c727d3b4be8ee6bc58ce51e30a124
  slotsOfMaybe ::
    GHC.Base.Maybe (CapDL.Model.KernelObject GHC.Types.Word)
    -> CapDL.Model.CapMap GHC.Types.Word
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds1 :: GHC.Base.Maybe
                             (CapDL.Model.KernelObject GHC.Types.Word)) ->
                 case ds1 of wild {
                   GHC.Base.Nothing
                   -> Data.Map.Base.Tip @ GHC.Types.Word @ CapDL.Model.Cap
                   GHC.Base.Just x -> CapDL.State.objSlots x }) -}
6a19fbeb7b6c64d1f358ddb858af9932
  snoc :: [a] -> a -> [a]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (xs :: [a]) (x :: a) ->
                 GHC.Base.augment
                   @ a
                   (\ @ b (c :: a -> b -> b)[OneShot] (n :: b)[OneShot] ->
                    GHC.Base.foldr @ a @ b c n xs)
                   (GHC.Types.: @ a x (GHC.Types.[] @ a))) -}
93ade5adba19a5465e89cfe59b3994ed
  typAt ::
    CapDL.Model.KOType
    -> CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word
    -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><S,1*U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: CapDL.Model.KOType)
                   (w1 :: CapDL.Model.ObjID)
                   (w2 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case w2 of ww3 { CapDL.Model.Model ww4 ww5 ww6 ww7 ww8 ->
                 CapDL.State.$wtypAt w ww1 ww2 ww5 } }) -}
fcf4e40f093609a4daef0de8bd721f41
  uniqueASID ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wuniqueASID w ww2 }) -}
4eae936bed5d0a53570aea121bf42f2a
  uniquePD ::
    CapDL.Model.ObjID
    -> CapDL.Model.Model GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,U(U,U)><S(LSLLL),1*U(A,1*U,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.ObjID)
                   (w1 :: CapDL.Model.Model GHC.Types.Word) ->
                 case w1 of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 CapDL.State.$wuniquePD w ww2 }) -}
c833e6902486ce7111088a39b7f358ea
  validCapArch ::
    CapDL.Model.Arch -> CapDL.Model.Cap -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.Arch) (ds1 :: CapDL.Model.Cap) ->
                 case ds1 of wild {
                   DEFAULT
                   -> case ds of wild1 {
                        CapDL.Model.IA32
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.IRQIOAPICHandlerCap ds2 -> GHC.Types.True
                             CapDL.Model.IRQMSIHandlerCap ds2 -> GHC.Types.True
                             CapDL.Model.IOPortsCap ds2 -> GHC.Types.True
                             CapDL.Model.IOSpaceMasterCap -> GHC.Types.True
                             CapDL.Model.IOSpaceCap ds2 -> GHC.Types.True
                             CapDL.Model.IOPTCap ds2 -> GHC.Types.True
                             CapDL.Model.VCPUCap ds2 -> GHC.Types.True }
                        CapDL.Model.ARM11
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.ARMIOSpaceCap ds2 -> GHC.Types.True }
                        CapDL.Model.X86_64
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.IRQIOAPICHandlerCap ds2 -> GHC.Types.True
                             CapDL.Model.IRQMSIHandlerCap ds2 -> GHC.Types.True
                             CapDL.Model.PDPTCap ds2 ds3 -> GHC.Types.True
                             CapDL.Model.PML4Cap ds2 ds3 -> GHC.Types.True
                             CapDL.Model.IOPortsCap ds2 -> GHC.Types.True
                             CapDL.Model.IOSpaceMasterCap -> GHC.Types.True
                             CapDL.Model.IOSpaceCap ds2 -> GHC.Types.True
                             CapDL.Model.IOPTCap ds2 -> GHC.Types.True
                             CapDL.Model.VCPUCap ds2 -> GHC.Types.True }
                        CapDL.Model.AARCH64
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.PUDCap ds2 ds3 -> GHC.Types.True
                             CapDL.Model.PGDCap ds2 ds3 -> GHC.Types.True } }
                   CapDL.Model.NullCap -> GHC.Types.True
                   CapDL.Model.UntypedCap ds2 -> GHC.Types.True
                   CapDL.Model.EndpointCap ds2 ds3 ds4 -> GHC.Types.True
                   CapDL.Model.NotificationCap ds2 ds3 ds4 -> GHC.Types.True
                   CapDL.Model.ReplyCap ds2 -> GHC.Types.True
                   CapDL.Model.MasterReplyCap ds2 -> GHC.Types.True
                   CapDL.Model.CNodeCap ds2 ds3 ds4 -> GHC.Types.True
                   CapDL.Model.TCBCap ds2 -> GHC.Types.True
                   CapDL.Model.IRQControlCap -> GHC.Types.True
                   CapDL.Model.IRQHandlerCap ds2 -> GHC.Types.True
                   CapDL.Model.DomainCap -> GHC.Types.True
                   CapDL.Model.SCCap ds2 -> GHC.Types.True
                   CapDL.Model.SchedControlCap ds2 -> GHC.Types.True
                   CapDL.Model.RTReplyCap ds2 -> GHC.Types.True
                   CapDL.Model.FrameCap ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True
                   CapDL.Model.PTCap ds2 ds3 -> GHC.Types.True
                   CapDL.Model.PDCap ds2 ds3 -> GHC.Types.True
                   CapDL.Model.ASIDControlCap -> GHC.Types.True
                   CapDL.Model.ASIDPoolCap ds2 ds3 -> GHC.Types.True }) -}
56a860dd31bf8eed0f43d8d009e2e4f4
  validIRQ ::
    CapDL.Model.Model GHC.Types.Word
    -> CapDL.Model.ObjID -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(LSLLL),1*U(A,1*U,A,A,A)><S,U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: CapDL.Model.Model GHC.Types.Word)
                   (w1 :: CapDL.Model.ObjID) ->
                 case w of ww { CapDL.Model.Model ww1 ww2 ww3 ww4 ww5 ->
                 case w1 of ww6 { (,) ww7 ww8 ->
                 CapDL.State.$wvalidIRQ ww2 ww7 ww8 } }) -}
77d9d0185601d824d6e6ed20af12a923
  validObjArch ::
    CapDL.Model.Arch
    -> CapDL.Model.KernelObject GHC.Types.Word -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.Arch)
                   (ds1 :: CapDL.Model.KernelObject GHC.Types.Word) ->
                 case ds1 of wild {
                   DEFAULT
                   -> case ds of wild1 {
                        CapDL.Model.IA32
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.IOPorts ds2 -> GHC.Types.True
                             CapDL.Model.IODevice ds2 ds3 ds4 -> GHC.Types.True
                             CapDL.Model.IOPT ds2 ds3 -> GHC.Types.True
                             CapDL.Model.VCPU -> GHC.Types.True
                             CapDL.Model.IOAPICIrq ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True
                             CapDL.Model.MSIIrq ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True }
                        CapDL.Model.ARM11
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.ARMIODevice ds2 ds3 -> GHC.Types.True }
                        CapDL.Model.X86_64
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.PDPT ds2 -> GHC.Types.True
                             CapDL.Model.PML4 ds2 -> GHC.Types.True
                             CapDL.Model.IOPorts ds2 -> GHC.Types.True
                             CapDL.Model.IODevice ds2 ds3 ds4 -> GHC.Types.True
                             CapDL.Model.IOPT ds2 ds3 -> GHC.Types.True
                             CapDL.Model.VCPU -> GHC.Types.True
                             CapDL.Model.IOAPICIrq ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True
                             CapDL.Model.MSIIrq ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True }
                        CapDL.Model.AARCH64
                        -> case wild of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.PUD ds2 -> GHC.Types.True
                             CapDL.Model.PGD ds2 -> GHC.Types.True } }
                   CapDL.Model.Endpoint -> GHC.Types.True
                   CapDL.Model.Notification -> GHC.Types.True
                   CapDL.Model.TCB ds2 ds3 ds4 ds5 ds6 -> GHC.Types.True
                   CapDL.Model.CNode ds2 ds3 -> GHC.Types.True
                   CapDL.Model.Untyped ds2 ds3 -> GHC.Types.True
                   CapDL.Model.SC ds2 ds3 -> GHC.Types.True
                   CapDL.Model.RTReply -> GHC.Types.True
                   CapDL.Model.ASIDPool ds2 -> GHC.Types.True
                   CapDL.Model.PT ds2 -> GHC.Types.True
                   CapDL.Model.PD ds2 -> GHC.Types.True
                   CapDL.Model.Frame ds2 ds3 ds4 -> GHC.Types.True }) -}
0e9d4c96dba895f31e8a639596ca7e74
  validObjCap ::
    CapDL.Model.KernelObject GHC.Types.Word
    -> CapDL.Model.Cap -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (ds :: CapDL.Model.KernelObject GHC.Types.Word)
                   (ds1 :: CapDL.Model.Cap) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.True
                   CapDL.Model.CNode ds2 ds3
                   -> case ds3 of wild1 { GHC.Types.W# ds4 ->
                      case ds4 of ds5 {
                        DEFAULT -> GHC.Types.True
                        0##
                        -> case ds1 of wild2 {
                             DEFAULT -> GHC.Types.False
                             CapDL.Model.NotificationCap ds6 ds7 ds8 -> GHC.Types.True } } }
                   CapDL.Model.ASIDPool ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.PDCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.PT ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.FrameCap ds3 ds4 ds5 ds6 ds7 -> GHC.Types.True }
                   CapDL.Model.PD ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.FrameCap ds3 ds4 ds5 ds6 ds7 -> GHC.Types.True
                        CapDL.Model.PTCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.PDPT ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.FrameCap ds3 ds4 ds5 ds6 ds7 -> GHC.Types.True
                        CapDL.Model.PDCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.PML4 ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.PDPTCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.PUD ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.FrameCap ds3 ds4 ds5 ds6 ds7 -> GHC.Types.True
                        CapDL.Model.PDCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.PGD ds2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.PUDCap ds3 ds4 -> GHC.Types.True }
                   CapDL.Model.IOPT ds2 ds3
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        CapDL.Model.FrameCap ds4 ds5 ds6 ds7 ds8 -> GHC.Types.True
                        CapDL.Model.IOPTCap ds4 -> GHC.Types.True } }) -}
"SC:$snullIntersections0" [ALWAYS] forall (sc :: Data.Set.Base.Set
                                                   ([GHC.Types.Char],
                                                    GHC.Base.Maybe GHC.Types.Word))
                                          (sc1 :: [Data.Set.Base.Set
                                                     ([GHC.Types.Char],
                                                      GHC.Base.Maybe GHC.Types.Word)])
  CapDL.State.checkCovers_$snullIntersections (GHC.Types.:
                                                 @ (Data.Set.Base.Set CapDL.Model.ObjID)
                                                 sc
                                                 sc1)
  = CapDL.State.checkCovers_$s$snullIntersections sc sc1
"SC:$w$sgo100" [0] forall @ a1
                          (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1)
                          (sc1 :: a1)
                          (sc2 :: [GHC.Types.Char])
  CapDL.State.$w$sgo1 @ a1
                      sc2
                      (GHC.Base.Nothing @ GHC.Types.Word)
                      sc1
                      sc
  = CapDL.State.$sinsert_$s$w$sgo2 @ a1 sc sc1 sc2
"SC:$w$sgo101" [0] forall @ a1
                          (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1)
                          (sc1 :: a1)
                          (sc2 :: GHC.Types.Word)
                          (sc3 :: [GHC.Types.Char])
  CapDL.State.$w$sgo1 @ a1
                      sc3
                      (GHC.Base.Just @ GHC.Types.Word sc2)
                      sc1
                      sc
  = CapDL.State.$sinsert_$s$w$sgo1 @ a1 sc sc1 sc2 sc3
"SC:$w$sgo102" [0] forall @ a1
                          (sc :: Data.Map.Base.Map
                                   ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a1)
                          (sc1 :: a1)
                          (sc2 :: GHC.Prim.Word#)
                          (sc3 :: [GHC.Types.Char])
  CapDL.State.$w$sgo1 @ a1
                      sc3
                      (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc2))
                      sc1
                      sc
  = CapDL.State.$sinsert_$s$w$sgo10 @ a1 sc sc1 sc2 sc3
"SC:$wpoly_go100" [0] forall @ a
                             (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a)
                             (sc1 :: [GHC.Types.Char])
  CapDL.State.$wpoly_go10 @ a
                          sc1
                          (GHC.Base.Nothing @ GHC.Types.Word)
                          sc
  = CapDL.State.$slookup_$s$wpoly_go2 @ a sc sc1
"SC:$wpoly_go101" [0] forall @ a
                             (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a)
                             (sc1 :: GHC.Types.Word)
                             (sc2 :: [GHC.Types.Char])
  CapDL.State.$wpoly_go10 @ a
                          sc2
                          (GHC.Base.Just @ GHC.Types.Word sc1)
                          sc
  = CapDL.State.$slookup_$s$wpoly_go1 @ a sc sc1 sc2
"SC:$wpoly_go102" [0] forall @ a
                             (sc :: Data.Map.Base.Map
                                      ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word) a)
                             (sc1 :: GHC.Prim.Word#)
                             (sc2 :: [GHC.Types.Char])
  CapDL.State.$wpoly_go10 @ a
                          sc2
                          (GHC.Base.Just @ GHC.Types.Word (GHC.Types.W# sc1))
                          sc
  = CapDL.State.$slookup_$s$wpoly_go10 @ a sc sc1 sc2
"SC:allLevels0" [ALWAYS] forall (sc :: CapDL.Model.Model
                                         GHC.Types.Word)
                                (sc1 :: ([GHC.Types.Char], GHC.Base.Maybe GHC.Types.Word)
                                        -> CapDL.Model.Model GHC.Types.Word
                                        -> Data.Map.Base.Map GHC.Types.Word CapDL.Model.Cap)
                                (sc2 :: GHC.Prim.Int#)
                                (sc3 :: [([GHC.Types.Word], CapDL.Model.Cap)])
  CapDL.State.allLevels sc3 (GHC.Types.I# sc2) sc1 sc
  = CapDL.State.allLevels_$sallLevels sc sc1 sc2 sc3
"SC:nullIntersections0" [ALWAYS] forall @ a
                                        (sc :: Data.Set.Base.Set a)
                                        (sc1 :: [Data.Set.Base.Set a])
                                        (sc2 :: GHC.Classes.Ord a)
  CapDL.State.nullIntersections @ a
                                sc2
                                (GHC.Types.: @ (Data.Set.Base.Set a) sc sc1)
  = CapDL.State.nullIntersections_$snullIntersections @ a sc sc1 sc2
"SPEC findDuplicates @ (ObjID, Word)" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                  (CapDL.Model.ObjID,
                                                                   GHC.Types.Word))
  CapDL.State.findDuplicates @ (CapDL.Model.ObjID, GHC.Types.Word)
                             $dOrd
  = CapDL.State.checkDuplicateMappedFrameCaps_$sfindDuplicates
"SPEC nullIntersections @ ObjID" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                             CapDL.Model.ObjID)
  CapDL.State.nullIntersections @ (GHC.Base.String,
                                   GHC.Base.Maybe GHC.Types.Word)
                                $dOrd
  = CapDL.State.checkCovers_$snullIntersections
"SPEC/CapDL.State $fEq(,) @ (String, Maybe Word) @ Word" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                                     GHC.Types.Word)
                                                                         ($dEq :: GHC.Classes.Eq
                                                                                    (GHC.Base.String,
                                                                                     GHC.Base.Maybe
                                                                                       GHC.Types.Word))
  GHC.Classes.$fEq(,) @ (GHC.Base.String,
                         GHC.Base.Maybe GHC.Types.Word)
                      @ GHC.Types.Word
                      $dEq
                      $dEq1
  = CapDL.State.$s$fEq(,)1
"SPEC/CapDL.State $fEq(,) @ [Char] @ (Maybe Word)" [ALWAYS] forall ($dEq1 :: GHC.Classes.Eq
                                                                               (GHC.Base.Maybe
                                                                                  GHC.Types.Word))
                                                                   ($dEq :: GHC.Classes.Eq
                                                                              [GHC.Types.Char])
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ (GHC.Base.Maybe GHC.Types.Word)
                      $dEq
                      $dEq1
  = CapDL.State.$s$fEq(,)
"SPEC/CapDL.State $fEqMaybe @ Word" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                               GHC.Types.Word)
  GHC.Base.$fEqMaybe @ GHC.Types.Word $dEq
  = CapDL.State.$s$fEq(,)_$s$fEqMaybe
"SPEC/CapDL.State $fEqMaybe_$c== @ Word" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                    GHC.Types.Word)
  GHC.Base.$fEqMaybe_$c== @ GHC.Types.Word $dEq
  = CapDL.State.$s$fEq(,)_$s$fEqMaybe_$c==
"SPEC/CapDL.State $fEq[] @ Word" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                            GHC.Types.Word)
  GHC.Classes.$fEq[] @ GHC.Types.Word $dEq = CapDL.State.$s$fEq[]
"SPEC/CapDL.State $fEq[]_$c/= @ Word" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                                 GHC.Types.Word)
  GHC.Classes.$fEq[]_$c/= @ GHC.Types.Word $dEq
  = CapDL.State.$s$fEq[]_$s$fEq[]_$c/=
"SPEC/CapDL.State $fOrd(,) @ (String, Maybe Word) @ Word" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                                       GHC.Types.Word)
                                                                          ($dOrd :: GHC.Classes.Ord
                                                                                      (GHC.Base.String,
                                                                                       GHC.Base.Maybe
                                                                                         GHC.Types.Word))
  GHC.Classes.$fOrd(,) @ (GHC.Base.String,
                          GHC.Base.Maybe GHC.Types.Word)
                       @ GHC.Types.Word
                       $dOrd
                       $dOrd1
  = CapDL.State.$s$fOrd(,)1
"SPEC/CapDL.State $fOrd(,) @ [Char] @ (Maybe Word)" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                                 (GHC.Base.Maybe
                                                                                    GHC.Types.Word))
                                                                    ($dOrd :: GHC.Classes.Ord
                                                                                [GHC.Types.Char])
  GHC.Classes.$fOrd(,) @ [GHC.Types.Char]
                       @ (GHC.Base.Maybe GHC.Types.Word)
                       $dOrd
                       $dOrd1
  = CapDL.State.$s$fOrd(,)
"SPEC/CapDL.State $fOrd(,)_$cp1Ord @ (String, Maybe Word) @ Word" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                                               GHC.Types.Word)
                                                                                  ($dOrd :: GHC.Classes.Ord
                                                                                              (GHC.Base.String,
                                                                                               GHC.Base.Maybe
                                                                                                 GHC.Types.Word))
  GHC.Classes.$fOrd(,)_$cp1Ord @ (GHC.Base.String,
                                  GHC.Base.Maybe GHC.Types.Word)
                               @ GHC.Types.Word
                               $dOrd
                               $dOrd1
  = CapDL.State.$s$fOrd(,)_$s$fOrd(,)_$cp1Ord
"SPEC/CapDL.State $fOrd(,)_$cp1Ord @ [Char] @ (Maybe Word)" [ALWAYS] forall ($dOrd1 :: GHC.Classes.Ord
                                                                                         (GHC.Base.Maybe
                                                                                            GHC.Types.Word))
                                                                            ($dOrd :: GHC.Classes.Ord
                                                                                        [GHC.Types.Char])
  GHC.Classes.$fOrd(,)_$cp1Ord @ [GHC.Types.Char]
                               @ (GHC.Base.Maybe GHC.Types.Word)
                               $dOrd
                               $dOrd1
  = CapDL.State.$s$fEq(,)_$s$fOrd(,)_$cp1Ord
"SPEC/CapDL.State $fOrdMaybe @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                 GHC.Types.Word)
  GHC.Base.$fOrdMaybe @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe
"SPEC/CapDL.State $fOrdMaybe_$c< @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                     GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$c< @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c<
"SPEC/CapDL.State $fOrdMaybe_$c<= @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                      GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$c<= @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c<=
"SPEC/CapDL.State $fOrdMaybe_$c> @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                     GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$c> @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c>
"SPEC/CapDL.State $fOrdMaybe_$c>= @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                      GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$c>= @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$c>=
"SPEC/CapDL.State $fOrdMaybe_$ccompare @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                           GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$ccompare @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$ccompare
"SPEC/CapDL.State $fOrdMaybe_$cmax @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                       GHC.Types.Word)
  GHC.Base.$fOrdMaybe_$cmax @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd(,)_$s$fOrdMaybe_$cmax
"SPEC/CapDL.State $fOrd[] @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                              GHC.Types.Word)
  GHC.Classes.$fOrd[] @ GHC.Types.Word $dOrd = CapDL.State.$s$fOrd[]
"SPEC/CapDL.State $fOrd[]_$c< @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                  GHC.Types.Word)
  GHC.Classes.$fOrd[]_$c< @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$c<
"SPEC/CapDL.State $fOrd[]_$c<= @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                   GHC.Types.Word)
  GHC.Classes.$fOrd[]_$c<= @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$c<=
"SPEC/CapDL.State $fOrd[]_$c> @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                  GHC.Types.Word)
  GHC.Classes.$fOrd[]_$c> @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$c>
"SPEC/CapDL.State $fOrd[]_$c>= @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                   GHC.Types.Word)
  GHC.Classes.$fOrd[]_$c>= @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$c>=
"SPEC/CapDL.State $fOrd[]_$cmax @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                    GHC.Types.Word)
  GHC.Classes.$fOrd[]_$cmax @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$cmax
"SPEC/CapDL.State $fOrd[]_$cmin @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                    GHC.Types.Word)
  GHC.Classes.$fOrd[]_$cmin @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$cmin
"SPEC/CapDL.State $fOrd[]_$cp1Ord @ Word" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                      GHC.Types.Word)
  GHC.Classes.$fOrd[]_$cp1Ord @ GHC.Types.Word $dOrd
  = CapDL.State.$s$fOrd[]_$s$fOrd[]_$cp1Ord
"SPEC/CapDL.State fromList @ [Word] _" [ALWAYS] forall @ a
                                                       ($dOrd :: GHC.Classes.Ord [GHC.Types.Word])
  Data.Map.Base.fromList @ [GHC.Types.Word] @ a $dOrd
  = CapDL.State.$sfromList @ a
"SPEC/CapDL.State mapKeys @ [Word] _ _" [ALWAYS] forall @ k1
                                                        @ a
                                                        ($dOrd :: GHC.Classes.Ord [GHC.Types.Word])
  Data.Map.Base.mapKeys @ [GHC.Types.Word] @ k1 @ a $dOrd
  = CapDL.State.$smapKeys @ k1 @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

