#
# Copyright 2018, Data61
# Commonwealth Scientific and Industrial Research Organisation (CSIRO)
# ABN 41 687 119 230.
#
# This software may be distributed and modified according to the terms of
# the BSD 2-Clause license. Note that NO WARRANTY is provided.
# See "LICENSE_BSD2.txt" for details.
#
# @TAG(DATA61_BSD)
#

cmake_minimum_required(VERSION 3.8.2)

# THIS FILE IS AUTOMATICALLY GENERATED. YOUR EDITS WILL BE OVERWRITTEN.

# Include the CapDL tools build helpers, we will need this later one when generating capDL targets
find_file(CAPDL_LOADER_BUILD_HELPERS helpers.cmake PATHS ${CMAKE_SOURCE_DIR}/projects/capdl/capdl-loader-app CMAKE_FIND_ROOT_PATH_BOTH)
mark_as_advanced(FORCE CAPDL_LOADER_BUILD_HELPERS)
if("${CAPDL_LOADER_BUILD_HELPERS}" STREQUAL "CAPDL_LOADER_BUILD_HELPERS-NOTFOUND")
    message(FATAL_ERROR "Failed to find helpers.cmake. Consider cmake -DCAPDL_LOADER_BUILD_HELPERS=/path/to/helpers.cmake")
endif()
include("${CAPDL_LOADER_BUILD_HELPERS}")

# Define names for tools we will use
set(OBJCOPY ${CROSS_COMPILER_PREFIX}objcopy)

# Declare our 'core' CAmkES libraries. These are the libraries that are considered minimal for the
# glue code that is linked to camkes applications to run
set(CAMKES_CORE_LIBS "sel4;muslc;sel4camkes;sel4sync;utils;sel4vka;sel4utils;sel4platsupport;platsupport;sel4vspace;sel4muslcsys")

# The main function generated by CAmkES does not conform to the standard main
# signatures, so disable warnings for this.
set(CAMKES_C_FLAGS "-Wno-main")







# We build up a list of all the generated items that we want to construct a single
# camkes invocation
set(item_list "")
set(outfile_list "")
set(reflow_commands "")
set(deps_list "")
set(elfs_list "")
set(camkes_ver_opts "")

macro(ParentListAppend list)
    set(local_list_value "${${list}}")
    list(APPEND local_list_value ${ARGN})
    set(${list} "${local_list_value}" PARENT_SCOPE)
endmacro(ParentListAppend list)

# Helper function for declaring a generated file
function(CAmkESGen output item)
    cmake_parse_arguments(PARSE_ARGV 2 CAMKES_GEN "SOURCE;C_STYLE;THY_STYLE" "SOURCES_VAR;VER_BASE_NAME" "DEPENDS;ELFS")
    if (NOT "${CAMKES_GEN_UNPARSED_ARGUMENTS}" STREQUAL "")
        message(FATAL_ERROR "Unknown arguments to CAmkESGen: ${CAMKES_GEN_UNPARSED_ARGUMENTS}")
    endif()
    # generate command
    get_filename_component(out_dir "${output}" DIRECTORY)
    # Reflow generated files if requested
    if (CAMKES_GEN_C_STYLE AND (NOT ("${CAMKES_C_FMT_INVOCATION}" STREQUAL "")))
        ParentListAppend(reflow_commands COMMAND sh -c
            "${CAMKES_C_FMT_INVOCATION} ${output} | ${CAMKES_SPONGE_INVOCATION} ${output}")
    elseif(CAMKES_GEN_THY_STYLE)
        ParentListAppend(reflow_commands COMMAND sh -c
            "${TPP_TOOL} ${output} | ${CAMKES_SPONGE_INVOCATION} ${output}")
    endif()
    # Append the item and outfile
    ParentListAppend(item_list "${item}")
    ParentListAppend(outfile_list "${output}")
    ParentListAppend(deps_list "${CAMKES_GEN_DEPENDS}")
    ParentListAppend(elfs_list "${CAMKES_GEN_ELFS}")
    ParentListAppend(deps_list "${CAMKES_GEN_ELFS}")
    # Pass along base name for verification templates
    if (NOT "${CAMKES_GEN_VER_BASE_NAME}" STREQUAL "")
        ParentListAppend(camkes_ver_opts "--verification-base-name=${CAMKES_GEN_VER_BASE_NAME}")
    endif()
    # Add to the sources list if it's a source file
    if (CAMKES_GEN_SOURCE)
        if (CAMKES_GEN_SOURCES_VAR)
            ParentListAppend("${CAMKES_GEN_SOURCES_VAR}" "${output}")
        else ()
            ParentListAppend(gen_sources "${output}")
        endif()
    endif()
    # Always add to the list of generated files
    ParentListAppend(gen_files "${output}")
endfunction(CAmkESGen)

# Generate all the files declared previously. object_state_op is either
# load- or save-object-state, depending on whether the object state has
# already been built.
function(CAmkESOutputGenCommand object_state_op)
    if ("${item_list}" STREQUAL "")
        return()
    endif()
    list(LENGTH outfile_list outfile_list_count)
    add_custom_command(
        OUTPUT ${outfile_list}
        COMMAND
            ${CMAKE_COMMAND} -E env ${CAMKES_TOOL_ENVIRONMENT} "${CAMKES_TOOL}"
                "--item;$<JOIN:${item_list},;--item;>"
                "--outfile;$<JOIN:${outfile_list},;--outfile;>"
                "--load-ast=${CMAKE_CURRENT_BINARY_DIR}/ast.pickle"
                "--${object_state_op}=${CMAKE_CURRENT_BINARY_DIR}/object.pickle"
                "$<$<BOOL:${elfs_list}>:--elf$<SEMICOLON>>$<JOIN:${elfs_list},$<SEMICOLON>--elf$<SEMICOLON>>"
                ${camkes_ver_opts}
                ${CAMKES_FLAGS}
        ${reflow_commands}
        DEPENDS
            ${CAMKES_ADL_SOURCE}
            /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.environment.start.cakeml /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/arch-definitions.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/SharedDataTo.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage6.py /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/Object.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/select_inputs.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.environment.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/cdl-refine.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/exception.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.template.h /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/runall.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPCSimple-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/parser.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/query.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4DirectCall-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/traversal.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/testsel4_notification.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/linker.lds /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/jinja_pylint.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/rpc-connector.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/camkes-hardware.idl4 /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/hash.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/inv.thy /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/ModchkIface.idl4 /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/camkes-gen.cmake /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/PageCollection.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/packed.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/jinja_lint.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationNative-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/sel4notification.pml /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/RPCSimple.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/base.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage4.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage0.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/cache.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/macros.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/Counter.py /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/lintsource.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/helpers/error.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/ckeywords.py /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/Spec.py /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/ELF.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationQueue-to.template.c /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/Allocator.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/exception.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/__init__.pyc /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/sizeof_probe.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage3.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/dictutils.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes.sh /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/helpers/util.c /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/signing_device.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4HardwareInterrupt.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/exception.pyc /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/macros.pyc /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Modchk/Modchk.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationBind-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/std_connector.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/sizeof_probe.pyc /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/RPCSimpleFrom.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/testmacros.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4SharedData-common.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/base.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/filehash.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/helpers/tls.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/SharedDataFrom.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/install_code.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationBind-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/flatten_args.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/RPCSimple_base.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/getmr_setmr.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPCSimple-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/Filters.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/log.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4DirectCall-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/capdl-spec.cdl /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/Template.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/isabelle_symbols.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/rpc-connector-common-to.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4SharedData-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage7.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/memoization.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/testbadidioms.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4SharedData-common.template.h /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/version.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPCCall-to.template.cakeml /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/Cap.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/RPCSimpleTo.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.debug.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPCCall-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/scope.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4Notification-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationNative-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPCCall-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/seL4_GetIPCBuffer_wp.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/Renderer.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/insert_input.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/seven.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4GDB-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/type.py /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Signtx/Signtx.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/exception.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage1.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.rumprun.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/Template.pyc /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4HardwareMMIO.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/lint.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.environment.end.cakeml /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/objects.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/shelf.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/delete_inputs.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/mkdirp.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.common.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4Notification-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPC-to.template.c /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Modtx/Modtx.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/rpc-connector-common-from.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4GDBMem-from.template.c /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/CryptoIface.idl4 /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage10.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/tests/testcustomtemplates.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage8.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/__main__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/have_heap.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/helpers/array_check.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/select_output.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/liftedast.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/NotificationNativeFrom.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4RPC-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/frozendict.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/component.simple.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4NotificationQueue-from.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/delete_output.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/create_output.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/strhash.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/helpers/marshal.c /home/sel4-training/sel4-tutorials-manifest/projects/camkes/capdl/python-capdl-tool/capdl/util.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/fdtQueryEngine.py /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Crypto/Crypto.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/root.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/ast/location.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/tls_wps.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage5.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/abort.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/cimp-base.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4GDBMem-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/ptr.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/NotificationNativeTo.template.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/exception.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/create_input.sql /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/terminal.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/Context.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/gdb-delegate.camkes /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/graph.dot /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/ModtxIface.idl4 /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/arch_helpers.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4IOAPICHardwareInterrupt.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage9.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/debug_abbrevs.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/runner/NameMangling.py /home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/SigntxIface.idl4 /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/heap.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/arch_helpers.pyc /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/parser/stage2.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/autocorres/camkes_get_tls_wp.thy /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4GDB-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4SharedData-to.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/seL4HardwareIOPort.template.c /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/templates/__init__.py /home/sel4-training/sel4-tutorials-manifest/tools/camkes/camkes/internal/insert_output.sql
            # This pulls in miscellaneous dependencies 
            # which is used by the camkes tool
            ${CAMKES_TOOL_DEPENDENCIES}
            # Any additional dependencies from the files
            ${deps_list}
        VERBATIM
        COMMAND_EXPAND_LISTS
        COMMENT "Performing CAmkES generation for ${outfile_list_count} files"
    )
    set(reflow_commands "" PARENT_SCOPE)
    set(item_list "" PARENT_SCOPE)
    set(deps_list "" PARENT_SCOPE)
    set(outfile_list "" PARENT_SCOPE)
    set(elfs_list "" PARENT_SCOPE)
    set(camkes_ver_opts "" PARENT_SCOPE)
endfunction(CAmkESOutputGenCommand)

# helper for appending lists of generator expressions
function(AppendGenerator output new_list_value)
    # determine if there is anything in the original list OR the new list, and use that to deteremine
    # whether or not to put a semicolon between the two
    set(prop "${${output}}")
    set(new_list "${prop}$<$<OR:$<BOOL:${prop}>,$<BOOL:${new_list_value}>>:$<SEMICOLON>>${new_list_value}")
    set(${output} "${new_list}" PARENT_SCOPE)
endfunction(AppendGenerator)

# Helper for constructing a generator expression that evalutes to the provided value if it exists,
# or to a default value.
# if maybe_value is the empty string
#  evaluate to the contents of default
# else
#  evaluate to the contents of maybe_value
# Both 'default' and 'maybe_value' can themselves be generator expressions, allow for chaining usages of
# this together to build nested ORs.
function(GeneratorValueOrDefault output default maybe_value)
    set(new_output "$<IF:$<STREQUAL:${maybe_value},>,${default},${maybe_value}>")
    set(${output} "${new_output}" PARENT_SCOPE)
endfunction(GeneratorValueOrDefault)

# A target for each binary that we need to build

    # Variable for collecting generated files
    set(gen_files "")
    set(gen_sources "")
    set(cakeml_sources "")
    # If no instance target exists declare it to simplify the logic of the generator expressions
    set (instance_target "CAmkESComponent_Crypto_instance_crypto")
    if (NOT (TARGET ${instance_target}))
        add_custom_target(${instance_target})
    endif()
    # Retrieve the static sources for the component
    set(static_sources "$<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_SOURCES>")
    AppendGenerator(static_sources "$<TARGET_PROPERTY:${instance_target},COMPONENT_SOURCES>")
    set(extra_c_flags "$<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_C_FLAGS>")
    AppendGenerator(extra_c_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_C_FLAGS>")
    set(extra_ld_flags "$<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_LD_FLAGS>")
    AppendGenerator(extra_ld_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_LD_FLAGS>")
    set(extra_libs "$<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_LIBS>")
    AppendGenerator(extra_libs "$<TARGET_PROPERTY:${instance_target},COMPONENT_LIBS>")
    # Retrieve the static headers for the component. Ensure instance headers are placed first
    set(includes "$<TARGET_PROPERTY:${instance_target},COMPONENT_INCLUDES>")
    AppendGenerator(includes "$<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_INCLUDES>")
    # Generate camkes header
    set(generated_dir "${CMAKE_CURRENT_BINARY_DIR}/crypto")
    CAmkESGen("${generated_dir}/include/camkes.h" "crypto/header" C_STYLE)
    # Generated different entry points for the instance
    CAmkESGen("${generated_dir}/camkes.c" crypto/source SOURCE C_STYLE)
    
    
    
    
        CAmkESGen("${generated_dir}/camkes.environment.c" crypto/c_environment_source SOURCE C_STYLE)
    
    # Generate connectors for this instance
    
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
            set(unique_name crypto_iface_seL4RPCCall_1)
            
        
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
                
                    CAmkESGen("${generated_dir}/${unique_name}.c" conn2.conn5/to/source/0 SOURCE C_STYLE)
                
                # Add a rule to generate the header if this connector has a header template
                
            
        
    
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
            set(unique_name modchk_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn3.conn7/from/source/0 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
            set(unique_name modtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn4.conn8/from/source/0 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
            set(unique_name signtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
    
    # Generate our linker script
    set(linker_file "${generated_dir}/linker.lds")
    CAmkESGen("${linker_file}" crypto/linker)
    # Create a target for all our generated files
    set(gen_target crypto_generated)
    add_custom_target(${gen_target} DEPENDS ${gen_files})
    # Build the actual binary
    set(target crypto.instance.bin)
    add_executable(${target} EXCLUDE_FROM_ALL
        ${static_sources}
        ${gen_sources}

    )
    # If COMPONENT_LINKER_LANGUAGE is set on the component target, set the LINKER_LANGUAGE of the executable
    get_property(link_language TARGET CAmkESComponent_Crypto PROPERTY COMPONENT_LINKER_LANGUAGE)
    if (NOT "${link_language}" STREQUAL "")
        set_property(TARGET ${target} PROPERTY LINKER_LANGUAGE ${link_language})
    endif()
    # Build any CakeML library
    if (NOT ("${cakeml_sources}" STREQUAL ""))
        # Pull heap/stack size from component expression OR instances expression OR default to an arbitrary 50
        # The order here is important as we want the instance property to be able to override the component property
        GeneratorValueOrDefault(heap 50 $<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(heap "${heap}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(stack 50 $<TARGET_PROPERTY:CAmkESComponent_Crypto,COMPONENT_CAKEML_STACK_SIZE>)
        GeneratorValueOrDefault(stack "${stack}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_STACK_SIZE>)
        # Additional directories for the HOL build to depend on
        get_property(cakeml_includes TARGET CAmkESComponent_Crypto PROPERTY COMPONENT_CAKEML_INCLUDES)
        get_property(cakeml_depends TARGET CAmkESComponent_Crypto PROPERTY COMPONENT_CAKEML_DEPENDS)
        DeclareCakeMLLib(camkescakeml_contents
            SOURCES "${cakeml_sources}"
            TRANSLATION_THEORY "camkesEnd"
            HEAP_SIZE "${heap}"
            STACK_SIZE "${stack}"
            RUNTIME_ENTRY "component_control_main"
            CAKEML_ENTRY "camkes_entry"
            INCLUDES ${cakeml_includes}
            DEPENDS "${gen_target}" "${cakeml_depends}"
        )
        target_link_libraries(${target} camkescakeml camkescakeml_contents)
    endif()
    target_include_directories(${target} PRIVATE ${includes} "${generated_dir}/include")
    # Depend upon core camkes libraries
    target_link_libraries(${target} ${CAMKES_CORE_LIBS})
    # Depend upon additional libraries
    target_link_libraries(${target} ${extra_libs})
    # Depend upon target that creates the generated source files
    add_dependencies(${target} ${gen_target} CAmkESComponent_Crypto)
    # Set our CAmkES specific additional link flags
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS
        " -static -nostdlib -u _camkes_start -e _camkes_start ")
    # Add extra flags specified by the user
    target_compile_options(${target} PRIVATE ${extra_c_flags} ${CAMKES_C_FLAGS})
    set_property(TARGET ${TARGET} APPEND_STRING PROPERTY LINK_FLAGS ${extra_ld_flags})
    # Only incrementally link if this instance is going on to become part of a
    # group.
    # TODO: we care about being grouped elsewhere as well. generalize this
    
    
        
    
        
    
        
    
        
    
    
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--script=${linker_file} ")

    # Variable for collecting generated files
    set(gen_files "")
    set(gen_sources "")
    set(cakeml_sources "")
    # If no instance target exists declare it to simplify the logic of the generator expressions
    set (instance_target "CAmkESComponent_Modchk_instance_modchk")
    if (NOT (TARGET ${instance_target}))
        add_custom_target(${instance_target})
    endif()
    # Retrieve the static sources for the component
    set(static_sources "$<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_SOURCES>")
    AppendGenerator(static_sources "$<TARGET_PROPERTY:${instance_target},COMPONENT_SOURCES>")
    set(extra_c_flags "$<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_C_FLAGS>")
    AppendGenerator(extra_c_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_C_FLAGS>")
    set(extra_ld_flags "$<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_LD_FLAGS>")
    AppendGenerator(extra_ld_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_LD_FLAGS>")
    set(extra_libs "$<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_LIBS>")
    AppendGenerator(extra_libs "$<TARGET_PROPERTY:${instance_target},COMPONENT_LIBS>")
    # Retrieve the static headers for the component. Ensure instance headers are placed first
    set(includes "$<TARGET_PROPERTY:${instance_target},COMPONENT_INCLUDES>")
    AppendGenerator(includes "$<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_INCLUDES>")
    # Generate camkes header
    set(generated_dir "${CMAKE_CURRENT_BINARY_DIR}/modchk")
    CAmkESGen("${generated_dir}/include/camkes.h" "modchk/header" C_STYLE)
    # Generated different entry points for the instance
    CAmkESGen("${generated_dir}/camkes.c" modchk/source SOURCE C_STYLE)
    
    
    
    
        CAmkESGen("${generated_dir}/camkes.environment.c" modchk/c_environment_source SOURCE C_STYLE)
    
    # Generate connectors for this instance
    
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
            set(unique_name crypto_iface_seL4RPCCall_1)
            
        
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
            set(unique_name modchk_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
                
                    CAmkESGen("${generated_dir}/${unique_name}.c" conn1.conn6/to/source/0 SOURCE C_STYLE)
                
                # Add a rule to generate the header if this connector has a header template
                
            
        
    
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
            set(unique_name modtx_iface_seL4RPCCall_1)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn3.conn7/from/source/1 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
            set(unique_name signtx_iface_seL4RPCCall_1)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn4.conn8/from/source/1 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
    
    # Generate our linker script
    set(linker_file "${generated_dir}/linker.lds")
    CAmkESGen("${linker_file}" modchk/linker)
    # Create a target for all our generated files
    set(gen_target modchk_generated)
    add_custom_target(${gen_target} DEPENDS ${gen_files})
    # Build the actual binary
    set(target modchk.instance.bin)
    add_executable(${target} EXCLUDE_FROM_ALL
        ${static_sources}
        ${gen_sources}

    )
    # If COMPONENT_LINKER_LANGUAGE is set on the component target, set the LINKER_LANGUAGE of the executable
    get_property(link_language TARGET CAmkESComponent_Modchk PROPERTY COMPONENT_LINKER_LANGUAGE)
    if (NOT "${link_language}" STREQUAL "")
        set_property(TARGET ${target} PROPERTY LINKER_LANGUAGE ${link_language})
    endif()
    # Build any CakeML library
    if (NOT ("${cakeml_sources}" STREQUAL ""))
        # Pull heap/stack size from component expression OR instances expression OR default to an arbitrary 50
        # The order here is important as we want the instance property to be able to override the component property
        GeneratorValueOrDefault(heap 50 $<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(heap "${heap}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(stack 50 $<TARGET_PROPERTY:CAmkESComponent_Modchk,COMPONENT_CAKEML_STACK_SIZE>)
        GeneratorValueOrDefault(stack "${stack}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_STACK_SIZE>)
        # Additional directories for the HOL build to depend on
        get_property(cakeml_includes TARGET CAmkESComponent_Modchk PROPERTY COMPONENT_CAKEML_INCLUDES)
        get_property(cakeml_depends TARGET CAmkESComponent_Modchk PROPERTY COMPONENT_CAKEML_DEPENDS)
        DeclareCakeMLLib(camkescakeml_contents
            SOURCES "${cakeml_sources}"
            TRANSLATION_THEORY "camkesEnd"
            HEAP_SIZE "${heap}"
            STACK_SIZE "${stack}"
            RUNTIME_ENTRY "component_control_main"
            CAKEML_ENTRY "camkes_entry"
            INCLUDES ${cakeml_includes}
            DEPENDS "${gen_target}" "${cakeml_depends}"
        )
        target_link_libraries(${target} camkescakeml camkescakeml_contents)
    endif()
    target_include_directories(${target} PRIVATE ${includes} "${generated_dir}/include")
    # Depend upon core camkes libraries
    target_link_libraries(${target} ${CAMKES_CORE_LIBS})
    # Depend upon additional libraries
    target_link_libraries(${target} ${extra_libs})
    # Depend upon target that creates the generated source files
    add_dependencies(${target} ${gen_target} CAmkESComponent_Modchk)
    # Set our CAmkES specific additional link flags
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS
        " -static -nostdlib -u _camkes_start -e _camkes_start ")
    # Add extra flags specified by the user
    target_compile_options(${target} PRIVATE ${extra_c_flags} ${CAMKES_C_FLAGS})
    set_property(TARGET ${TARGET} APPEND_STRING PROPERTY LINK_FLAGS ${extra_ld_flags})
    # Only incrementally link if this instance is going on to become part of a
    # group.
    # TODO: we care about being grouped elsewhere as well. generalize this
    
    
        
    
        
    
        
    
        
    
    
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--script=${linker_file} ")

    # Variable for collecting generated files
    set(gen_files "")
    set(gen_sources "")
    set(cakeml_sources "")
    # If no instance target exists declare it to simplify the logic of the generator expressions
    set (instance_target "CAmkESComponent_Modtx_instance_modtx")
    if (NOT (TARGET ${instance_target}))
        add_custom_target(${instance_target})
    endif()
    # Retrieve the static sources for the component
    set(static_sources "$<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_SOURCES>")
    AppendGenerator(static_sources "$<TARGET_PROPERTY:${instance_target},COMPONENT_SOURCES>")
    set(extra_c_flags "$<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_C_FLAGS>")
    AppendGenerator(extra_c_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_C_FLAGS>")
    set(extra_ld_flags "$<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_LD_FLAGS>")
    AppendGenerator(extra_ld_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_LD_FLAGS>")
    set(extra_libs "$<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_LIBS>")
    AppendGenerator(extra_libs "$<TARGET_PROPERTY:${instance_target},COMPONENT_LIBS>")
    # Retrieve the static headers for the component. Ensure instance headers are placed first
    set(includes "$<TARGET_PROPERTY:${instance_target},COMPONENT_INCLUDES>")
    AppendGenerator(includes "$<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_INCLUDES>")
    # Generate camkes header
    set(generated_dir "${CMAKE_CURRENT_BINARY_DIR}/modtx")
    CAmkESGen("${generated_dir}/include/camkes.h" "modtx/header" C_STYLE)
    # Generated different entry points for the instance
    CAmkESGen("${generated_dir}/camkes.c" modtx/source SOURCE C_STYLE)
    
    
    
    
        CAmkESGen("${generated_dir}/camkes.environment.c" modtx/c_environment_source SOURCE C_STYLE)
    
    # Generate connectors for this instance
    
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn2.conn5/from/source/0 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
            set(unique_name crypto_iface_seL4RPCCall_1)
            
        
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn1.conn6/from/source/0 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
            set(unique_name modchk_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
            set(unique_name modtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
                
                    CAmkESGen("${generated_dir}/${unique_name}.c" conn3.conn7/to/source/0 SOURCE C_STYLE)
                
                # Add a rule to generate the header if this connector has a header template
                
            
        
    
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
            set(unique_name signtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
    
    # Generate our linker script
    set(linker_file "${generated_dir}/linker.lds")
    CAmkESGen("${linker_file}" modtx/linker)
    # Create a target for all our generated files
    set(gen_target modtx_generated)
    add_custom_target(${gen_target} DEPENDS ${gen_files})
    # Build the actual binary
    set(target modtx.instance.bin)
    add_executable(${target} EXCLUDE_FROM_ALL
        ${static_sources}
        ${gen_sources}

    )
    # If COMPONENT_LINKER_LANGUAGE is set on the component target, set the LINKER_LANGUAGE of the executable
    get_property(link_language TARGET CAmkESComponent_Modtx PROPERTY COMPONENT_LINKER_LANGUAGE)
    if (NOT "${link_language}" STREQUAL "")
        set_property(TARGET ${target} PROPERTY LINKER_LANGUAGE ${link_language})
    endif()
    # Build any CakeML library
    if (NOT ("${cakeml_sources}" STREQUAL ""))
        # Pull heap/stack size from component expression OR instances expression OR default to an arbitrary 50
        # The order here is important as we want the instance property to be able to override the component property
        GeneratorValueOrDefault(heap 50 $<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(heap "${heap}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(stack 50 $<TARGET_PROPERTY:CAmkESComponent_Modtx,COMPONENT_CAKEML_STACK_SIZE>)
        GeneratorValueOrDefault(stack "${stack}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_STACK_SIZE>)
        # Additional directories for the HOL build to depend on
        get_property(cakeml_includes TARGET CAmkESComponent_Modtx PROPERTY COMPONENT_CAKEML_INCLUDES)
        get_property(cakeml_depends TARGET CAmkESComponent_Modtx PROPERTY COMPONENT_CAKEML_DEPENDS)
        DeclareCakeMLLib(camkescakeml_contents
            SOURCES "${cakeml_sources}"
            TRANSLATION_THEORY "camkesEnd"
            HEAP_SIZE "${heap}"
            STACK_SIZE "${stack}"
            RUNTIME_ENTRY "component_control_main"
            CAKEML_ENTRY "camkes_entry"
            INCLUDES ${cakeml_includes}
            DEPENDS "${gen_target}" "${cakeml_depends}"
        )
        target_link_libraries(${target} camkescakeml camkescakeml_contents)
    endif()
    target_include_directories(${target} PRIVATE ${includes} "${generated_dir}/include")
    # Depend upon core camkes libraries
    target_link_libraries(${target} ${CAMKES_CORE_LIBS})
    # Depend upon additional libraries
    target_link_libraries(${target} ${extra_libs})
    # Depend upon target that creates the generated source files
    add_dependencies(${target} ${gen_target} CAmkESComponent_Modtx)
    # Set our CAmkES specific additional link flags
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS
        " -static -nostdlib -u _camkes_start -e _camkes_start ")
    # Add extra flags specified by the user
    target_compile_options(${target} PRIVATE ${extra_c_flags} ${CAMKES_C_FLAGS})
    set_property(TARGET ${TARGET} APPEND_STRING PROPERTY LINK_FLAGS ${extra_ld_flags})
    # Only incrementally link if this instance is going on to become part of a
    # group.
    # TODO: we care about being grouped elsewhere as well. generalize this
    
    
        
    
        
    
        
    
        
    
    
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--script=${linker_file} ")

    # Variable for collecting generated files
    set(gen_files "")
    set(gen_sources "")
    set(cakeml_sources "")
    # If no instance target exists declare it to simplify the logic of the generator expressions
    set (instance_target "CAmkESComponent_Signtx_instance_signtx")
    if (NOT (TARGET ${instance_target}))
        add_custom_target(${instance_target})
    endif()
    # Retrieve the static sources for the component
    set(static_sources "$<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_SOURCES>")
    AppendGenerator(static_sources "$<TARGET_PROPERTY:${instance_target},COMPONENT_SOURCES>")
    set(extra_c_flags "$<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_C_FLAGS>")
    AppendGenerator(extra_c_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_C_FLAGS>")
    set(extra_ld_flags "$<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_LD_FLAGS>")
    AppendGenerator(extra_ld_flags "$<TARGET_PROPERTY:${instance_target},COMPONENT_LD_FLAGS>")
    set(extra_libs "$<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_LIBS>")
    AppendGenerator(extra_libs "$<TARGET_PROPERTY:${instance_target},COMPONENT_LIBS>")
    # Retrieve the static headers for the component. Ensure instance headers are placed first
    set(includes "$<TARGET_PROPERTY:${instance_target},COMPONENT_INCLUDES>")
    AppendGenerator(includes "$<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_INCLUDES>")
    # Generate camkes header
    set(generated_dir "${CMAKE_CURRENT_BINARY_DIR}/signtx")
    CAmkESGen("${generated_dir}/include/camkes.h" "signtx/header" C_STYLE)
    # Generated different entry points for the instance
    CAmkESGen("${generated_dir}/camkes.c" signtx/source SOURCE C_STYLE)
    
    
    
    
        CAmkESGen("${generated_dir}/camkes.environment.c" signtx/c_environment_source SOURCE C_STYLE)
    
    # Generate connectors for this instance
    
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
            set(unique_name crypto_iface_seL4RPCCall_1)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn2.conn5/from/source/1 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
        
            set(unique_name crypto_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
            set(unique_name modchk_iface_seL4RPCCall_1)
            
                CAmkESGen("${generated_dir}/${unique_name}.c" conn1.conn6/from/source/1 SOURCE C_STYLE)
                # Add a rule to generate the header if this connector has a header template
                
            
        
        
            set(unique_name modchk_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
            set(unique_name modtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name modtx_iface_seL4RPCCall_0)
            
        
    
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
        
            set(unique_name signtx_iface_seL4RPCCall_1)
            
        
        
            set(unique_name signtx_iface_seL4RPCCall_0)
            
                
                    CAmkESGen("${generated_dir}/${unique_name}.c" conn4.conn8/to/source/0 SOURCE C_STYLE)
                
                # Add a rule to generate the header if this connector has a header template
                
            
        
    
    # Generate our linker script
    set(linker_file "${generated_dir}/linker.lds")
    CAmkESGen("${linker_file}" signtx/linker)
    # Create a target for all our generated files
    set(gen_target signtx_generated)
    add_custom_target(${gen_target} DEPENDS ${gen_files})
    # Build the actual binary
    set(target signtx.instance.bin)
    add_executable(${target} EXCLUDE_FROM_ALL
        ${static_sources}
        ${gen_sources}

    )
    # If COMPONENT_LINKER_LANGUAGE is set on the component target, set the LINKER_LANGUAGE of the executable
    get_property(link_language TARGET CAmkESComponent_Signtx PROPERTY COMPONENT_LINKER_LANGUAGE)
    if (NOT "${link_language}" STREQUAL "")
        set_property(TARGET ${target} PROPERTY LINKER_LANGUAGE ${link_language})
    endif()
    # Build any CakeML library
    if (NOT ("${cakeml_sources}" STREQUAL ""))
        # Pull heap/stack size from component expression OR instances expression OR default to an arbitrary 50
        # The order here is important as we want the instance property to be able to override the component property
        GeneratorValueOrDefault(heap 50 $<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(heap "${heap}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_HEAP_SIZE>)
        GeneratorValueOrDefault(stack 50 $<TARGET_PROPERTY:CAmkESComponent_Signtx,COMPONENT_CAKEML_STACK_SIZE>)
        GeneratorValueOrDefault(stack "${stack}" $<TARGET_PROPERTY:${instance_target},COMPONENT_CAKEML_STACK_SIZE>)
        # Additional directories for the HOL build to depend on
        get_property(cakeml_includes TARGET CAmkESComponent_Signtx PROPERTY COMPONENT_CAKEML_INCLUDES)
        get_property(cakeml_depends TARGET CAmkESComponent_Signtx PROPERTY COMPONENT_CAKEML_DEPENDS)
        DeclareCakeMLLib(camkescakeml_contents
            SOURCES "${cakeml_sources}"
            TRANSLATION_THEORY "camkesEnd"
            HEAP_SIZE "${heap}"
            STACK_SIZE "${stack}"
            RUNTIME_ENTRY "component_control_main"
            CAKEML_ENTRY "camkes_entry"
            INCLUDES ${cakeml_includes}
            DEPENDS "${gen_target}" "${cakeml_depends}"
        )
        target_link_libraries(${target} camkescakeml camkescakeml_contents)
    endif()
    target_include_directories(${target} PRIVATE ${includes} "${generated_dir}/include")
    # Depend upon core camkes libraries
    target_link_libraries(${target} ${CAMKES_CORE_LIBS})
    # Depend upon additional libraries
    target_link_libraries(${target} ${extra_libs})
    # Depend upon target that creates the generated source files
    add_dependencies(${target} ${gen_target} CAmkESComponent_Signtx)
    # Set our CAmkES specific additional link flags
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS
        " -static -nostdlib -u _camkes_start -e _camkes_start ")
    # Add extra flags specified by the user
    target_compile_options(${target} PRIVATE ${extra_c_flags} ${CAMKES_C_FLAGS})
    set_property(TARGET ${TARGET} APPEND_STRING PROPERTY LINK_FLAGS ${extra_ld_flags})
    # Only incrementally link if this instance is going on to become part of a
    # group.
    # TODO: we care about being grouped elsewhere as well. generalize this
    
    
        
    
        
    
        
    
        
    
    
    set_property(TARGET ${target} APPEND_STRING PROPERTY LINK_FLAGS " -Wl,--script=${linker_file} ")


# We need to apply objcopy to each component instance's ELF before we link them
# into a flattened binary in order to avoid symbol collision. Note that when we
# mangle symbols, we use the prefix 'camkes ' to avoid colliding with any
# user-provided symbols.




    set(input_target crypto.instance.bin)
    set(output ${CMAKE_CURRENT_BINARY_DIR}/crypto.instance-copy.bin)
    set(output_target crypto_instance_copy_target)
    set(input $<TARGET_FILE:${input_target}>)
    add_custom_command(
        OUTPUT "${output}"
        COMMAND
        # Brace yourself. This is going to be a bumpy ride.
        ${OBJCOPY}
            
            --keep-global-symbol ""

            
            --redefine-sym "_camkes_start=camkes crypto _camkes_start"

            
                
            
                
            
                
            
                
            
            "${input}" "${output}"
        COMMAND
            # Some toolchains insert exception handling infrastructure whether we ask
            # for it or not. The preceding `objcopy` step breaks references in
            # implicit `.eh_frame`s and friends, which then goes on to cause a linker
            # warning. Rather than attempt some complicated gymnastics to repair these
            # references, we just strip the exception handling pieces. To further
            # complicate the process, some architectures require an `.eh_frame` and
            # attempting to remove it causes errors. To handle this we just blindly
            # try to remove it and mask errors. We can't do this unconditionally in
            # the preceding `objcopy` because it fails when our toolchain has *not*
            # inserted exception handling pieces or when we're targeting an
            # architecture that requires `.eh_frame`.
            bash -c "${OBJCOPY} --remove-section .eh_frame --remove-section .eh_frame_hdr \
                --remove-section .rel.eh_frame --remove-section .rela.eh_frame ${output} \
                >/dev/null 2>/dev/null"
        VERBATIM
        DEPENDS ${input_target}
    )
    add_custom_target(crypto_instance_copy_target DEPENDS "${output}")
    # TODO target for dependencies



    set(input_target modchk.instance.bin)
    set(output ${CMAKE_CURRENT_BINARY_DIR}/modchk.instance-copy.bin)
    set(output_target modchk_instance_copy_target)
    set(input $<TARGET_FILE:${input_target}>)
    add_custom_command(
        OUTPUT "${output}"
        COMMAND
        # Brace yourself. This is going to be a bumpy ride.
        ${OBJCOPY}
            
            --keep-global-symbol ""

            
            --redefine-sym "_camkes_start=camkes modchk _camkes_start"

            
                
            
                
            
                
            
                
            
            "${input}" "${output}"
        COMMAND
            # Some toolchains insert exception handling infrastructure whether we ask
            # for it or not. The preceding `objcopy` step breaks references in
            # implicit `.eh_frame`s and friends, which then goes on to cause a linker
            # warning. Rather than attempt some complicated gymnastics to repair these
            # references, we just strip the exception handling pieces. To further
            # complicate the process, some architectures require an `.eh_frame` and
            # attempting to remove it causes errors. To handle this we just blindly
            # try to remove it and mask errors. We can't do this unconditionally in
            # the preceding `objcopy` because it fails when our toolchain has *not*
            # inserted exception handling pieces or when we're targeting an
            # architecture that requires `.eh_frame`.
            bash -c "${OBJCOPY} --remove-section .eh_frame --remove-section .eh_frame_hdr \
                --remove-section .rel.eh_frame --remove-section .rela.eh_frame ${output} \
                >/dev/null 2>/dev/null"
        VERBATIM
        DEPENDS ${input_target}
    )
    add_custom_target(modchk_instance_copy_target DEPENDS "${output}")
    # TODO target for dependencies



    set(input_target modtx.instance.bin)
    set(output ${CMAKE_CURRENT_BINARY_DIR}/modtx.instance-copy.bin)
    set(output_target modtx_instance_copy_target)
    set(input $<TARGET_FILE:${input_target}>)
    add_custom_command(
        OUTPUT "${output}"
        COMMAND
        # Brace yourself. This is going to be a bumpy ride.
        ${OBJCOPY}
            
            --keep-global-symbol ""

            
            --redefine-sym "_camkes_start=camkes modtx _camkes_start"

            
                
            
                
            
                
            
                
            
            "${input}" "${output}"
        COMMAND
            # Some toolchains insert exception handling infrastructure whether we ask
            # for it or not. The preceding `objcopy` step breaks references in
            # implicit `.eh_frame`s and friends, which then goes on to cause a linker
            # warning. Rather than attempt some complicated gymnastics to repair these
            # references, we just strip the exception handling pieces. To further
            # complicate the process, some architectures require an `.eh_frame` and
            # attempting to remove it causes errors. To handle this we just blindly
            # try to remove it and mask errors. We can't do this unconditionally in
            # the preceding `objcopy` because it fails when our toolchain has *not*
            # inserted exception handling pieces or when we're targeting an
            # architecture that requires `.eh_frame`.
            bash -c "${OBJCOPY} --remove-section .eh_frame --remove-section .eh_frame_hdr \
                --remove-section .rel.eh_frame --remove-section .rela.eh_frame ${output} \
                >/dev/null 2>/dev/null"
        VERBATIM
        DEPENDS ${input_target}
    )
    add_custom_target(modtx_instance_copy_target DEPENDS "${output}")
    # TODO target for dependencies



    set(input_target signtx.instance.bin)
    set(output ${CMAKE_CURRENT_BINARY_DIR}/signtx.instance-copy.bin)
    set(output_target signtx_instance_copy_target)
    set(input $<TARGET_FILE:${input_target}>)
    add_custom_command(
        OUTPUT "${output}"
        COMMAND
        # Brace yourself. This is going to be a bumpy ride.
        ${OBJCOPY}
            
            --keep-global-symbol ""

            
            --redefine-sym "_camkes_start=camkes signtx _camkes_start"

            
                
            
                
            
                
            
                
            
            "${input}" "${output}"
        COMMAND
            # Some toolchains insert exception handling infrastructure whether we ask
            # for it or not. The preceding `objcopy` step breaks references in
            # implicit `.eh_frame`s and friends, which then goes on to cause a linker
            # warning. Rather than attempt some complicated gymnastics to repair these
            # references, we just strip the exception handling pieces. To further
            # complicate the process, some architectures require an `.eh_frame` and
            # attempting to remove it causes errors. To handle this we just blindly
            # try to remove it and mask errors. We can't do this unconditionally in
            # the preceding `objcopy` because it fails when our toolchain has *not*
            # inserted exception handling pieces or when we're targeting an
            # architecture that requires `.eh_frame`.
            bash -c "${OBJCOPY} --remove-section .eh_frame --remove-section .eh_frame_hdr \
                --remove-section .rel.eh_frame --remove-section .rela.eh_frame ${output} \
                >/dev/null 2>/dev/null"
        VERBATIM
        DEPENDS ${input_target}
    )
    add_custom_target(signtx_instance_copy_target DEPENDS "${output}")
    # TODO target for dependencies


# Define the linker we used for instances groups. This is just C linking but without crt objects
# or any other libraries, we just want the flags to generate the correct binary type
set(CMAKE_INSTANCE_GROUP_LINK_EXECUTABLE "<CMAKE_C_COMPILER> <FLAGS> <CMAKE_C_LINK_FLAGS> <LINK_FLAGS> <OBJECTS> -o <TARGET>" CACHE INTERNAL "" FORCE)
# Finally link together the instances in the different groups */

    
    # Find all the instances that are part of this group */
    set(instances "")
    set(instance_targets "")
    
        
        
            list(APPEND instances "crypto.instance-copy.bin")
            list(APPEND instance_targets "crypto_instance_copy_target")
            # Define the copies as objects in case we need to link them into a group and
            # we would like cmake to not attempt to compile them
            set_property(SOURCE "crypto.instance-copy.bin" PROPERTY EXTERNAL_OBJECT TRUE)
        
    
        
        
    
        
        
    
        
        
    
    set(target ${CMAKE_CURRENT_BINARY_DIR}/crypto_group_bin)
    list(LENGTH instances instances_len)
    if (${instances_len} GREATER 1)
        add_executable(crypto_group_bin EXCLUDE_FROM_ALL ${instances})
        add_dependencies(crypto_group_bin ${instance_targets})
        # Use a custom linker definition that will not include crt objects
        set_property(TARGET crypto_group_bin PROPERTY LINKER_LANGUAGE INSTANCE_GROUP)
        # Note that we deliberately give groups a
        # broken entry point so that, if they are incorrectly loaded without correct
        # initial instruction pointers, threads will immediately fault
        set_property(TARGET crypto_group_bin APPEND PROPERTY LINK_FLAGS " -static -nostdlib --entry=0x0 -Wl,--build-id=none")
    else()
        add_custom_command(
            OUTPUT ${target}
            COMMAND
                cp "${instances}" "${target}"
            DEPENDS
                ${instances}
                ${instance_targets}
        )
    endif()
    add_custom_target(crypto_group_bin_group_target DEPENDS "${target}")

    
    # Find all the instances that are part of this group */
    set(instances "")
    set(instance_targets "")
    
        
        
    
        
        
            list(APPEND instances "modchk.instance-copy.bin")
            list(APPEND instance_targets "modchk_instance_copy_target")
            # Define the copies as objects in case we need to link them into a group and
            # we would like cmake to not attempt to compile them
            set_property(SOURCE "modchk.instance-copy.bin" PROPERTY EXTERNAL_OBJECT TRUE)
        
    
        
        
    
        
        
    
    set(target ${CMAKE_CURRENT_BINARY_DIR}/modchk_group_bin)
    list(LENGTH instances instances_len)
    if (${instances_len} GREATER 1)
        add_executable(modchk_group_bin EXCLUDE_FROM_ALL ${instances})
        add_dependencies(modchk_group_bin ${instance_targets})
        # Use a custom linker definition that will not include crt objects
        set_property(TARGET modchk_group_bin PROPERTY LINKER_LANGUAGE INSTANCE_GROUP)
        # Note that we deliberately give groups a
        # broken entry point so that, if they are incorrectly loaded without correct
        # initial instruction pointers, threads will immediately fault
        set_property(TARGET modchk_group_bin APPEND PROPERTY LINK_FLAGS " -static -nostdlib --entry=0x0 -Wl,--build-id=none")
    else()
        add_custom_command(
            OUTPUT ${target}
            COMMAND
                cp "${instances}" "${target}"
            DEPENDS
                ${instances}
                ${instance_targets}
        )
    endif()
    add_custom_target(modchk_group_bin_group_target DEPENDS "${target}")

    
    # Find all the instances that are part of this group */
    set(instances "")
    set(instance_targets "")
    
        
        
    
        
        
    
        
        
            list(APPEND instances "modtx.instance-copy.bin")
            list(APPEND instance_targets "modtx_instance_copy_target")
            # Define the copies as objects in case we need to link them into a group and
            # we would like cmake to not attempt to compile them
            set_property(SOURCE "modtx.instance-copy.bin" PROPERTY EXTERNAL_OBJECT TRUE)
        
    
        
        
    
    set(target ${CMAKE_CURRENT_BINARY_DIR}/modtx_group_bin)
    list(LENGTH instances instances_len)
    if (${instances_len} GREATER 1)
        add_executable(modtx_group_bin EXCLUDE_FROM_ALL ${instances})
        add_dependencies(modtx_group_bin ${instance_targets})
        # Use a custom linker definition that will not include crt objects
        set_property(TARGET modtx_group_bin PROPERTY LINKER_LANGUAGE INSTANCE_GROUP)
        # Note that we deliberately give groups a
        # broken entry point so that, if they are incorrectly loaded without correct
        # initial instruction pointers, threads will immediately fault
        set_property(TARGET modtx_group_bin APPEND PROPERTY LINK_FLAGS " -static -nostdlib --entry=0x0 -Wl,--build-id=none")
    else()
        add_custom_command(
            OUTPUT ${target}
            COMMAND
                cp "${instances}" "${target}"
            DEPENDS
                ${instances}
                ${instance_targets}
        )
    endif()
    add_custom_target(modtx_group_bin_group_target DEPENDS "${target}")

    
    # Find all the instances that are part of this group */
    set(instances "")
    set(instance_targets "")
    
        
        
    
        
        
    
        
        
    
        
        
            list(APPEND instances "signtx.instance-copy.bin")
            list(APPEND instance_targets "signtx_instance_copy_target")
            # Define the copies as objects in case we need to link them into a group and
            # we would like cmake to not attempt to compile them
            set_property(SOURCE "signtx.instance-copy.bin" PROPERTY EXTERNAL_OBJECT TRUE)
        
    
    set(target ${CMAKE_CURRENT_BINARY_DIR}/signtx_group_bin)
    list(LENGTH instances instances_len)
    if (${instances_len} GREATER 1)
        add_executable(signtx_group_bin EXCLUDE_FROM_ALL ${instances})
        add_dependencies(signtx_group_bin ${instance_targets})
        # Use a custom linker definition that will not include crt objects
        set_property(TARGET signtx_group_bin PROPERTY LINKER_LANGUAGE INSTANCE_GROUP)
        # Note that we deliberately give groups a
        # broken entry point so that, if they are incorrectly loaded without correct
        # initial instruction pointers, threads will immediately fault
        set_property(TARGET signtx_group_bin APPEND PROPERTY LINK_FLAGS " -static -nostdlib --entry=0x0 -Wl,--build-id=none")
    else()
        add_custom_command(
            OUTPUT ${target}
            COMMAND
                cp "${instances}" "${target}"
            DEPENDS
                ${instances}
                ${instance_targets}
        )
    endif()
    add_custom_target(signtx_group_bin_group_target DEPENDS "${target}")


# Generate our targets up to this point
CAmkESOutputGenCommand(save-object-state)

set(capdl_elf_depends "")
set(capdl_elf_targets "")

    
    list(APPEND capdl_elfs "${CMAKE_CURRENT_BINARY_DIR}/crypto_group_bin")
    list(APPEND capdl_elf_targets "crypto_group_bin_group_target")

    
    list(APPEND capdl_elfs "${CMAKE_CURRENT_BINARY_DIR}/modchk_group_bin")
    list(APPEND capdl_elf_targets "modchk_group_bin_group_target")

    
    list(APPEND capdl_elfs "${CMAKE_CURRENT_BINARY_DIR}/modtx_group_bin")
    list(APPEND capdl_elf_targets "modtx_group_bin_group_target")

    
    list(APPEND capdl_elfs "${CMAKE_CURRENT_BINARY_DIR}/signtx_group_bin")
    list(APPEND capdl_elf_targets "signtx_group_bin_group_target")

# CapDL generation. Aside from depending upon the CAmkES specifications themselves, it
# depends upon the copied instance binaries
# First define the capDL spec generation from CAmkES
CAmkESGen("${CAMKES_CDL_TARGET}" capdl DEPENDS "${capdl_elf_targets}" ELFS "${capdl_elfs}")
CAmkESOutputGenCommand(load-object-state)
add_custom_target(camkes_capdl_target DEPENDS "${CAMKES_CDL_TARGET}")

# Invoke the parse-capDL tool to turn the CDL spec into a C spec
CapDLToolCFileGen(capdl_c_spec_target capdl_spec.c "${CAMKES_CDL_TARGET}" "${CAPDL_TOOL_BINARY}"
    MAX_IRQS ${CapDLLoaderMaxIRQs}
    DEPENDS camkes_capdl_target install_capdl_tool "${CAPDL_TOOL_BINARY}")

# Ask the CapDL tool to generate an image with our given copied/mangled instances
BuildCapDLApplication(
    C_SPEC "capdl_spec.c"
    
        
        ELF "${CMAKE_CURRENT_BINARY_DIR}/crypto_group_bin"
    
        
        ELF "${CMAKE_CURRENT_BINARY_DIR}/modchk_group_bin"
    
        
        ELF "${CMAKE_CURRENT_BINARY_DIR}/modtx_group_bin"
    
        
        ELF "${CMAKE_CURRENT_BINARY_DIR}/signtx_group_bin"
    
    DEPENDS
        # Dependency on the C_SPEC and ELFs are added automatically, we just have to add the target
        # dependencies
        capdl_c_spec_target
        ${capdl_elf_targets}
    OUTPUT "capdl-loader"
)
DeclareRootserver("capdl-loader")

# Generate Isabelle theory scripts if needed
if (${CAmkESCapDLVerification})
    # Base name for Isabelle theories. We derive this from the app name,
    # but mangled to ensure that it is a valid identifier.
    string(MAKE_C_IDENTIFIER ${CAMKES_APP} VER_BASE_NAME)

    # Generated theory names. These must be consistent with the templates.
    set(CAMKES_CDL_THY "${VER_BASE_NAME}_CDL.thy")
    set(CAMKES_ADL_THY "${VER_BASE_NAME}_Arch_Spec.thy")
    set(CAMKES_CDL_REFINE_THY "${VER_BASE_NAME}_CDL_Refine.thy")
    set(CAMKES_VER_ROOT "ROOT")

    # ROOT file
    CAmkESGen("${CAMKES_VER_ROOT}" "isabelle-root" THY_STYLE VER_BASE_NAME ${VER_BASE_NAME})
    add_custom_target(isabelle_root DEPENDS "${CAMKES_VER_ROOT}")

    # Generate these theory files as part of overall build
    # FIXME: hack?
    add_dependencies("capdl-loader" isabelle_root)

    # Isabelle capDL spec
    add_custom_command(
        OUTPUT "${CAMKES_CDL_THY}"
        COMMAND
            # HACK: workaround for SELFOUR-6
            # This removes Grant from all endpoint caps
            ${CAPDL_THY_HACK_TOOL} <"${CAMKES_CDL_TARGET}" >"${CAMKES_CDL_TARGET}.munge"
        COMMAND
            ${CAPDL_TOOL_BINARY} --isabelle "${CAMKES_CDL_THY}" "${CAMKES_CDL_TARGET}.munge"
        DEPENDS
            "${CAMKES_CDL_TARGET}"
            camkes_capdl_target
            "${CAPDL_TOOL_BINARY}"
            install_capdl_tool
        BYPRODUCTS
            "${CAMKES_CDL_TARGET}.munge"
    )
    add_custom_target(camkes_cdl_thy DEPENDS "${CAMKES_CDL_THY}")
    add_dependencies(isabelle_root camkes_cdl_thy)

    # ADL spec
    CAmkESGen("${CAMKES_ADL_THY}" "arch-spec" THY_STYLE VER_BASE_NAME ${VER_BASE_NAME})
    add_custom_target(camkes_adl_thy DEPENDS "${CAMKES_ADL_THY}")
    add_dependencies(isabelle_root camkes_adl_thy)

    # CDL refinement proof
    CAmkESGen("${CAMKES_CDL_REFINE_THY}" "cdl-refine" THY_STYLE VER_BASE_NAME ${VER_BASE_NAME}
              DEPENDS "${capdl_elf_targets}" ELFS "${capdl_elfs}")
    add_custom_target(camkes_cdl_refine_thy DEPENDS "${CAMKES_CDL_REFINE_THY}")
    add_dependencies(isabelle_root camkes_cdl_refine_thy)

    CAmkESOutputGenCommand(load-object-state)
endif()

# Ensure we generated all the files we intended to, this is just sanity checking
if (NOT ("${item_list}" STREQUAL ""))
    message(FATAL_ERROR "Items added through CAmkESGen not generated")
endif()