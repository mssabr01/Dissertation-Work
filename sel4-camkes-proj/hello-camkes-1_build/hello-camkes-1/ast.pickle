(ccopy_reg
_reconstructor
p0
(ccamkes.ast.liftedast
LiftedAST
p1
c__builtin__
object
p2
Ntp3
Rp4
(dp5
S'_parent'
p6
NsS'_location'
p7
NsS'_assembly'
p8
g0
(ccamkes.ast.objects
Assembly
p9
g2
Ntp10
Rp11
(dp12
g7
g0
(ccamkes.ast.location
SourceLocation
p13
g2
Ntp14
Rp15
(dp16
S'precise'
p17
I00
sS'term'
p18
g0
(cplyplus.strees
STree
p19
g2
Ntp20
Rp21
(dp22
S'head'
p23
g0
(cplyplus.common
Str
p24
c__builtin__
unicode
p25
Vassembly_decl
p26
tp27
Rp28
sS'tail'
p29
(lp30
g0
(g19
g2
Ntp31
Rp32
(dp33
g23
g0
(g24
g25
Vassembly_defn
p34
tp35
Rp36
sg29
(lp37
g0
(g19
g2
Ntp38
Rp39
(dp40
g23
g0
(g24
g25
Vcomposition_sing
p41
tp42
Rp43
sg29
(lp44
g0
(g19
g2
Ntp45
Rp46
(dp47
g23
g0
(g24
g25
Vcomposition_decl
p48
tp49
Rp50
sg29
(lp51
g0
(g19
g2
Ntp52
Rp53
(dp54
g23
g0
(g24
g25
Vcomposition_defn
p55
tp56
Rp57
sg29
(lp58
g0
(g19
g2
Ntp59
Rp60
(dp61
g23
g0
(g24
g25
Vinstance_defn
p62
tp63
Rp64
sg29
(lp65
g0
(g19
g2
Ntp66
Rp67
(dp68
g23
g0
(g24
g25
Vcomponent_ref
p69
tp70
Rp71
sg29
(lp72
g0
(g19
g2
Ntp73
Rp74
(dp75
g23
g0
(g24
g25
Vreference
p76
tp77
Rp78
sg29
(lp79
g0
(g19
g2
Ntp80
Rp81
(dp82
g23
g0
(g24
g25
Vid
p83
tp84
Rp85
sg29
(lp86
g0
(cplyplus.common
TokValue
p87
g25
VCrypto
p88
tp89
Rp90
(dp91
S'column'
p92
I19
sS'index'
p93
I71
sS'line'
p94
I22
sS'type'
p95
g0
(g24
g25
VID
p96
tp97
Rp98
sS'pos_in_stream'
p99
I526
sbasbasbasbag0
(g19
g2
Ntp100
Rp101
(dp102
g23
g85
sg29
(lp103
g0
(g87
g25
Vcrypto
p104
tp105
Rp106
(dp107
g92
I26
sg93
I73
sg94
I22
sg95
g98
sg99
I533
sbasbasbag0
(g19
g2
Ntp108
Rp109
(dp110
g23
g64
sg29
(lp111
g0
(g19
g2
Ntp112
Rp113
(dp114
g23
g71
sg29
(lp115
g0
(g19
g2
Ntp116
Rp117
(dp118
g23
g78
sg29
(lp119
g0
(g19
g2
Ntp120
Rp121
(dp122
g23
g85
sg29
(lp123
g0
(g87
g25
VModchk
p124
tp125
Rp126
(dp127
g92
I19
sg93
I79
sg94
I23
sg95
g98
sg99
I559
sbasbasbasbag0
(g19
g2
Ntp128
Rp129
(dp130
g23
g85
sg29
(lp131
g0
(g87
g25
Vmodchk
p132
tp133
Rp134
(dp135
g92
I26
sg93
I81
sg94
I23
sg95
g98
sg99
I566
sbasbasbag0
(g19
g2
Ntp136
Rp137
(dp138
g23
g64
sg29
(lp139
g0
(g19
g2
Ntp140
Rp141
(dp142
g23
g71
sg29
(lp143
g0
(g19
g2
Ntp144
Rp145
(dp146
g23
g78
sg29
(lp147
g0
(g19
g2
Ntp148
Rp149
(dp150
g23
g85
sg29
(lp151
g0
(g87
g25
VModtx
p152
tp153
Rp154
(dp155
g92
I19
sg93
I87
sg94
I24
sg95
g98
sg99
I592
sbasbasbasbag0
(g19
g2
Ntp156
Rp157
(dp158
g23
g85
sg29
(lp159
g0
(g87
g25
Vmodtx
p160
tp161
Rp162
(dp163
g92
I25
sg93
I89
sg94
I24
sg95
g98
sg99
I598
sbasbasbag0
(g19
g2
Ntp164
Rp165
(dp166
g23
g64
sg29
(lp167
g0
(g19
g2
Ntp168
Rp169
(dp170
g23
g71
sg29
(lp171
g0
(g19
g2
Ntp172
Rp173
(dp174
g23
g78
sg29
(lp175
g0
(g19
g2
Ntp176
Rp177
(dp178
g23
g85
sg29
(lp179
g0
(g87
g25
VSigntx
p180
tp181
Rp182
(dp183
g92
I19
sg93
I95
sg94
I25
sg95
g98
sg99
I623
sbasbasbasbag0
(g19
g2
Ntp184
Rp185
(dp186
g23
g85
sg29
(lp187
g0
(g87
g25
Vsigntx
p188
tp189
Rp190
(dp191
g92
I26
sg93
I97
sg94
I25
sg95
g98
sg99
I630
sbasbasbag0
(g19
g2
Ntp192
Rp193
(dp194
g23
g0
(g24
g25
Vconnection_defn
p195
tp196
Rp197
sg29
(lp198
g0
(g19
g2
Ntp199
Rp200
(dp201
g23
g0
(g24
g25
Vconnector_ref
p202
tp203
Rp204
sg29
(lp205
g0
(g19
g2
Ntp206
Rp207
(dp208
g23
g78
sg29
(lp209
g0
(g19
g2
Ntp210
Rp211
(dp212
g23
g85
sg29
(lp213
g0
(g87
g25
VseL4RPCCall
p214
tp215
Rp216
(dp217
g92
I21
sg93
I113
sg94
I33
sg95
g98
sg99
I1033
sbasbasbasbag0
(g19
g2
Ntp218
Rp219
(dp220
g23
g85
sg29
(lp221
g0
(g87
g25
Vconn1
p222
tp223
Rp224
(dp225
g92
I33
sg93
I115
sg94
I33
sg95
g98
sg99
I1045
sbasbag0
(g19
g2
Ntp226
Rp227
(dp228
g23
g0
(g24
g25
Vconnection_end
p229
tp230
Rp231
sg29
(lp232
g0
(g19
g2
Ntp233
Rp234
(dp235
g23
g0
(g24
g25
Vfrom
p236
tp237
Rp238
sg29
(lp239
g0
(g87
g25
Vfrom
p240
tp241
Rp242
(dp243
g92
I39
sg93
I117
sg94
I33
sg95
g0
(g24
g25
VFROM
p244
tp245
Rp246
sg99
I1051
sbasbag0
(g19
g2
Ntp247
Rp248
(dp249
g23
g78
sg29
(lp250
g0
(g19
g2
Ntp251
Rp252
(dp253
g23
g85
sg29
(lp254
g0
(g87
g25
Vmodtx
p255
tp256
Rp257
(dp258
g92
I44
sg93
I119
sg94
I33
sg95
g98
sg99
I1056
sbasbag0
(g19
g2
Ntp259
Rp260
(dp261
g23
g85
sg29
(lp262
g0
(g87
g25
Vmodchk_iface
p263
tp264
Rp265
(dp266
g92
I50
sg93
I121
sg94
I33
sg95
g98
sg99
I1062
sbasbasbasbag0
(g19
g2
Ntp267
Rp268
(dp269
g23
g231
sg29
(lp270
g0
(g19
g2
Ntp271
Rp272
(dp273
g23
g0
(g24
g25
Vto
p274
tp275
Rp276
sg29
(lp277
g0
(g87
g25
Vto
p278
tp279
Rp280
(dp281
g92
I64
sg93
I124
sg94
I33
sg95
g0
(g24
g25
VTO
p282
tp283
Rp284
sg99
I1076
sbasbag0
(g19
g2
Ntp285
Rp286
(dp287
g23
g78
sg29
(lp288
g0
(g19
g2
Ntp289
Rp290
(dp291
g23
g85
sg29
(lp292
g0
(g87
g25
Vmodchk
p293
tp294
Rp295
(dp296
g92
I67
sg93
I126
sg94
I33
sg95
g98
sg99
I1079
sbasbag0
(g19
g2
Ntp297
Rp298
(dp299
g23
g85
sg29
(lp300
g0
(g87
g25
Vmodchk_iface
p301
tp302
Rp303
(dp304
g92
I74
sg93
I128
sg94
I33
sg95
g98
sg99
I1086
sbasbasbasbasbag0
(g19
g2
Ntp305
Rp306
(dp307
g23
g197
sg29
(lp308
g0
(g19
g2
Ntp309
Rp310
(dp311
g23
g204
sg29
(lp312
g0
(g19
g2
Ntp313
Rp314
(dp315
g23
g78
sg29
(lp316
g0
(g19
g2
Ntp317
Rp318
(dp319
g23
g85
sg29
(lp320
g0
(g87
g25
VseL4RPCCall
p321
tp322
Rp323
(dp324
g92
I21
sg93
I136
sg94
I34
sg95
g98
sg99
I1122
sbasbasbasbag0
(g19
g2
Ntp325
Rp326
(dp327
g23
g85
sg29
(lp328
g0
(g87
g25
Vconn2
p329
tp330
Rp331
(dp332
g92
I33
sg93
I138
sg94
I34
sg95
g98
sg99
I1134
sbasbag0
(g19
g2
Ntp333
Rp334
(dp335
g23
g231
sg29
(lp336
g0
(g19
g2
Ntp337
Rp338
(dp339
g23
g238
sg29
(lp340
g0
(g87
g25
Vfrom
p341
tp342
Rp343
(dp344
g92
I39
sg93
I140
sg94
I34
sg95
g246
sg99
I1140
sbasbag0
(g19
g2
Ntp345
Rp346
(dp347
g23
g78
sg29
(lp348
g0
(g19
g2
Ntp349
Rp350
(dp351
g23
g85
sg29
(lp352
g0
(g87
g25
Vmodtx
p353
tp354
Rp355
(dp356
g92
I44
sg93
I142
sg94
I34
sg95
g98
sg99
I1145
sbasbag0
(g19
g2
Ntp357
Rp358
(dp359
g23
g85
sg29
(lp360
g0
(g87
g25
Vcrypto_iface
p361
tp362
Rp363
(dp364
g92
I50
sg93
I144
sg94
I34
sg95
g98
sg99
I1151
sbasbasbasbag0
(g19
g2
Ntp365
Rp366
(dp367
g23
g231
sg29
(lp368
g0
(g19
g2
Ntp369
Rp370
(dp371
g23
g276
sg29
(lp372
g0
(g87
g25
Vto
p373
tp374
Rp375
(dp376
g92
I64
sg93
I147
sg94
I34
sg95
g284
sg99
I1165
sbasbag0
(g19
g2
Ntp377
Rp378
(dp379
g23
g78
sg29
(lp380
g0
(g19
g2
Ntp381
Rp382
(dp383
g23
g85
sg29
(lp384
g0
(g87
g25
Vcrypto
p385
tp386
Rp387
(dp388
g92
I67
sg93
I149
sg94
I34
sg95
g98
sg99
I1168
sbasbag0
(g19
g2
Ntp389
Rp390
(dp391
g23
g85
sg29
(lp392
g0
(g87
g25
Vcrypto_iface
p393
tp394
Rp395
(dp396
g92
I74
sg93
I151
sg94
I34
sg95
g98
sg99
I1175
sbasbasbasbasbag0
(g19
g2
Ntp397
Rp398
(dp399
g23
g197
sg29
(lp400
g0
(g19
g2
Ntp401
Rp402
(dp403
g23
g204
sg29
(lp404
g0
(g19
g2
Ntp405
Rp406
(dp407
g23
g78
sg29
(lp408
g0
(g19
g2
Ntp409
Rp410
(dp411
g23
g85
sg29
(lp412
g0
(g87
g25
VseL4RPCCall
p413
tp414
Rp415
(dp416
g92
I14
sg93
I161
sg94
I36
sg95
g98
sg99
I1252
sbasbasbasbag0
(g19
g2
Ntp417
Rp418
(dp419
g23
g85
sg29
(lp420
g0
(g87
g25
Vconn3
p421
tp422
Rp423
(dp424
g92
I26
sg93
I163
sg94
I36
sg95
g98
sg99
I1264
sbasbag0
(g19
g2
Ntp425
Rp426
(dp427
g23
g231
sg29
(lp428
g0
(g19
g2
Ntp429
Rp430
(dp431
g23
g238
sg29
(lp432
g0
(g87
g25
Vfrom
p433
tp434
Rp435
(dp436
g92
I32
sg93
I165
sg94
I36
sg95
g246
sg99
I1270
sbasbag0
(g19
g2
Ntp437
Rp438
(dp439
g23
g78
sg29
(lp440
g0
(g19
g2
Ntp441
Rp442
(dp443
g23
g85
sg29
(lp444
g0
(g87
g25
Vcrypto
p445
tp446
Rp447
(dp448
g92
I37
sg93
I167
sg94
I36
sg95
g98
sg99
I1275
sbasbag0
(g19
g2
Ntp449
Rp450
(dp451
g23
g85
sg29
(lp452
g0
(g87
g25
Vmodtx_iface
p453
tp454
Rp455
(dp456
g92
I44
sg93
I169
sg94
I36
sg95
g98
sg99
I1282
sbasbasbasbag0
(g19
g2
Ntp457
Rp458
(dp459
g23
g231
sg29
(lp460
g0
(g19
g2
Ntp461
Rp462
(dp463
g23
g276
sg29
(lp464
g0
(g87
g25
Vto
p465
tp466
Rp467
(dp468
g92
I57
sg93
I172
sg94
I36
sg95
g284
sg99
I1295
sbasbag0
(g19
g2
Ntp469
Rp470
(dp471
g23
g78
sg29
(lp472
g0
(g19
g2
Ntp473
Rp474
(dp475
g23
g85
sg29
(lp476
g0
(g87
g25
Vmodtx
p477
tp478
Rp479
(dp480
g92
I60
sg93
I174
sg94
I36
sg95
g98
sg99
I1298
sbasbag0
(g19
g2
Ntp481
Rp482
(dp483
g23
g85
sg29
(lp484
g0
(g87
g25
Vmodtx_iface
p485
tp486
Rp487
(dp488
g92
I66
sg93
I176
sg94
I36
sg95
g98
sg99
I1304
sbasbasbasbasbag0
(g19
g2
Ntp489
Rp490
(dp491
g23
g197
sg29
(lp492
g0
(g19
g2
Ntp493
Rp494
(dp495
g23
g204
sg29
(lp496
g0
(g19
g2
Ntp497
Rp498
(dp499
g23
g78
sg29
(lp500
g0
(g19
g2
Ntp501
Rp502
(dp503
g23
g85
sg29
(lp504
g0
(g87
g25
VseL4RPCCall
p505
tp506
Rp507
(dp508
g92
I14
sg93
I183
sg94
I37
sg95
g98
sg99
I1331
sbasbasbasbag0
(g19
g2
Ntp509
Rp510
(dp511
g23
g85
sg29
(lp512
g0
(g87
g25
Vconn4
p513
tp514
Rp515
(dp516
g92
I26
sg93
I185
sg94
I37
sg95
g98
sg99
I1343
sbasbag0
(g19
g2
Ntp517
Rp518
(dp519
g23
g231
sg29
(lp520
g0
(g19
g2
Ntp521
Rp522
(dp523
g23
g238
sg29
(lp524
g0
(g87
g25
Vfrom
p525
tp526
Rp527
(dp528
g92
I32
sg93
I187
sg94
I37
sg95
g246
sg99
I1349
sbasbag0
(g19
g2
Ntp529
Rp530
(dp531
g23
g78
sg29
(lp532
g0
(g19
g2
Ntp533
Rp534
(dp535
g23
g85
sg29
(lp536
g0
(g87
g25
Vcrypto
p537
tp538
Rp539
(dp540
g92
I37
sg93
I189
sg94
I37
sg95
g98
sg99
I1354
sbasbag0
(g19
g2
Ntp541
Rp542
(dp543
g23
g85
sg29
(lp544
g0
(g87
g25
Vsigntx_iface
p545
tp546
Rp547
(dp548
g92
I44
sg93
I191
sg94
I37
sg95
g98
sg99
I1361
sbasbasbasbag0
(g19
g2
Ntp549
Rp550
(dp551
g23
g231
sg29
(lp552
g0
(g19
g2
Ntp553
Rp554
(dp555
g23
g276
sg29
(lp556
g0
(g87
g25
Vto
p557
tp558
Rp559
(dp560
g92
I58
sg93
I194
sg94
I37
sg95
g284
sg99
I1375
sbasbag0
(g19
g2
Ntp561
Rp562
(dp563
g23
g78
sg29
(lp564
g0
(g19
g2
Ntp565
Rp566
(dp567
g23
g85
sg29
(lp568
g0
(g87
g25
Vsigntx
p569
tp570
Rp571
(dp572
g92
I61
sg93
I196
sg94
I37
sg95
g98
sg99
I1378
sbasbag0
(g19
g2
Ntp573
Rp574
(dp575
g23
g85
sg29
(lp576
g0
(g87
g25
Vsigntx_iface
p577
tp578
Rp579
(dp580
g92
I68
sg93
I198
sg94
I37
sg95
g98
sg99
I1385
sbasbasbasbasbag0
(g19
g2
Ntp581
Rp582
(dp583
g23
g197
sg29
(lp584
g0
(g19
g2
Ntp585
Rp586
(dp587
g23
g204
sg29
(lp588
g0
(g19
g2
Ntp589
Rp590
(dp591
g23
g78
sg29
(lp592
g0
(g19
g2
Ntp593
Rp594
(dp595
g23
g85
sg29
(lp596
g0
(g87
g25
VseL4RPCCall
p597
tp598
Rp599
(dp600
g92
I14
sg93
I209
sg94
I40
sg95
g98
sg99
I1464
sbasbasbasbag0
(g19
g2
Ntp601
Rp602
(dp603
g23
g85
sg29
(lp604
g0
(g87
g25
Vconn5
p605
tp606
Rp607
(dp608
g92
I26
sg93
I211
sg94
I40
sg95
g98
sg99
I1476
sbasbag0
(g19
g2
Ntp609
Rp610
(dp611
g23
g231
sg29
(lp612
g0
(g19
g2
Ntp613
Rp614
(dp615
g23
g238
sg29
(lp616
g0
(g87
g25
Vfrom
p617
tp618
Rp619
(dp620
g92
I32
sg93
I213
sg94
I40
sg95
g246
sg99
I1482
sbasbag0
(g19
g2
Ntp621
Rp622
(dp623
g23
g78
sg29
(lp624
g0
(g19
g2
Ntp625
Rp626
(dp627
g23
g85
sg29
(lp628
g0
(g87
g25
Vsigntx
p629
tp630
Rp631
(dp632
g92
I37
sg93
I215
sg94
I40
sg95
g98
sg99
I1487
sbasbag0
(g19
g2
Ntp633
Rp634
(dp635
g23
g85
sg29
(lp636
g0
(g87
g25
Vcrypto_iface
p637
tp638
Rp639
(dp640
g92
I44
sg93
I217
sg94
I40
sg95
g98
sg99
I1494
sbasbasbasbag0
(g19
g2
Ntp641
Rp642
(dp643
g23
g231
sg29
(lp644
g0
(g19
g2
Ntp645
Rp646
(dp647
g23
g276
sg29
(lp648
g0
(g87
g25
Vto
p649
tp650
Rp651
(dp652
g92
I58
sg93
I220
sg94
I40
sg95
g284
sg99
I1508
sbasbag0
(g19
g2
Ntp653
Rp654
(dp655
g23
g78
sg29
(lp656
g0
(g19
g2
Ntp657
Rp658
(dp659
g23
g85
sg29
(lp660
g0
(g87
g25
Vcrypto
p661
tp662
Rp663
(dp664
g92
I61
sg93
I222
sg94
I40
sg95
g98
sg99
I1511
sbasbag0
(g19
g2
Ntp665
Rp666
(dp667
g23
g85
sg29
(lp668
g0
(g87
g25
Vcrypto_iface
p669
tp670
Rp671
(dp672
g92
I68
sg93
I224
sg94
I40
sg95
g98
sg99
I1518
sbasbasbasbasbag0
(g19
g2
Ntp673
Rp674
(dp675
g23
g197
sg29
(lp676
g0
(g19
g2
Ntp677
Rp678
(dp679
g23
g204
sg29
(lp680
g0
(g19
g2
Ntp681
Rp682
(dp683
g23
g78
sg29
(lp684
g0
(g19
g2
Ntp685
Rp686
(dp687
g23
g85
sg29
(lp688
g0
(g87
g25
VseL4RPCCall
p689
tp690
Rp691
(dp692
g92
I14
sg93
I231
sg94
I41
sg95
g98
sg99
I1546
sbasbasbasbag0
(g19
g2
Ntp693
Rp694
(dp695
g23
g85
sg29
(lp696
g0
(g87
g25
Vconn6
p697
tp698
Rp699
(dp700
g92
I26
sg93
I233
sg94
I41
sg95
g98
sg99
I1558
sbasbag0
(g19
g2
Ntp701
Rp702
(dp703
g23
g231
sg29
(lp704
g0
(g19
g2
Ntp705
Rp706
(dp707
g23
g238
sg29
(lp708
g0
(g87
g25
Vfrom
p709
tp710
Rp711
(dp712
g92
I32
sg93
I235
sg94
I41
sg95
g246
sg99
I1564
sbasbag0
(g19
g2
Ntp713
Rp714
(dp715
g23
g78
sg29
(lp716
g0
(g19
g2
Ntp717
Rp718
(dp719
g23
g85
sg29
(lp720
g0
(g87
g25
Vsigntx
p721
tp722
Rp723
(dp724
g92
I37
sg93
I237
sg94
I41
sg95
g98
sg99
I1569
sbasbag0
(g19
g2
Ntp725
Rp726
(dp727
g23
g85
sg29
(lp728
g0
(g87
g25
Vmodchk_iface
p729
tp730
Rp731
(dp732
g92
I44
sg93
I239
sg94
I41
sg95
g98
sg99
I1576
sbasbasbasbag0
(g19
g2
Ntp733
Rp734
(dp735
g23
g231
sg29
(lp736
g0
(g19
g2
Ntp737
Rp738
(dp739
g23
g276
sg29
(lp740
g0
(g87
g25
Vto
p741
tp742
Rp743
(dp744
g92
I58
sg93
I242
sg94
I41
sg95
g284
sg99
I1590
sbasbag0
(g19
g2
Ntp745
Rp746
(dp747
g23
g78
sg29
(lp748
g0
(g19
g2
Ntp749
Rp750
(dp751
g23
g85
sg29
(lp752
g0
(g87
g25
Vmodchk
p753
tp754
Rp755
(dp756
g92
I61
sg93
I244
sg94
I41
sg95
g98
sg99
I1593
sbasbag0
(g19
g2
Ntp757
Rp758
(dp759
g23
g85
sg29
(lp760
g0
(g87
g25
Vmodchk_iface
p761
tp762
Rp763
(dp764
g92
I68
sg93
I246
sg94
I41
sg95
g98
sg99
I1600
sbasbasbasbasbag0
(g19
g2
Ntp765
Rp766
(dp767
g23
g197
sg29
(lp768
g0
(g19
g2
Ntp769
Rp770
(dp771
g23
g204
sg29
(lp772
g0
(g19
g2
Ntp773
Rp774
(dp775
g23
g78
sg29
(lp776
g0
(g19
g2
Ntp777
Rp778
(dp779
g23
g85
sg29
(lp780
g0
(g87
g25
VseL4RPCCall
p781
tp782
Rp783
(dp784
g92
I14
sg93
I256
sg94
I43
sg95
g98
sg99
I1678
sbasbasbasbag0
(g19
g2
Ntp785
Rp786
(dp787
g23
g85
sg29
(lp788
g0
(g87
g25
Vconn7
p789
tp790
Rp791
(dp792
g92
I26
sg93
I258
sg94
I43
sg95
g98
sg99
I1690
sbasbag0
(g19
g2
Ntp793
Rp794
(dp795
g23
g231
sg29
(lp796
g0
(g19
g2
Ntp797
Rp798
(dp799
g23
g238
sg29
(lp800
g0
(g87
g25
Vfrom
p801
tp802
Rp803
(dp804
g92
I32
sg93
I260
sg94
I43
sg95
g246
sg99
I1696
sbasbag0
(g19
g2
Ntp805
Rp806
(dp807
g23
g78
sg29
(lp808
g0
(g19
g2
Ntp809
Rp810
(dp811
g23
g85
sg29
(lp812
g0
(g87
g25
Vmodchk
p813
tp814
Rp815
(dp816
g92
I37
sg93
I262
sg94
I43
sg95
g98
sg99
I1701
sbasbag0
(g19
g2
Ntp817
Rp818
(dp819
g23
g85
sg29
(lp820
g0
(g87
g25
Vmodtx_iface
p821
tp822
Rp823
(dp824
g92
I44
sg93
I264
sg94
I43
sg95
g98
sg99
I1708
sbasbasbasbag0
(g19
g2
Ntp825
Rp826
(dp827
g23
g231
sg29
(lp828
g0
(g19
g2
Ntp829
Rp830
(dp831
g23
g276
sg29
(lp832
g0
(g87
g25
Vto
p833
tp834
Rp835
(dp836
g92
I57
sg93
I267
sg94
I43
sg95
g284
sg99
I1721
sbasbag0
(g19
g2
Ntp837
Rp838
(dp839
g23
g78
sg29
(lp840
g0
(g19
g2
Ntp841
Rp842
(dp843
g23
g85
sg29
(lp844
g0
(g87
g25
Vmodtx
p845
tp846
Rp847
(dp848
g92
I60
sg93
I269
sg94
I43
sg95
g98
sg99
I1724
sbasbag0
(g19
g2
Ntp849
Rp850
(dp851
g23
g85
sg29
(lp852
g0
(g87
g25
Vmodtx_iface
p853
tp854
Rp855
(dp856
g92
I66
sg93
I271
sg94
I43
sg95
g98
sg99
I1730
sbasbasbasbasbag0
(g19
g2
Ntp857
Rp858
(dp859
g23
g197
sg29
(lp860
g0
(g19
g2
Ntp861
Rp862
(dp863
g23
g204
sg29
(lp864
g0
(g19
g2
Ntp865
Rp866
(dp867
g23
g78
sg29
(lp868
g0
(g19
g2
Ntp869
Rp870
(dp871
g23
g85
sg29
(lp872
g0
(g87
g25
VseL4RPCCall
p873
tp874
Rp875
(dp876
g92
I14
sg93
I278
sg94
I44
sg95
g98
sg99
I1757
sbasbasbasbag0
(g19
g2
Ntp877
Rp878
(dp879
g23
g85
sg29
(lp880
g0
(g87
g25
Vconn8
p881
tp882
Rp883
(dp884
g92
I26
sg93
I280
sg94
I44
sg95
g98
sg99
I1769
sbasbag0
(g19
g2
Ntp885
Rp886
(dp887
g23
g231
sg29
(lp888
g0
(g19
g2
Ntp889
Rp890
(dp891
g23
g238
sg29
(lp892
g0
(g87
g25
Vfrom
p893
tp894
Rp895
(dp896
g92
I32
sg93
I282
sg94
I44
sg95
g246
sg99
I1775
sbasbag0
(g19
g2
Ntp897
Rp898
(dp899
g23
g78
sg29
(lp900
g0
(g19
g2
Ntp901
Rp902
(dp903
g23
g85
sg29
(lp904
g0
(g87
g25
Vmodchk
p905
tp906
Rp907
(dp908
g92
I37
sg93
I284
sg94
I44
sg95
g98
sg99
I1780
sbasbag0
(g19
g2
Ntp909
Rp910
(dp911
g23
g85
sg29
(lp912
g0
(g87
g25
Vsigntx_iface
p913
tp914
Rp915
(dp916
g92
I44
sg93
I286
sg94
I44
sg95
g98
sg99
I1787
sbasbasbasbag0
(g19
g2
Ntp917
Rp918
(dp919
g23
g231
sg29
(lp920
g0
(g19
g2
Ntp921
Rp922
(dp923
g23
g276
sg29
(lp924
g0
(g87
g25
Vto
p925
tp926
Rp927
(dp928
g92
I58
sg93
I289
sg94
I44
sg95
g284
sg99
I1801
sbasbag0
(g19
g2
Ntp929
Rp930
(dp931
g23
g78
sg29
(lp932
g0
(g19
g2
Ntp933
Rp934
(dp935
g23
g85
sg29
(lp936
g0
(g87
g25
Vsigntx
p937
tp938
Rp939
(dp940
g92
I61
sg93
I291
sg94
I44
sg95
g98
sg99
I1804
sbasbag0
(g19
g2
Ntp941
Rp942
(dp943
g23
g85
sg29
(lp944
g0
(g87
g25
Vsigntx_iface
p945
tp946
Rp947
(dp948
g92
I68
sg93
I293
sg94
I44
sg95
g98
sg99
I1811
sbasbasbasbasbasbasbasbag0
(g19
g2
Ntp949
Rp950
(dp951
g23
g0
(g24
g25
Vconfiguration_sing
p952
tp953
Rp954
sg29
(lp955
g0
(g19
g2
Ntp956
Rp957
(dp958
g23
g0
(g24
g25
Vconfiguration_decl
p959
tp960
Rp961
sg29
(lp962
g0
(g19
g2
Ntp963
Rp964
(dp965
g23
g0
(g24
g25
Vconfiguration_defn
p966
tp967
Rp968
sg29
(lp969
sbasbasbasbasbsS'_min_col'
p970
NsS'_max_col'
p971
NsS'_filename'
p972
S'/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/signing_device.camkes'
p973
sS'_lineno'
p974
NsS'full_source'
p975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p976
sbsS'_configuration'
p977
g0
(ccamkes.ast.objects
Configuration
p978
g2
Ntp979
Rp980
(dp981
g7
g0
(g13
g2
Ntp982
Rp983
(dp984
g17
I00
sg18
g964
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p985
sbsS'_settings'
p986
(tsS'_name'
p987
Nsg6
g11
sS'settings_dict'
p988
(dp989
sS'_mapping'
p990
ccollections
defaultdict
p991
(c__builtin__
dict
p992
tp993
Rp994
sS'_frozen'
p995
I01
sbsg987
Nsg6
g4
sS'_composition'
p996
g0
(ccamkes.ast.objects
Composition
p997
g2
Ntp998
Rp999
(dp1000
S'_groups'
p1001
(tsS'_exports'
p1002
(tsg7
g0
(g13
g2
Ntp1003
Rp1004
(dp1005
g17
I00
sg18
g46
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p1006
sbsg987
Nsg6
g11
sS'_instances'
p1007
(g0
(ccamkes.ast.objects
Instance
p1008
g2
Ntp1009
Rp1010
(dp1011
S'_type'
p1012
g0
(ccamkes.ast.objects
Component
p1013
g2
Ntp1014
Rp1015
(dp1016
S'_mutexes'
p1017
(tsS'_binary_semaphores'
p1018
(lp1019
sg7
g0
(g13
g2
Ntp1020
Rp1021
(dp1022
g17
I00
sg18
g0
(g19
g2
Ntp1023
Rp1024
(dp1025
g23
g0
(g24
g25
Vcomponent_decl
p1026
tp1027
Rp1028
sg29
(lp1029
g0
(g19
g2
Ntp1030
Rp1031
(dp1032
g23
g85
sg29
(lp1033
g0
(g87
g25
VCrypto
p1034
tp1035
Rp1036
(dp1037
g92
I11
sg93
I22
sg94
I7
sg95
g98
sg99
I166
sbasbag0
(g19
g2
Ntp1038
Rp1039
(dp1040
g23
g0
(g24
g25
Vcomponent_defn
p1041
tp1042
Rp1043
sg29
(lp1044
g0
(g19
g2
Ntp1045
Rp1046
(dp1047
g23
g0
(g24
g25
Vprovides
p1048
tp1049
Rp1050
sg29
(lp1051
g0
(g19
g2
Ntp1052
Rp1053
(dp1054
g23
g78
sg29
(lp1055
g0
(g19
g2
Ntp1056
Rp1057
(dp1058
g23
g85
sg29
(lp1059
g0
(g87
g25
VCryptoIface
p1060
tp1061
Rp1062
(dp1063
g92
I14
sg93
I32
sg94
I9
sg95
g98
sg99
I248
sbasbasbag0
(g19
g2
Ntp1064
Rp1065
(dp1066
g23
g85
sg29
(lp1067
g0
(g87
g25
Vcrypto_iface
p1068
tp1069
Rp1070
(dp1071
g92
I26
sg93
I34
sg94
I9
sg95
g98
sg99
I260
sbasbasbag0
(g19
g2
Ntp1072
Rp1073
(dp1074
g23
g0
(g24
g25
Vuses
p1075
tp1076
Rp1077
sg29
(lp1078
g0
(g19
g2
Ntp1079
Rp1080
(dp1081
g23
g78
sg29
(lp1082
g0
(g19
g2
Ntp1083
Rp1084
(dp1085
g23
g85
sg29
(lp1086
g0
(g87
g25
VModtxIface
p1087
tp1088
Rp1089
(dp1090
g92
I10
sg93
I42
sg94
I11
sg95
g98
sg99
I288
sbasbasbag0
(g19
g2
Ntp1091
Rp1092
(dp1093
g23
g85
sg29
(lp1094
g0
(g87
g25
Vmodtx_iface
p1095
tp1096
Rp1097
(dp1098
g92
I21
sg93
I44
sg94
I11
sg95
g98
sg99
I299
sbasbasbag0
(g19
g2
Ntp1099
Rp1100
(dp1101
g23
g1077
sg29
(lp1102
g0
(g19
g2
Ntp1103
Rp1104
(dp1105
g23
g78
sg29
(lp1106
g0
(g19
g2
Ntp1107
Rp1108
(dp1109
g23
g85
sg29
(lp1110
g0
(g87
g25
VSigntxIface
p1111
tp1112
Rp1113
(dp1114
g92
I10
sg93
I50
sg94
I12
sg95
g98
sg99
I321
sbasbasbag0
(g19
g2
Ntp1115
Rp1116
(dp1117
g23
g85
sg29
(lp1118
g0
(g87
g25
Vsigntx_iface
p1119
tp1120
Rp1121
(dp1122
g92
I22
sg93
I52
sg94
I12
sg95
g98
sg99
I333
sbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Crypto/Crypto.camkes
p1123
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Crypto {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides CryptoIface crypto_iface;\u000a    \u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a}\u000a
p1124
sbsg977
NsS'_emits'
p1125
(tsg996
NsS'_control'
p1126
I00
sS'_dataports'
p1127
(tsg987
g1036
sg6
g4
sS'_hardware'
p1128
I00
sS'_consumes'
p1129
(tsS'_provides'
p1130
(g0
(ccamkes.ast.objects
Provides
p1131
g2
Ntp1132
Rp1133
(dp1134
g6
g1015
sg1012
g0
(ccamkes.ast.objects
Procedure
p1135
g2
Ntp1136
Rp1137
(dp1138
g7
g0
(g13
g2
Ntp1139
Rp1140
(dp1141
g17
I00
sg18
g0
(g19
g2
Ntp1142
Rp1143
(dp1144
g23
g0
(g24
g25
Vprocedure_decl
p1145
tp1146
Rp1147
sg29
(lp1148
g0
(g19
g2
Ntp1149
Rp1150
(dp1151
g23
g85
sg29
(lp1152
g0
(g87
g25
VCryptoIface
p1153
tp1154
Rp1155
(dp1156
g92
I11
sg93
I6
sg94
I3
sg95
g98
sg99
I38
sbasbag0
(g19
g2
Ntp1157
Rp1158
(dp1159
g23
g0
(g24
g25
Vprocedure_defn
p1160
tp1161
Rp1162
sg29
(lp1163
g0
(g19
g2
Ntp1164
Rp1165
(dp1166
g23
g0
(g24
g25
Vmethod_decl
p1167
tp1168
Rp1169
sg29
(lp1170
g0
(g19
g2
Ntp1171
Rp1172
(dp1173
g23
g85
sg29
(lp1174
g0
(g87
g25
Vsign
p1175
tp1176
Rp1177
(dp1178
g92
I10
sg93
I13
sg94
I4
sg95
g98
sg99
I61
sbasbag0
(g19
g2
Ntp1179
Rp1180
(dp1181
g23
g0
(g24
g25
Vmethod_scalar_parameter
p1182
tp1183
Rp1184
sg29
(lp1185
g0
(g19
g2
Ntp1186
Rp1187
(dp1188
g23
g0
(g24
g25
Vdirection
p1189
tp1190
Rp1191
sg29
(lp1192
g0
(g87
g25
Vin
p1193
tp1194
Rp1195
(dp1196
g92
I15
sg93
I15
sg94
I4
sg95
g0
(g24
g25
VIN
p1197
tp1198
Rp1199
sg99
I66
sbasbag0
(g19
g2
Ntp1200
Rp1201
(dp1202
g23
g0
(g24
g25
Vtype
p1203
tp1204
Rp1205
sg29
(lp1206
g0
(g87
g25
Vstring
p1207
tp1208
Rp1209
(dp1210
g92
I18
sg93
I17
sg94
I4
sg95
g0
(g24
g25
VSTRING
p1211
tp1212
Rp1213
sg99
I69
sbasbag0
(g19
g2
Ntp1214
Rp1215
(dp1216
g23
g85
sg29
(lp1217
g0
(g87
g25
Vtext
p1218
tp1219
Rp1220
(dp1221
g92
I25
sg93
I19
sg94
I4
sg95
g98
sg99
I76
sbasbasbag0
(g19
g2
Ntp1222
Rp1223
(dp1224
g23
g1184
sg29
(lp1225
g0
(g19
g2
Ntp1226
Rp1227
(dp1228
g23
g1191
sg29
(lp1229
g0
(g87
g25
Vin
p1230
tp1231
Rp1232
(dp1233
g92
I31
sg93
I22
sg94
I4
sg95
g1199
sg99
I82
sbasbag0
(g19
g2
Ntp1234
Rp1235
(dp1236
g23
g1205
sg29
(lp1237
g0
(g19
g2
Ntp1238
Rp1239
(dp1240
g23
g0
(g24
g25
Vsigned_int
p1241
tp1242
Rp1243
sg29
(lp1244
g0
(g87
g25
Vint
p1245
tp1246
Rp1247
(dp1248
g92
I34
sg93
I24
sg94
I4
sg95
g0
(g24
g25
VINT
p1249
tp1250
Rp1251
sg99
I85
sbasbasbag0
(g19
g2
Ntp1252
Rp1253
(dp1254
g23
g85
sg29
(lp1255
g0
(g87
g25
Vid
p1256
tp1257
Rp1258
(dp1259
g92
I38
sg93
I26
sg94
I4
sg95
g98
sg99
I89
sbasbasbasbag0
(g19
g2
Ntp1260
Rp1261
(dp1262
g23
g1169
sg29
(lp1263
g0
(g19
g2
Ntp1264
Rp1265
(dp1266
g23
g85
sg29
(lp1267
g0
(g87
g25
Vverify
p1268
tp1269
Rp1270
(dp1271
g92
I10
sg93
I33
sg94
I5
sg95
g98
sg99
I103
sbasbag0
(g19
g2
Ntp1272
Rp1273
(dp1274
g23
g1184
sg29
(lp1275
g0
(g19
g2
Ntp1276
Rp1277
(dp1278
g23
g1191
sg29
(lp1279
g0
(g87
g25
Vin
p1280
tp1281
Rp1282
(dp1283
g92
I17
sg93
I35
sg94
I5
sg95
g1199
sg99
I110
sbasbag0
(g19
g2
Ntp1284
Rp1285
(dp1286
g23
g1205
sg29
(lp1287
g0
(g87
g25
Vstring
p1288
tp1289
Rp1290
(dp1291
g92
I20
sg93
I37
sg94
I5
sg95
g1213
sg99
I113
sbasbag0
(g19
g2
Ntp1292
Rp1293
(dp1294
g23
g85
sg29
(lp1295
g0
(g87
g25
Vtext
p1296
tp1297
Rp1298
(dp1299
g92
I27
sg93
I39
sg94
I5
sg95
g98
sg99
I120
sbasbasbag0
(g19
g2
Ntp1300
Rp1301
(dp1302
g23
g1184
sg29
(lp1303
g0
(g19
g2
Ntp1304
Rp1305
(dp1306
g23
g1191
sg29
(lp1307
g0
(g87
g25
Vin
p1308
tp1309
Rp1310
(dp1311
g92
I33
sg93
I42
sg94
I5
sg95
g1199
sg99
I126
sbasbag0
(g19
g2
Ntp1312
Rp1313
(dp1314
g23
g1205
sg29
(lp1315
g0
(g19
g2
Ntp1316
Rp1317
(dp1318
g23
g1243
sg29
(lp1319
g0
(g87
g25
Vint
p1320
tp1321
Rp1322
(dp1323
g92
I36
sg93
I44
sg94
I5
sg95
g1251
sg99
I129
sbasbasbag0
(g19
g2
Ntp1324
Rp1325
(dp1326
g23
g85
sg29
(lp1327
g0
(g87
g25
Vid
p1328
tp1329
Rp1330
(dp1331
g92
I40
sg93
I46
sg94
I5
sg95
g98
sg99
I133
sbasbasbag0
(g19
g2
Ntp1332
Rp1333
(dp1334
g23
g1184
sg29
(lp1335
g0
(g19
g2
Ntp1336
Rp1337
(dp1338
g23
g1191
sg29
(lp1339
g0
(g87
g25
Vin
p1340
tp1341
Rp1342
(dp1343
g92
I44
sg93
I49
sg94
I5
sg95
g1199
sg99
I137
sbasbag0
(g19
g2
Ntp1344
Rp1345
(dp1346
g23
g1205
sg29
(lp1347
g0
(g87
g25
Vstring
p1348
tp1349
Rp1350
(dp1351
g92
I47
sg93
I51
sg94
I5
sg95
g1213
sg99
I140
sbasbag0
(g19
g2
Ntp1352
Rp1353
(dp1354
g23
g85
sg29
(lp1355
g0
(g87
g25
Vhmac
p1356
tp1357
Rp1358
(dp1359
g92
I54
sg93
I53
sg94
I5
sg95
g98
sg99
I147
sbasbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/CryptoIface.idl4
p1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1361
sbsg987
g1155
sg6
g4
sS'_methods'
p1362
(lp1363
g0
(ccamkes.ast.objects
Method
p1364
g2
Ntp1365
Rp1366
(dp1367
S'_parameters'
p1368
(g0
(ccamkes.ast.objects
Parameter
p1369
g2
Ntp1370
Rp1371
(dp1372
g1012
Vstring
p1373
sg7
g0
(g13
g2
Ntp1374
Rp1375
(dp1376
g17
I00
sg18
g1180
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1377
sbsS'_array'
p1378
I00
sg987
g1220
sg6
g1366
sS'_direction'
p1379
g1195
sg995
I01
sbg0
(g1369
g2
Ntp1380
Rp1381
(dp1382
g1012
Vint
p1383
sg7
g0
(g13
g2
Ntp1384
Rp1385
(dp1386
g17
I00
sg18
g1223
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1387
sbsg1378
I00
sg987
g1258
sg6
g1366
sg1379
g1232
sg995
I01
sbtp1388
sg7
g0
(g13
g2
Ntp1389
Rp1390
(dp1391
g17
I00
sg18
g1165
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1392
sbsS'_return_type'
p1393
Nsg987
g1177
sg6
g1137
sg995
I01
sbag0
(g1364
g2
Ntp1394
Rp1395
(dp1396
g1368
(g0
(g1369
g2
Ntp1397
Rp1398
(dp1399
g1012
Vstring
p1400
sg7
g0
(g13
g2
Ntp1401
Rp1402
(dp1403
g17
I00
sg18
g1273
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1404
sbsg1378
I00
sg987
g1298
sg6
g1395
sg1379
g1282
sg995
I01
sbg0
(g1369
g2
Ntp1405
Rp1406
(dp1407
g1012
g1383
sg7
g0
(g13
g2
Ntp1408
Rp1409
(dp1410
g17
I00
sg18
g1301
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1411
sbsg1378
I00
sg987
g1330
sg6
g1395
sg1379
g1310
sg995
I01
sbg0
(g1369
g2
Ntp1412
Rp1413
(dp1414
g1012
Vstring
p1415
sg7
g0
(g13
g2
Ntp1416
Rp1417
(dp1418
g17
I00
sg18
g1333
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1419
sbsg1378
I00
sg987
g1358
sg6
g1395
sg1379
g1342
sg995
I01
sbtp1420
sg7
g0
(g13
g2
Ntp1421
Rp1422
(dp1423
g17
I00
sg18
g1261
sg970
Nsg971
Nsg972
g1360
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure CryptoIface {\u000a    void sign(in string text, in int id);\u000a    void verify(in string text, in int id, in string hmac);\u000a};\u000a
p1424
sbsg1393
Nsg987
g1270
sg6
g1137
sg995
I01
sbasS'_includes'
p1425
(lp1426
sg990
(dp1427
g1270
g1395
sg1177
g1366
ssS'_attributes'
p1428
(lp1429
sg995
I01
sbsg7
g0
(g13
g2
Ntp1430
Rp1431
(dp1432
g17
I00
sg18
g1046
sg970
Nsg971
Nsg972
g1123
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Crypto {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides CryptoIface crypto_iface;\u000a    \u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a}\u000a
p1433
sbsg995
I01
sg987
g1070
sbtp1434
sg1425
(tsg990
(dp1435
g1121
g0
(ccamkes.ast.objects
Uses
p1436
g2
Ntp1437
Rp1438
(dp1439
g1012
g0
(g1135
g2
Ntp1440
Rp1441
(dp1442
g7
g0
(g13
g2
Ntp1443
Rp1444
(dp1445
g17
I00
sg18
g0
(g19
g2
Ntp1446
Rp1447
(dp1448
g23
g1147
sg29
(lp1449
g0
(g19
g2
Ntp1450
Rp1451
(dp1452
g23
g85
sg29
(lp1453
g0
(g87
g25
VSigntxIface
p1454
tp1455
Rp1456
(dp1457
g92
I11
sg93
I6
sg94
I3
sg95
g98
sg99
I38
sbasbag0
(g19
g2
Ntp1458
Rp1459
(dp1460
g23
g1162
sg29
(lp1461
g0
(g19
g2
Ntp1462
Rp1463
(dp1464
g23
g1169
sg29
(lp1465
g0
(g19
g2
Ntp1466
Rp1467
(dp1468
g23
g85
sg29
(lp1469
g0
(g87
g25
Vprint_sign
p1470
tp1471
Rp1472
(dp1473
g92
I10
sg93
I13
sg94
I4
sg95
g98
sg99
I61
sbasbag0
(g19
g2
Ntp1474
Rp1475
(dp1476
g23
g1184
sg29
(lp1477
g0
(g19
g2
Ntp1478
Rp1479
(dp1480
g23
g1191
sg29
(lp1481
g0
(g87
g25
Vin
p1482
tp1483
Rp1484
(dp1485
g92
I21
sg93
I15
sg94
I4
sg95
g1199
sg99
I72
sbasbag0
(g19
g2
Ntp1486
Rp1487
(dp1488
g23
g1205
sg29
(lp1489
g0
(g87
g25
Vstring
p1490
tp1491
Rp1492
(dp1493
g92
I24
sg93
I17
sg94
I4
sg95
g1213
sg99
I75
sbasbag0
(g19
g2
Ntp1494
Rp1495
(dp1496
g23
g85
sg29
(lp1497
g0
(g87
g25
Vtext
p1498
tp1499
Rp1500
(dp1501
g92
I31
sg93
I19
sg94
I4
sg95
g98
sg99
I82
sbasbasbag0
(g19
g2
Ntp1502
Rp1503
(dp1504
g23
g1184
sg29
(lp1505
g0
(g19
g2
Ntp1506
Rp1507
(dp1508
g23
g1191
sg29
(lp1509
g0
(g87
g25
Vin
p1510
tp1511
Rp1512
(dp1513
g92
I37
sg93
I22
sg94
I4
sg95
g1199
sg99
I88
sbasbag0
(g19
g2
Ntp1514
Rp1515
(dp1516
g23
g1205
sg29
(lp1517
g0
(g87
g25
Vstring
p1518
tp1519
Rp1520
(dp1521
g92
I40
sg93
I24
sg94
I4
sg95
g1213
sg99
I91
sbasbag0
(g19
g2
Ntp1522
Rp1523
(dp1524
g23
g85
sg29
(lp1525
g0
(g87
g25
Vsource
p1526
tp1527
Rp1528
(dp1529
g92
I47
sg93
I26
sg94
I4
sg95
g98
sg99
I98
sbasbasbag0
(g19
g2
Ntp1530
Rp1531
(dp1532
g23
g1184
sg29
(lp1533
g0
(g19
g2
Ntp1534
Rp1535
(dp1536
g23
g1191
sg29
(lp1537
g0
(g87
g25
Vin
p1538
tp1539
Rp1540
(dp1541
g92
I55
sg93
I29
sg94
I4
sg95
g1199
sg99
I106
sbasbag0
(g19
g2
Ntp1542
Rp1543
(dp1544
g23
g1205
sg29
(lp1545
g0
(g19
g2
Ntp1546
Rp1547
(dp1548
g23
g1243
sg29
(lp1549
g0
(g87
g25
Vint
p1550
tp1551
Rp1552
(dp1553
g92
I58
sg93
I31
sg94
I4
sg95
g1251
sg99
I109
sbasbasbag0
(g19
g2
Ntp1554
Rp1555
(dp1556
g23
g85
sg29
(lp1557
g0
(g87
g25
Vid
p1558
tp1559
Rp1560
(dp1561
g92
I62
sg93
I33
sg94
I4
sg95
g98
sg99
I113
sbasbasbag0
(g19
g2
Ntp1562
Rp1563
(dp1564
g23
g1184
sg29
(lp1565
g0
(g19
g2
Ntp1566
Rp1567
(dp1568
g23
g1191
sg29
(lp1569
g0
(g87
g25
Vin
p1570
tp1571
Rp1572
(dp1573
g92
I66
sg93
I36
sg94
I4
sg95
g1199
sg99
I117
sbasbag0
(g19
g2
Ntp1574
Rp1575
(dp1576
g23
g1205
sg29
(lp1577
g0
(g19
g2
Ntp1578
Rp1579
(dp1580
g23
g1243
sg29
(lp1581
g0
(g87
g25
Vint
p1582
tp1583
Rp1584
(dp1585
g92
I69
sg93
I38
sg94
I4
sg95
g1251
sg99
I120
sbasbasbag0
(g19
g2
Ntp1586
Rp1587
(dp1588
g23
g85
sg29
(lp1589
g0
(g87
g25
VisValid
p1590
tp1591
Rp1592
(dp1593
g92
I73
sg93
I40
sg94
I4
sg95
g98
sg99
I124
sbasbasbag0
(g19
g2
Ntp1594
Rp1595
(dp1596
g23
g1184
sg29
(lp1597
g0
(g19
g2
Ntp1598
Rp1599
(dp1600
g23
g1191
sg29
(lp1601
g0
(g87
g25
Vin
p1602
tp1603
Rp1604
(dp1605
g92
I82
sg93
I43
sg94
I4
sg95
g1199
sg99
I133
sbasbag0
(g19
g2
Ntp1606
Rp1607
(dp1608
g23
g1205
sg29
(lp1609
g0
(g87
g25
Vstring
p1610
tp1611
Rp1612
(dp1613
g92
I85
sg93
I45
sg94
I4
sg95
g1213
sg99
I136
sbasbag0
(g19
g2
Ntp1614
Rp1615
(dp1616
g23
g85
sg29
(lp1617
g0
(g87
g25
Vhmac
p1618
tp1619
Rp1620
(dp1621
g92
I92
sg93
I47
sg94
I4
sg95
g98
sg99
I143
sbasbasbasbag0
(g19
g2
Ntp1622
Rp1623
(dp1624
g23
g1169
sg29
(lp1625
g0
(g19
g2
Ntp1626
Rp1627
(dp1628
g23
g85
sg29
(lp1629
g0
(g87
g25
Vprint_mod
p1630
tp1631
Rp1632
(dp1633
g92
I10
sg93
I54
sg94
I5
sg95
g98
sg99
I159
sbasbag0
(g19
g2
Ntp1634
Rp1635
(dp1636
g23
g1184
sg29
(lp1637
g0
(g19
g2
Ntp1638
Rp1639
(dp1640
g23
g1191
sg29
(lp1641
g0
(g87
g25
Vin
p1642
tp1643
Rp1644
(dp1645
g92
I20
sg93
I56
sg94
I5
sg95
g1199
sg99
I169
sbasbag0
(g19
g2
Ntp1646
Rp1647
(dp1648
g23
g1205
sg29
(lp1649
g0
(g87
g25
Vstring
p1650
tp1651
Rp1652
(dp1653
g92
I23
sg93
I58
sg94
I5
sg95
g1213
sg99
I172
sbasbag0
(g19
g2
Ntp1654
Rp1655
(dp1656
g23
g85
sg29
(lp1657
g0
(g87
g25
Vtext
p1658
tp1659
Rp1660
(dp1661
g92
I30
sg93
I60
sg94
I5
sg95
g98
sg99
I179
sbasbasbag0
(g19
g2
Ntp1662
Rp1663
(dp1664
g23
g1184
sg29
(lp1665
g0
(g19
g2
Ntp1666
Rp1667
(dp1668
g23
g1191
sg29
(lp1669
g0
(g87
g25
Vin
p1670
tp1671
Rp1672
(dp1673
g92
I36
sg93
I63
sg94
I5
sg95
g1199
sg99
I185
sbasbag0
(g19
g2
Ntp1674
Rp1675
(dp1676
g23
g1205
sg29
(lp1677
g0
(g87
g25
Vstring
p1678
tp1679
Rp1680
(dp1681
g92
I39
sg93
I65
sg94
I5
sg95
g1213
sg99
I188
sbasbag0
(g19
g2
Ntp1682
Rp1683
(dp1684
g23
g85
sg29
(lp1685
g0
(g87
g25
Vsource
p1686
tp1687
Rp1688
(dp1689
g92
I46
sg93
I67
sg94
I5
sg95
g98
sg99
I195
sbasbasbag0
(g19
g2
Ntp1690
Rp1691
(dp1692
g23
g1184
sg29
(lp1693
g0
(g19
g2
Ntp1694
Rp1695
(dp1696
g23
g1191
sg29
(lp1697
g0
(g87
g25
Vin
p1698
tp1699
Rp1700
(dp1701
g92
I54
sg93
I70
sg94
I5
sg95
g1199
sg99
I203
sbasbag0
(g19
g2
Ntp1702
Rp1703
(dp1704
g23
g1205
sg29
(lp1705
g0
(g19
g2
Ntp1706
Rp1707
(dp1708
g23
g1243
sg29
(lp1709
g0
(g87
g25
Vint
p1710
tp1711
Rp1712
(dp1713
g92
I57
sg93
I72
sg94
I5
sg95
g1251
sg99
I206
sbasbasbag0
(g19
g2
Ntp1714
Rp1715
(dp1716
g23
g85
sg29
(lp1717
g0
(g87
g25
Vid
p1718
tp1719
Rp1720
(dp1721
g92
I61
sg93
I74
sg94
I5
sg95
g98
sg99
I210
sbasbasbag0
(g19
g2
Ntp1722
Rp1723
(dp1724
g23
g1184
sg29
(lp1725
g0
(g19
g2
Ntp1726
Rp1727
(dp1728
g23
g1191
sg29
(lp1729
g0
(g87
g25
Vin
p1730
tp1731
Rp1732
(dp1733
g92
I65
sg93
I77
sg94
I5
sg95
g1199
sg99
I214
sbasbag0
(g19
g2
Ntp1734
Rp1735
(dp1736
g23
g1205
sg29
(lp1737
g0
(g19
g2
Ntp1738
Rp1739
(dp1740
g23
g1243
sg29
(lp1741
g0
(g87
g25
Vint
p1742
tp1743
Rp1744
(dp1745
g92
I68
sg93
I79
sg94
I5
sg95
g1251
sg99
I217
sbasbasbag0
(g19
g2
Ntp1746
Rp1747
(dp1748
g23
g85
sg29
(lp1749
g0
(g87
g25
VisValid
p1750
tp1751
Rp1752
(dp1753
g92
I72
sg93
I81
sg94
I5
sg95
g98
sg99
I221
sbasbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/SigntxIface.idl4
p1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1755
sbsg987
g1456
sg6
g4
sg1362
(lp1756
g0
(g1364
g2
Ntp1757
Rp1758
(dp1759
g1368
(g0
(g1369
g2
Ntp1760
Rp1761
(dp1762
g1012
Vstring
p1763
sg7
g0
(g13
g2
Ntp1764
Rp1765
(dp1766
g17
I00
sg18
g1475
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1767
sbsg1378
I00
sg987
g1500
sg6
g1758
sg1379
g1484
sg995
I01
sbg0
(g1369
g2
Ntp1768
Rp1769
(dp1770
g1012
Vstring
p1771
sg7
g0
(g13
g2
Ntp1772
Rp1773
(dp1774
g17
I00
sg18
g1503
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1775
sbsg1378
I00
sg987
g1528
sg6
g1758
sg1379
g1512
sg995
I01
sbg0
(g1369
g2
Ntp1776
Rp1777
(dp1778
g1012
g1383
sg7
g0
(g13
g2
Ntp1779
Rp1780
(dp1781
g17
I00
sg18
g1531
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1782
sbsg1378
I00
sg987
g1560
sg6
g1758
sg1379
g1540
sg995
I01
sbg0
(g1369
g2
Ntp1783
Rp1784
(dp1785
g1012
g1383
sg7
g0
(g13
g2
Ntp1786
Rp1787
(dp1788
g17
I00
sg18
g1563
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1789
sbsg1378
I00
sg987
g1592
sg6
g1758
sg1379
g1572
sg995
I01
sbg0
(g1369
g2
Ntp1790
Rp1791
(dp1792
g1012
Vstring
p1793
sg7
g0
(g13
g2
Ntp1794
Rp1795
(dp1796
g17
I00
sg18
g1595
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1797
sbsg1378
I00
sg987
g1620
sg6
g1758
sg1379
g1604
sg995
I01
sbtp1798
sg7
g0
(g13
g2
Ntp1799
Rp1800
(dp1801
g17
I00
sg18
g1463
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1802
sbsg1393
Nsg987
g1472
sg6
g1441
sg995
I01
sbag0
(g1364
g2
Ntp1803
Rp1804
(dp1805
g1368
(g0
(g1369
g2
Ntp1806
Rp1807
(dp1808
g1012
Vstring
p1809
sg7
g0
(g13
g2
Ntp1810
Rp1811
(dp1812
g17
I00
sg18
g1635
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1813
sbsg1378
I00
sg987
g1660
sg6
g1804
sg1379
g1644
sg995
I01
sbg0
(g1369
g2
Ntp1814
Rp1815
(dp1816
g1012
Vstring
p1817
sg7
g0
(g13
g2
Ntp1818
Rp1819
(dp1820
g17
I00
sg18
g1663
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1821
sbsg1378
I00
sg987
g1688
sg6
g1804
sg1379
g1672
sg995
I01
sbg0
(g1369
g2
Ntp1822
Rp1823
(dp1824
g1012
g1383
sg7
g0
(g13
g2
Ntp1825
Rp1826
(dp1827
g17
I00
sg18
g1691
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1828
sbsg1378
I00
sg987
g1720
sg6
g1804
sg1379
g1700
sg995
I01
sbg0
(g1369
g2
Ntp1829
Rp1830
(dp1831
g1012
g1383
sg7
g0
(g13
g2
Ntp1832
Rp1833
(dp1834
g17
I00
sg18
g1723
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1835
sbsg1378
I00
sg987
g1752
sg6
g1804
sg1379
g1732
sg995
I01
sbtp1836
sg7
g0
(g13
g2
Ntp1837
Rp1838
(dp1839
g17
I00
sg18
g1623
sg970
Nsg971
Nsg972
g1754
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure SigntxIface {\u000a    void print_sign(in string text, in string source, in int id, in int isValid, in string hmac);\u000a    void print_mod(in string text, in string source, in int id, in int isValid);\u000a};\u000a\u000a
p1840
sbsg1393
Nsg987
g1632
sg6
g1441
sg995
I01
sbasg1425
(lp1841
sg990
(dp1842
g1472
g1758
sg1632
g1804
ssg1428
(lp1843
sg995
I01
sbsg7
g0
(g13
g2
Ntp1844
Rp1845
(dp1846
g17
I00
sg18
g1100
sg970
Nsg971
Nsg972
g1123
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Crypto {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides CryptoIface crypto_iface;\u000a    \u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a}\u000a
p1847
sbsg987
g1121
sg6
g1015
sS'_optional'
p1848
I00
sg995
I01
sbsg1097
g0
(g1436
g2
Ntp1849
Rp1850
(dp1851
g1012
g0
(g1135
g2
Ntp1852
Rp1853
(dp1854
g7
g0
(g13
g2
Ntp1855
Rp1856
(dp1857
g17
I00
sg18
g0
(g19
g2
Ntp1858
Rp1859
(dp1860
g23
g1147
sg29
(lp1861
g0
(g19
g2
Ntp1862
Rp1863
(dp1864
g23
g85
sg29
(lp1865
g0
(g87
g25
VModtxIface
p1866
tp1867
Rp1868
(dp1869
g92
I11
sg93
I6
sg94
I3
sg95
g98
sg99
I38
sbasbag0
(g19
g2
Ntp1870
Rp1871
(dp1872
g23
g1162
sg29
(lp1873
g0
(g19
g2
Ntp1874
Rp1875
(dp1876
g23
g1169
sg29
(lp1877
g0
(g19
g2
Ntp1878
Rp1879
(dp1880
g23
g85
sg29
(lp1881
g0
(g87
g25
Vprint
p1882
tp1883
Rp1884
(dp1885
g92
I10
sg93
I13
sg94
I4
sg95
g98
sg99
I60
sbasbag0
(g19
g2
Ntp1886
Rp1887
(dp1888
g23
g1184
sg29
(lp1889
g0
(g19
g2
Ntp1890
Rp1891
(dp1892
g23
g1191
sg29
(lp1893
g0
(g87
g25
Vin
p1894
tp1895
Rp1896
(dp1897
g92
I16
sg93
I15
sg94
I4
sg95
g1199
sg99
I66
sbasbag0
(g19
g2
Ntp1898
Rp1899
(dp1900
g23
g1205
sg29
(lp1901
g0
(g87
g25
Vstring
p1902
tp1903
Rp1904
(dp1905
g92
I19
sg93
I17
sg94
I4
sg95
g1213
sg99
I69
sbasbag0
(g19
g2
Ntp1906
Rp1907
(dp1908
g23
g85
sg29
(lp1909
g0
(g87
g25
Vtext
p1910
tp1911
Rp1912
(dp1913
g92
I26
sg93
I19
sg94
I4
sg95
g98
sg99
I76
sbasbasbag0
(g19
g2
Ntp1914
Rp1915
(dp1916
g23
g1184
sg29
(lp1917
g0
(g19
g2
Ntp1918
Rp1919
(dp1920
g23
g1191
sg29
(lp1921
g0
(g87
g25
Vin
p1922
tp1923
Rp1924
(dp1925
g92
I32
sg93
I22
sg94
I4
sg95
g1199
sg99
I82
sbasbag0
(g19
g2
Ntp1926
Rp1927
(dp1928
g23
g1205
sg29
(lp1929
g0
(g87
g25
Vstring
p1930
tp1931
Rp1932
(dp1933
g92
I35
sg93
I24
sg94
I4
sg95
g1213
sg99
I85
sbasbag0
(g19
g2
Ntp1934
Rp1935
(dp1936
g23
g85
sg29
(lp1937
g0
(g87
g25
Vsource
p1938
tp1939
Rp1940
(dp1941
g92
I42
sg93
I26
sg94
I4
sg95
g98
sg99
I92
sbasbasbag0
(g19
g2
Ntp1942
Rp1943
(dp1944
g23
g1184
sg29
(lp1945
g0
(g19
g2
Ntp1946
Rp1947
(dp1948
g23
g1191
sg29
(lp1949
g0
(g87
g25
Vin
p1950
tp1951
Rp1952
(dp1953
g92
I50
sg93
I29
sg94
I4
sg95
g1199
sg99
I100
sbasbag0
(g19
g2
Ntp1954
Rp1955
(dp1956
g23
g1205
sg29
(lp1957
g0
(g19
g2
Ntp1958
Rp1959
(dp1960
g23
g1243
sg29
(lp1961
g0
(g87
g25
Vint
p1962
tp1963
Rp1964
(dp1965
g92
I53
sg93
I31
sg94
I4
sg95
g1251
sg99
I103
sbasbasbag0
(g19
g2
Ntp1966
Rp1967
(dp1968
g23
g85
sg29
(lp1969
g0
(g87
g25
Vid
p1970
tp1971
Rp1972
(dp1973
g92
I57
sg93
I33
sg94
I4
sg95
g98
sg99
I107
sbasbasbag0
(g19
g2
Ntp1974
Rp1975
(dp1976
g23
g1184
sg29
(lp1977
g0
(g19
g2
Ntp1978
Rp1979
(dp1980
g23
g1191
sg29
(lp1981
g0
(g87
g25
Vin
p1982
tp1983
Rp1984
(dp1985
g92
I61
sg93
I36
sg94
I4
sg95
g1199
sg99
I111
sbasbag0
(g19
g2
Ntp1986
Rp1987
(dp1988
g23
g1205
sg29
(lp1989
g0
(g19
g2
Ntp1990
Rp1991
(dp1992
g23
g1243
sg29
(lp1993
g0
(g87
g25
Vint
p1994
tp1995
Rp1996
(dp1997
g92
I64
sg93
I38
sg94
I4
sg95
g1251
sg99
I114
sbasbasbag0
(g19
g2
Ntp1998
Rp1999
(dp2000
g23
g85
sg29
(lp2001
g0
(g87
g25
VisValid
p2002
tp2003
Rp2004
(dp2005
g92
I68
sg93
I40
sg94
I4
sg95
g98
sg99
I118
sbasbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/ModtxIface.idl4
p2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2007
sbsg987
g1868
sg6
g4
sg1362
(lp2008
g0
(g1364
g2
Ntp2009
Rp2010
(dp2011
g1368
(g0
(g1369
g2
Ntp2012
Rp2013
(dp2014
g1012
Vstring
p2015
sg7
g0
(g13
g2
Ntp2016
Rp2017
(dp2018
g17
I00
sg18
g1887
sg970
Nsg971
Nsg972
g2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2019
sbsg1378
I00
sg987
g1912
sg6
g2010
sg1379
g1896
sg995
I01
sbg0
(g1369
g2
Ntp2020
Rp2021
(dp2022
g1012
Vstring
p2023
sg7
g0
(g13
g2
Ntp2024
Rp2025
(dp2026
g17
I00
sg18
g1915
sg970
Nsg971
Nsg972
g2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2027
sbsg1378
I00
sg987
g1940
sg6
g2010
sg1379
g1924
sg995
I01
sbg0
(g1369
g2
Ntp2028
Rp2029
(dp2030
g1012
g1383
sg7
g0
(g13
g2
Ntp2031
Rp2032
(dp2033
g17
I00
sg18
g1943
sg970
Nsg971
Nsg972
g2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2034
sbsg1378
I00
sg987
g1972
sg6
g2010
sg1379
g1952
sg995
I01
sbg0
(g1369
g2
Ntp2035
Rp2036
(dp2037
g1012
g1383
sg7
g0
(g13
g2
Ntp2038
Rp2039
(dp2040
g17
I00
sg18
g1975
sg970
Nsg971
Nsg972
g2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2041
sbsg1378
I00
sg987
g2004
sg6
g2010
sg1379
g1984
sg995
I01
sbtp2042
sg7
g0
(g13
g2
Ntp2043
Rp2044
(dp2045
g17
I00
sg18
g1875
sg970
Nsg971
Nsg972
g2006
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModtxIface {\u000a    void print(in string text, in string source, in int id, in int isValid);\u000a};\u000a
p2046
sbsg1393
Nsg987
g1884
sg6
g1853
sg995
I01
sbasg1425
(lp2047
sg990
(dp2048
g1884
g2010
ssg1428
(lp2049
sg995
I01
sbsg7
g0
(g13
g2
Ntp2050
Rp2051
(dp2052
g17
I00
sg18
g1073
sg970
Nsg971
Nsg972
g1123
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Crypto {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides CryptoIface crypto_iface;\u000a    \u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a}\u000a
p2053
sbsg987
g1097
sg6
g1015
sg1848
I00
sg995
I01
sbsg1070
g1133
ssS'_uses'
p2054
(g1850
g1438
tp2055
sg1428
(tsS'_semaphores'
p2056
(tsg995
I01
sbsg7
g0
(g13
g2
Ntp2057
Rp2058
(dp2059
g17
I00
sg18
g60
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2060
sbsg987
g106
sg6
g999
sS'_address_space'
p2061
g106
sg995
I01
sbg0
(g1008
g2
Ntp2062
Rp2063
(dp2064
g1012
g0
(g1013
g2
Ntp2065
Rp2066
(dp2067
g1017
(tsg1018
(lp2068
sg7
g0
(g13
g2
Ntp2069
Rp2070
(dp2071
g17
I00
sg18
g0
(g19
g2
Ntp2072
Rp2073
(dp2074
g23
g1028
sg29
(lp2075
g0
(g19
g2
Ntp2076
Rp2077
(dp2078
g23
g85
sg29
(lp2079
g0
(g87
g25
VModchk
p2080
tp2081
Rp2082
(dp2083
g92
I11
sg93
I22
sg94
I7
sg95
g98
sg99
I166
sbasbag0
(g19
g2
Ntp2084
Rp2085
(dp2086
g23
g1043
sg29
(lp2087
g0
(g19
g2
Ntp2088
Rp2089
(dp2090
g23
g1050
sg29
(lp2091
g0
(g19
g2
Ntp2092
Rp2093
(dp2094
g23
g78
sg29
(lp2095
g0
(g19
g2
Ntp2096
Rp2097
(dp2098
g23
g85
sg29
(lp2099
g0
(g87
g25
VModchkIface
p2100
tp2101
Rp2102
(dp2103
g92
I14
sg93
I32
sg94
I9
sg95
g98
sg99
I248
sbasbasbag0
(g19
g2
Ntp2104
Rp2105
(dp2106
g23
g85
sg29
(lp2107
g0
(g87
g25
Vmodchk_iface
p2108
tp2109
Rp2110
(dp2111
g92
I26
sg93
I34
sg94
I9
sg95
g98
sg99
I260
sbasbasbag0
(g19
g2
Ntp2112
Rp2113
(dp2114
g23
g1077
sg29
(lp2115
g0
(g19
g2
Ntp2116
Rp2117
(dp2118
g23
g78
sg29
(lp2119
g0
(g19
g2
Ntp2120
Rp2121
(dp2122
g23
g85
sg29
(lp2123
g0
(g87
g25
VModtxIface
p2124
tp2125
Rp2126
(dp2127
g92
I10
sg93
I41
sg94
I11
sg95
g98
sg99
I284
sbasbasbag0
(g19
g2
Ntp2128
Rp2129
(dp2130
g23
g85
sg29
(lp2131
g0
(g87
g25
Vmodtx_iface
p2132
tp2133
Rp2134
(dp2135
g92
I21
sg93
I43
sg94
I11
sg95
g98
sg99
I295
sbasbasbag0
(g19
g2
Ntp2136
Rp2137
(dp2138
g23
g1077
sg29
(lp2139
g0
(g19
g2
Ntp2140
Rp2141
(dp2142
g23
g78
sg29
(lp2143
g0
(g19
g2
Ntp2144
Rp2145
(dp2146
g23
g85
sg29
(lp2147
g0
(g87
g25
VSigntxIface
p2148
tp2149
Rp2150
(dp2151
g92
I10
sg93
I49
sg94
I12
sg95
g98
sg99
I317
sbasbasbag0
(g19
g2
Ntp2152
Rp2153
(dp2154
g23
g85
sg29
(lp2155
g0
(g87
g25
Vsigntx_iface
p2156
tp2157
Rp2158
(dp2159
g92
I22
sg93
I51
sg94
I12
sg95
g98
sg99
I329
sbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Modchk/Modchk.camkes
p2160
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Modchk {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModchkIface modchk_iface;\u000a\u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a\u000a}\u000a
p2161
sbsg977
Nsg1125
(tsg996
Nsg1126
I00
sg1127
(tsg987
g2082
sg6
g4
sg1128
I00
sg1129
(tsg1130
(g0
(g1131
g2
Ntp2162
Rp2163
(dp2164
g6
g2066
sg1012
g0
(g1135
g2
Ntp2165
Rp2166
(dp2167
g7
g0
(g13
g2
Ntp2168
Rp2169
(dp2170
g17
I00
sg18
g0
(g19
g2
Ntp2171
Rp2172
(dp2173
g23
g1147
sg29
(lp2174
g0
(g19
g2
Ntp2175
Rp2176
(dp2177
g23
g85
sg29
(lp2178
g0
(g87
g25
VModchkIface
p2179
tp2180
Rp2181
(dp2182
g92
I11
sg93
I6
sg94
I3
sg95
g98
sg99
I38
sbasbag0
(g19
g2
Ntp2183
Rp2184
(dp2185
g23
g1162
sg29
(lp2186
g0
(g19
g2
Ntp2187
Rp2188
(dp2189
g23
g1169
sg29
(lp2190
g0
(g19
g2
Ntp2191
Rp2192
(dp2193
g23
g85
sg29
(lp2194
g0
(g87
g25
Vverify
p2195
tp2196
Rp2197
(dp2198
g92
I10
sg93
I14
sg94
I5
sg95
g98
sg99
I62
sbasbag0
(g19
g2
Ntp2199
Rp2200
(dp2201
g23
g1184
sg29
(lp2202
g0
(g19
g2
Ntp2203
Rp2204
(dp2205
g23
g1191
sg29
(lp2206
g0
(g87
g25
Vin
p2207
tp2208
Rp2209
(dp2210
g92
I17
sg93
I16
sg94
I5
sg95
g1199
sg99
I69
sbasbag0
(g19
g2
Ntp2211
Rp2212
(dp2213
g23
g1205
sg29
(lp2214
g0
(g87
g25
Vstring
p2215
tp2216
Rp2217
(dp2218
g92
I20
sg93
I18
sg94
I5
sg95
g1213
sg99
I72
sbasbag0
(g19
g2
Ntp2219
Rp2220
(dp2221
g23
g85
sg29
(lp2222
g0
(g87
g25
Vtext
p2223
tp2224
Rp2225
(dp2226
g92
I27
sg93
I20
sg94
I5
sg95
g98
sg99
I79
sbasbasbag0
(g19
g2
Ntp2227
Rp2228
(dp2229
g23
g1184
sg29
(lp2230
g0
(g19
g2
Ntp2231
Rp2232
(dp2233
g23
g1191
sg29
(lp2234
g0
(g87
g25
Vin
p2235
tp2236
Rp2237
(dp2238
g92
I33
sg93
I23
sg94
I5
sg95
g1199
sg99
I85
sbasbag0
(g19
g2
Ntp2239
Rp2240
(dp2241
g23
g1205
sg29
(lp2242
g0
(g87
g25
Vstring
p2243
tp2244
Rp2245
(dp2246
g92
I36
sg93
I25
sg94
I5
sg95
g1213
sg99
I88
sbasbag0
(g19
g2
Ntp2247
Rp2248
(dp2249
g23
g85
sg29
(lp2250
g0
(g87
g25
Vsource
p2251
tp2252
Rp2253
(dp2254
g92
I43
sg93
I27
sg94
I5
sg95
g98
sg99
I95
sbasbasbag0
(g19
g2
Ntp2255
Rp2256
(dp2257
g23
g1184
sg29
(lp2258
g0
(g19
g2
Ntp2259
Rp2260
(dp2261
g23
g1191
sg29
(lp2262
g0
(g87
g25
Vin
p2263
tp2264
Rp2265
(dp2266
g92
I51
sg93
I30
sg94
I5
sg95
g1199
sg99
I103
sbasbag0
(g19
g2
Ntp2267
Rp2268
(dp2269
g23
g1205
sg29
(lp2270
g0
(g19
g2
Ntp2271
Rp2272
(dp2273
g23
g1243
sg29
(lp2274
g0
(g87
g25
Vint
p2275
tp2276
Rp2277
(dp2278
g92
I54
sg93
I32
sg94
I5
sg95
g1251
sg99
I106
sbasbasbag0
(g19
g2
Ntp2279
Rp2280
(dp2281
g23
g85
sg29
(lp2282
g0
(g87
g25
Vid
p2283
tp2284
Rp2285
(dp2286
g92
I58
sg93
I34
sg94
I5
sg95
g98
sg99
I110
sbasbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/interfaces/ModchkIface.idl4
p2287
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModchkIface {\u000a\u000a    void verify(in string text, in string source, in int id);\u000a};\u000a\u000a
p2288
sbsg987
g2181
sg6
g4
sg1362
(lp2289
g0
(g1364
g2
Ntp2290
Rp2291
(dp2292
g1368
(g0
(g1369
g2
Ntp2293
Rp2294
(dp2295
g1012
Vstring
p2296
sg7
g0
(g13
g2
Ntp2297
Rp2298
(dp2299
g17
I00
sg18
g2200
sg970
Nsg971
Nsg972
g2287
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModchkIface {\u000a\u000a    void verify(in string text, in string source, in int id);\u000a};\u000a\u000a
p2300
sbsg1378
I00
sg987
g2225
sg6
g2291
sg1379
g2209
sg995
I01
sbg0
(g1369
g2
Ntp2301
Rp2302
(dp2303
g1012
Vstring
p2304
sg7
g0
(g13
g2
Ntp2305
Rp2306
(dp2307
g17
I00
sg18
g2228
sg970
Nsg971
Nsg972
g2287
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModchkIface {\u000a\u000a    void verify(in string text, in string source, in int id);\u000a};\u000a\u000a
p2308
sbsg1378
I00
sg987
g2253
sg6
g2291
sg1379
g2237
sg995
I01
sbg0
(g1369
g2
Ntp2309
Rp2310
(dp2311
g1012
g1383
sg7
g0
(g13
g2
Ntp2312
Rp2313
(dp2314
g17
I00
sg18
g2256
sg970
Nsg971
Nsg972
g2287
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModchkIface {\u000a\u000a    void verify(in string text, in string source, in int id);\u000a};\u000a\u000a
p2315
sbsg1378
I00
sg987
g2285
sg6
g2291
sg1379
g2265
sg995
I01
sbtp2316
sg7
g0
(g13
g2
Ntp2317
Rp2318
(dp2319
g17
I00
sg18
g2188
sg970
Nsg971
Nsg972
g2287
sg974
Nsg975
V/* Simple RPC interface */\u000a\u000aprocedure ModchkIface {\u000a\u000a    void verify(in string text, in string source, in int id);\u000a};\u000a\u000a
p2320
sbsg1393
Nsg987
g2197
sg6
g2166
sg995
I01
sbasg1425
(lp2321
sg990
(dp2322
g2197
g2291
ssg1428
(lp2323
sg995
I01
sbsg7
g0
(g13
g2
Ntp2324
Rp2325
(dp2326
g17
I00
sg18
g2089
sg970
Nsg971
Nsg972
g2160
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Modchk {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModchkIface modchk_iface;\u000a\u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a\u000a}\u000a
p2327
sbsg995
I01
sg987
g2110
sbtp2328
sg1425
(tsg990
(dp2329
g2158
g0
(g1436
g2
Ntp2330
Rp2331
(dp2332
g1012
g1441
sg7
g0
(g13
g2
Ntp2333
Rp2334
(dp2335
g17
I00
sg18
g2137
sg970
Nsg971
Nsg972
g2160
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Modchk {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModchkIface modchk_iface;\u000a\u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a\u000a}\u000a
p2336
sbsg987
g2158
sg6
g2066
sg1848
I00
sg995
I01
sbsg2134
g0
(g1436
g2
Ntp2337
Rp2338
(dp2339
g1012
g1853
sg7
g0
(g13
g2
Ntp2340
Rp2341
(dp2342
g17
I00
sg18
g2113
sg970
Nsg971
Nsg972
g2160
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Modchk {\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModchkIface modchk_iface;\u000a\u000a    uses ModtxIface modtx_iface;\u000a    uses SigntxIface signtx_iface;\u000a\u000a}\u000a
p2343
sbsg987
g2134
sg6
g2066
sg1848
I00
sg995
I01
sbsg2110
g2163
ssg2054
(g2338
g2331
tp2344
sg1428
(tsg2056
(tsg995
I01
sbsg7
g0
(g13
g2
Ntp2345
Rp2346
(dp2347
g17
I00
sg18
g109
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2348
sbsg987
g134
sg6
g999
sg2061
g134
sg995
I01
sbg0
(g1008
g2
Ntp2349
Rp2350
(dp2351
g1012
g0
(g1013
g2
Ntp2352
Rp2353
(dp2354
g1017
(tsg1018
(lp2355
sg7
g0
(g13
g2
Ntp2356
Rp2357
(dp2358
g17
I00
sg18
g0
(g19
g2
Ntp2359
Rp2360
(dp2361
g23
g1028
sg29
(lp2362
g0
(g19
g2
Ntp2363
Rp2364
(dp2365
g23
g85
sg29
(lp2366
g0
(g87
g25
VModtx
p2367
tp2368
Rp2369
(dp2370
g92
I11
sg93
I24
sg94
I8
sg95
g98
sg99
I185
sbasbag0
(g19
g2
Ntp2371
Rp2372
(dp2373
g23
g1043
sg29
(lp2374
g0
(g19
g2
Ntp2375
Rp2376
(dp2377
g23
g0
(g24
g25
Vcontrol
p2378
tp2379
Rp2380
sg29
(lp2381
sbag0
(g19
g2
Ntp2382
Rp2383
(dp2384
g23
g1050
sg29
(lp2385
g0
(g19
g2
Ntp2386
Rp2387
(dp2388
g23
g78
sg29
(lp2389
g0
(g19
g2
Ntp2390
Rp2391
(dp2392
g23
g85
sg29
(lp2393
g0
(g87
g25
VModtxIface
p2394
tp2395
Rp2396
(dp2397
g92
I14
sg93
I39
sg94
I12
sg95
g98
sg99
I280
sbasbasbag0
(g19
g2
Ntp2398
Rp2399
(dp2400
g23
g85
sg29
(lp2401
g0
(g87
g25
Vmodtx_iface
p2402
tp2403
Rp2404
(dp2405
g92
I25
sg93
I41
sg94
I12
sg95
g98
sg99
I291
sbasbasbag0
(g19
g2
Ntp2406
Rp2407
(dp2408
g23
g1077
sg29
(lp2409
g0
(g19
g2
Ntp2410
Rp2411
(dp2412
g23
g78
sg29
(lp2413
g0
(g19
g2
Ntp2414
Rp2415
(dp2416
g23
g85
sg29
(lp2417
g0
(g87
g25
VModchkIface
p2418
tp2419
Rp2420
(dp2421
g92
I10
sg93
I48
sg94
I14
sg95
g98
sg99
I314
sbasbasbag0
(g19
g2
Ntp2422
Rp2423
(dp2424
g23
g85
sg29
(lp2425
g0
(g87
g25
Vmodchk_iface
p2426
tp2427
Rp2428
(dp2429
g92
I22
sg93
I50
sg94
I14
sg95
g98
sg99
I326
sbasbasbag0
(g19
g2
Ntp2430
Rp2431
(dp2432
g23
g1077
sg29
(lp2433
g0
(g19
g2
Ntp2434
Rp2435
(dp2436
g23
g78
sg29
(lp2437
g0
(g19
g2
Ntp2438
Rp2439
(dp2440
g23
g85
sg29
(lp2441
g0
(g87
g25
VCryptoIface
p2442
tp2443
Rp2444
(dp2445
g92
I10
sg93
I56
sg94
I15
sg95
g98
sg99
I349
sbasbasbag0
(g19
g2
Ntp2446
Rp2447
(dp2448
g23
g85
sg29
(lp2449
g0
(g87
g25
Vcrypto_iface
p2450
tp2451
Rp2452
(dp2453
g92
I22
sg93
I58
sg94
I15
sg95
g98
sg99
I361
sbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Modtx/Modtx.camkes
p2454
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a/* Modtx.camkes */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000a\u000acomponent Modtx {\u000a\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModtxIface modtx_iface;\u000a\u000a    uses ModchkIface modchk_iface;\u000a    uses CryptoIface crypto_iface;\u000a\u000a}\u000a
p2455
sbsg977
Nsg1125
(tsg996
Nsg1126
I01
sg1127
(tsg987
g2369
sg6
g4
sg1128
I00
sg1129
(tsg1130
(g0
(g1131
g2
Ntp2456
Rp2457
(dp2458
g6
g2353
sg1012
g1853
sg7
g0
(g13
g2
Ntp2459
Rp2460
(dp2461
g17
I00
sg18
g2383
sg970
Nsg971
Nsg972
g2454
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a/* Modtx.camkes */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000a\u000acomponent Modtx {\u000a\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModtxIface modtx_iface;\u000a\u000a    uses ModchkIface modchk_iface;\u000a    uses CryptoIface crypto_iface;\u000a\u000a}\u000a
p2462
sbsg995
I01
sg987
g2404
sbtp2463
sg1425
(tsg990
(dp2464
g2452
g0
(g1436
g2
Ntp2465
Rp2466
(dp2467
g1012
g1137
sg7
g0
(g13
g2
Ntp2468
Rp2469
(dp2470
g17
I00
sg18
g2431
sg970
Nsg971
Nsg972
g2454
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a/* Modtx.camkes */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000a\u000acomponent Modtx {\u000a\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModtxIface modtx_iface;\u000a\u000a    uses ModchkIface modchk_iface;\u000a    uses CryptoIface crypto_iface;\u000a\u000a}\u000a
p2471
sbsg987
g2452
sg6
g2353
sg1848
I00
sg995
I01
sbsg2404
g2457
sg2428
g0
(g1436
g2
Ntp2472
Rp2473
(dp2474
g1012
g2166
sg7
g0
(g13
g2
Ntp2475
Rp2476
(dp2477
g17
I00
sg18
g2407
sg970
Nsg971
Nsg972
g2454
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a/* Modtx.camkes */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/ModtxIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000a\u000acomponent Modtx {\u000a\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides ModtxIface modtx_iface;\u000a\u000a    uses ModchkIface modchk_iface;\u000a    uses CryptoIface crypto_iface;\u000a\u000a}\u000a
p2478
sbsg987
g2428
sg6
g2353
sg1848
I00
sg995
I01
sbssg2054
(g2473
g2466
tp2479
sg1428
(tsg2056
(tsg995
I01
sbsg7
g0
(g13
g2
Ntp2480
Rp2481
(dp2482
g17
I00
sg18
g137
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2483
sbsg987
g162
sg6
g999
sg2061
g162
sg995
I01
sbg0
(g1008
g2
Ntp2484
Rp2485
(dp2486
g1012
g0
(g1013
g2
Ntp2487
Rp2488
(dp2489
g1017
(tsg1018
(lp2490
sg7
g0
(g13
g2
Ntp2491
Rp2492
(dp2493
g17
I00
sg18
g0
(g19
g2
Ntp2494
Rp2495
(dp2496
g23
g1028
sg29
(lp2497
g0
(g19
g2
Ntp2498
Rp2499
(dp2500
g23
g85
sg29
(lp2501
g0
(g87
g25
VSigntx
p2502
tp2503
Rp2504
(dp2505
g92
I11
sg93
I22
sg94
I7
sg95
g98
sg99
I167
sbasbag0
(g19
g2
Ntp2506
Rp2507
(dp2508
g23
g1043
sg29
(lp2509
g0
(g19
g2
Ntp2510
Rp2511
(dp2512
g23
g2380
sg29
(lp2513
sbag0
(g19
g2
Ntp2514
Rp2515
(dp2516
g23
g1050
sg29
(lp2517
g0
(g19
g2
Ntp2518
Rp2519
(dp2520
g23
g78
sg29
(lp2521
g0
(g19
g2
Ntp2522
Rp2523
(dp2524
g23
g85
sg29
(lp2525
g0
(g87
g25
VSigntxIface
p2526
tp2527
Rp2528
(dp2529
g92
I14
sg93
I36
sg94
I10
sg95
g98
sg99
I262
sbasbasbag0
(g19
g2
Ntp2530
Rp2531
(dp2532
g23
g85
sg29
(lp2533
g0
(g87
g25
Vsigntx_iface
p2534
tp2535
Rp2536
(dp2537
g92
I26
sg93
I38
sg94
I10
sg95
g98
sg99
I274
sbasbasbag0
(g19
g2
Ntp2538
Rp2539
(dp2540
g23
g1077
sg29
(lp2541
g0
(g19
g2
Ntp2542
Rp2543
(dp2544
g23
g78
sg29
(lp2545
g0
(g19
g2
Ntp2546
Rp2547
(dp2548
g23
g85
sg29
(lp2549
g0
(g87
g25
VCryptoIface
p2550
tp2551
Rp2552
(dp2553
g92
I10
sg93
I45
sg94
I12
sg95
g98
sg99
I298
sbasbasbag0
(g19
g2
Ntp2554
Rp2555
(dp2556
g23
g85
sg29
(lp2557
g0
(g87
g25
Vcrypto_iface
p2558
tp2559
Rp2560
(dp2561
g92
I22
sg93
I47
sg94
I12
sg95
g98
sg99
I310
sbasbasbag0
(g19
g2
Ntp2562
Rp2563
(dp2564
g23
g1077
sg29
(lp2565
g0
(g19
g2
Ntp2566
Rp2567
(dp2568
g23
g78
sg29
(lp2569
g0
(g19
g2
Ntp2570
Rp2571
(dp2572
g23
g85
sg29
(lp2573
g0
(g87
g25
VModchkIface
p2574
tp2575
Rp2576
(dp2577
g92
I10
sg93
I53
sg94
I13
sg95
g98
sg99
I333
sbasbasbag0
(g19
g2
Ntp2578
Rp2579
(dp2580
g23
g85
sg29
(lp2581
g0
(g87
g25
Vmodchk_iface
p2582
tp2583
Rp2584
(dp2585
g92
I22
sg93
I55
sg94
I13
sg95
g98
sg99
I345
sbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/hello-camkes-1/components/Signtx/Signtx.camkes
p2586
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Signtx {\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides SigntxIface signtx_iface;\u000a\u000a    uses CryptoIface crypto_iface;\u000a    uses ModchkIface modchk_iface;\u000a\u000a}\u000a
p2587
sbsg977
Nsg1125
(tsg996
Nsg1126
I01
sg1127
(tsg987
g2504
sg6
g4
sg1128
I00
sg1129
(tsg1130
(g0
(g1131
g2
Ntp2588
Rp2589
(dp2590
g6
g2488
sg1012
g1441
sg7
g0
(g13
g2
Ntp2591
Rp2592
(dp2593
g17
I00
sg18
g2515
sg970
Nsg971
Nsg972
g2586
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Signtx {\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides SigntxIface signtx_iface;\u000a\u000a    uses CryptoIface crypto_iface;\u000a    uses ModchkIface modchk_iface;\u000a\u000a}\u000a
p2594
sbsg995
I01
sg987
g2536
sbtp2595
sg1425
(tsg990
(dp2596
g2536
g2589
sg2560
g0
(g1436
g2
Ntp2597
Rp2598
(dp2599
g1012
g1137
sg7
g0
(g13
g2
Ntp2600
Rp2601
(dp2602
g17
I00
sg18
g2539
sg970
Nsg971
Nsg972
g2586
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Signtx {\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides SigntxIface signtx_iface;\u000a\u000a    uses CryptoIface crypto_iface;\u000a    uses ModchkIface modchk_iface;\u000a\u000a}\u000a
p2603
sbsg987
g2560
sg6
g2488
sg1848
I00
sg995
I01
sbsg2584
g0
(g1436
g2
Ntp2604
Rp2605
(dp2606
g1012
g2166
sg7
g0
(g13
g2
Ntp2607
Rp2608
(dp2609
g17
I00
sg18
g2563
sg970
Nsg971
Nsg972
g2586
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000aimport "../../interfaces/ModchkIface.idl4";\u000aimport "../../interfaces/CryptoIface.idl4";\u000aimport "../../interfaces/SigntxIface.idl4";\u000a\u000acomponent Signtx {\u000a    control;\u000a    /* include definitions of typedefs for the dataports */\u000a    provides SigntxIface signtx_iface;\u000a\u000a    uses CryptoIface crypto_iface;\u000a    uses ModchkIface modchk_iface;\u000a\u000a}\u000a
p2610
sbsg987
g2584
sg6
g2488
sg1848
I00
sg995
I01
sbssg2054
(g2598
g2605
tp2611
sg1428
(tsg2056
(tsg995
I01
sbsg7
g0
(g13
g2
Ntp2612
Rp2613
(dp2614
g17
I00
sg18
g165
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2615
sbsg987
g190
sg6
g999
sg2061
g190
sg995
I01
sbtp2616
sS'_connections'
p2617
(g0
(ccamkes.ast.objects
Connection
p2618
g2
Ntp2619
Rp2620
(dp2621
g1012
g0
(ccamkes.ast.objects
Connector
p2622
g2
Ntp2623
Rp2624
(dp2625
g7
g0
(g13
g2
Ntp2626
Rp2627
(dp2628
g17
I00
sg18
g0
(g19
g2
Ntp2629
Rp2630
(dp2631
g23
g0
(g24
g25
Vconnector_decl
p2632
tp2633
Rp2634
sg29
(lp2635
g0
(g19
g2
Ntp2636
Rp2637
(dp2638
g23
g85
sg29
(lp2639
g0
(g87
g25
VseL4RPCCall
p2640
tp2641
Rp2642
(dp2643
g92
I11
sg93
I179
sg94
I94
sg95
g98
sg99
I2942
sbasbag0
(g19
g2
Ntp2644
Rp2645
(dp2646
g23
g0
(g24
g25
Vconnector_defn
p2647
tp2648
Rp2649
sg29
(lp2650
g0
(g19
g2
Ntp2651
Rp2652
(dp2653
g23
g0
(g24
g25
Vconnector_end_type
p2654
tp2655
Rp2656
sg29
(lp2657
g0
(g87
g25
VProcedures
p2658
tp2659
Rp2660
(dp2661
g92
I10
sg93
I186
sg94
I95
sg95
g0
(g24
g25
VPROCEDURES_TYPE
p2662
tp2663
Rp2664
sg99
I2965
sbasbag0
(g19
g2
Ntp2665
Rp2666
(dp2667
g23
g0
(g24
g25
Vprecedence11
p2668
tp2669
Rp2670
sg29
(lp2671
g0
(g19
g2
Ntp2672
Rp2673
(dp2674
g23
g0
(g24
g25
Vprecedence10
p2675
tp2676
Rp2677
sg29
(lp2678
g0
(g19
g2
Ntp2679
Rp2680
(dp2681
g23
g0
(g24
g25
Vprecedence9
p2682
tp2683
Rp2684
sg29
(lp2685
g0
(g19
g2
Ntp2686
Rp2687
(dp2688
g23
g0
(g24
g25
Vprecedence8
p2689
tp2690
Rp2691
sg29
(lp2692
g0
(g19
g2
Ntp2693
Rp2694
(dp2695
g23
g0
(g24
g25
Vprecedence7
p2696
tp2697
Rp2698
sg29
(lp2699
g0
(g19
g2
Ntp2700
Rp2701
(dp2702
g23
g0
(g24
g25
Vprecedence6
p2703
tp2704
Rp2705
sg29
(lp2706
g0
(g19
g2
Ntp2707
Rp2708
(dp2709
g23
g0
(g24
g25
Vprecedence5
p2710
tp2711
Rp2712
sg29
(lp2713
g0
(g19
g2
Ntp2714
Rp2715
(dp2716
g23
g0
(g24
g25
Vprecedence4
p2717
tp2718
Rp2719
sg29
(lp2720
g0
(g19
g2
Ntp2721
Rp2722
(dp2723
g23
g0
(g24
g25
Vprecedence3
p2724
tp2725
Rp2726
sg29
(lp2727
g0
(g19
g2
Ntp2728
Rp2729
(dp2730
g23
g0
(g24
g25
Vprecedence2
p2731
tp2732
Rp2733
sg29
(lp2734
g0
(g19
g2
Ntp2735
Rp2736
(dp2737
g23
g0
(g24
g25
Vprecedence1
p2738
tp2739
Rp2740
sg29
(lp2741
g0
(g19
g2
Ntp2742
Rp2743
(dp2744
g23
g0
(g24
g25
Vnumber
p2745
tp2746
Rp2747
sg29
(lp2748
g0
(g87
g25
V0
p2749
tp2750
Rp2751
(dp2752
g92
I26
sg93
I190
sg94
I95
sg95
S'_ANON_35'
p2753
sg99
I2981
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp2754
Rp2755
(dp2756
g23
g2656
sg29
(lp2757
g0
(g87
g25
VProcedure
p2758
tp2759
Rp2760
(dp2761
g92
I8
sg93
I198
sg94
I96
sg95
g0
(g24
g25
VPROCEDURE_TYPE
p2762
tp2763
Rp2764
sg99
I2999
sbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/std_connector.camkes
p2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p2766
sbsS'_from_hardware'
p2767
I00
sg1428
(lp2768
sS'_from_threads'
p2769
I0
sg987
g2642
sg6
g4
sS'_from_multiple'
p2770
I01
sS'_to_type'
p2771
VProcedure
p2772
sS'_to_threads'
p2773
I1
sS'_from_template'
p2774
NsS'_from_type'
p2775
g2772
sS'_to_template'
p2776
NsS'_to_multiple'
p2777
I00
sS'_to_hardware'
p2778
I00
sg995
I01
sbsg7
NsS'_from_ends'
p2779
(g0
(ccamkes.ast.objects
ConnectionEnd
p2780
g2
Ntp2781
Rp2782
(dp2783
g6
g2620
sS'_interface'
p2784
g2466
sg7
g0
(g13
g2
Ntp2785
Rp2786
(dp2787
g17
I00
sg18
g334
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2788
sbsS'_instance'
p2789
g2350
sS'_end'
p2790
Vfrom
p2791
sg995
I01
sbg0
(g2780
g2
Ntp2792
Rp2793
(dp2794
g6
g2620
sg2784
g2598
sg7
g0
(g13
g2
Ntp2795
Rp2796
(dp2797
g17
I00
sg18
g610
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2798
sbsg2789
g2485
sg2790
g2791
sg995
I01
sbtp2799
sg987
Vconn2.conn5
p2800
sg6
NsS'_to_ends'
p2801
(g0
(g2780
g2
Ntp2802
Rp2803
(dp2804
g6
g2620
sg2784
g1133
sg7
g0
(g13
g2
Ntp2805
Rp2806
(dp2807
g17
I00
sg18
g366
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2808
sbsg2789
g1010
sg2790
Vto
p2809
sg995
I01
sbtp2810
sg995
I01
sbg0
(g2618
g2
Ntp2811
Rp2812
(dp2813
g1012
g2624
sg7
Nsg2779
(g0
(g2780
g2
Ntp2814
Rp2815
(dp2816
g6
g2812
sg2784
g2473
sg7
g0
(g13
g2
Ntp2817
Rp2818
(dp2819
g17
I00
sg18
g227
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2820
sbsg2789
g2350
sg2790
g2791
sg995
I01
sbg0
(g2780
g2
Ntp2821
Rp2822
(dp2823
g6
g2812
sg2784
g2605
sg7
g0
(g13
g2
Ntp2824
Rp2825
(dp2826
g17
I00
sg18
g702
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2827
sbsg2789
g2485
sg2790
g2791
sg995
I01
sbtp2828
sg987
Vconn1.conn6
p2829
sg6
Nsg2801
(g0
(g2780
g2
Ntp2830
Rp2831
(dp2832
g6
g2812
sg2784
g2163
sg7
g0
(g13
g2
Ntp2833
Rp2834
(dp2835
g17
I00
sg18
g268
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2836
sbsg2789
g2063
sg2790
g2809
sg995
I01
sbtp2837
sg995
I01
sbg0
(g2618
g2
Ntp2838
Rp2839
(dp2840
g1012
g2624
sg7
Nsg2779
(g0
(g2780
g2
Ntp2841
Rp2842
(dp2843
g6
g2839
sg2784
g1850
sg7
g0
(g13
g2
Ntp2844
Rp2845
(dp2846
g17
I00
sg18
g426
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2847
sbsg2789
g1010
sg2790
g2791
sg995
I01
sbg0
(g2780
g2
Ntp2848
Rp2849
(dp2850
g6
g2839
sg2784
g2338
sg7
g0
(g13
g2
Ntp2851
Rp2852
(dp2853
g17
I00
sg18
g794
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2854
sbsg2789
g2063
sg2790
g2791
sg995
I01
sbtp2855
sg987
Vconn3.conn7
p2856
sg6
Nsg2801
(g0
(g2780
g2
Ntp2857
Rp2858
(dp2859
g6
g2839
sg2784
g2457
sg7
g0
(g13
g2
Ntp2860
Rp2861
(dp2862
g17
I00
sg18
g458
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2863
sbsg2789
g2350
sg2790
g2809
sg995
I01
sbtp2864
sg995
I01
sbg0
(g2618
g2
Ntp2865
Rp2866
(dp2867
g1012
g2624
sg7
Nsg2779
(g0
(g2780
g2
Ntp2868
Rp2869
(dp2870
g6
g2866
sg2784
g1438
sg7
g0
(g13
g2
Ntp2871
Rp2872
(dp2873
g17
I00
sg18
g518
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2874
sbsg2789
g1010
sg2790
g2791
sg995
I01
sbg0
(g2780
g2
Ntp2875
Rp2876
(dp2877
g6
g2866
sg2784
g2331
sg7
g0
(g13
g2
Ntp2878
Rp2879
(dp2880
g17
I00
sg18
g886
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2881
sbsg2789
g2063
sg2790
g2791
sg995
I01
sbtp2882
sg987
Vconn4.conn8
p2883
sg6
Nsg2801
(g0
(g2780
g2
Ntp2884
Rp2885
(dp2886
g6
g2866
sg2784
g2589
sg7
g0
(g13
g2
Ntp2887
Rp2888
(dp2889
g17
I00
sg18
g550
sg970
Nsg971
Nsg972
g973
sg974
Nsg975
V/* @TAG(DATA61_BSD) */\u000a\u000a/*\u000a * CAmkES for signing device\u000a */\u000a\u000aimport <std_connector.camkes>;\u000aimport "interfaces/ModtxIface.idl4";\u000aimport "interfaces/SigntxIface.idl4";\u000aimport "interfaces/CryptoIface.idl4";\u000aimport "interfaces/ModchkIface.idl4";\u000a\u000a/* import component defintions */\u000aimport "components/Modtx/Modtx.camkes";\u000aimport "components/Crypto/Crypto.camkes";\u000aimport "components/Modchk/Modchk.camkes";\u000aimport "components/Signtx/Signtx.camkes";\u000a\u000aassembly {\u000a    composition {\u000a        /* component instances */\u000a        component Crypto crypto;\u000a        component Modchk modchk;\u000a        component Modtx modtx;\u000a        component Signtx signtx;\u000a\u000a        /* TASK 5: Event connections */\u000a        /* hint 1: connect each "emits" interface in a component to the "consumes" interface in the other\u000a         * hint 2: use seL4Notification as the connector\u000a         * hint 3: look at https://github.com/seL4/camkes-tool/blob/master/docs/index.md#an-example-of-events\u000a         */\u000a	 /* Things coming out of the modtx component */\u000a         connection seL4RPCCall conn1(from modtx.modchk_iface, to modchk.modchk_iface); \u000a         connection seL4RPCCall conn2(from modtx.crypto_iface, to crypto.crypto_iface);\u000a	 /* Things coming out of the crypto component*/\u000a	 connection seL4RPCCall conn3(from crypto.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn4(from crypto.signtx_iface, to signtx.signtx_iface);\u000a\u000a	 /* Things coming out of the signtx component */\u000a	 connection seL4RPCCall conn5(from signtx.crypto_iface, to crypto.crypto_iface);\u000a	 connection seL4RPCCall conn6(from signtx.modchk_iface, to modchk.modchk_iface);\u000a	 /* Things coming out of the modchk component */\u000a	 connection seL4RPCCall conn7(from modchk.modtx_iface, to modtx.modtx_iface);\u000a	 connection seL4RPCCall conn8(from modchk.signtx_iface, to signtx.signtx_iface);\u000a    }\u000a\u000a    configuration {\u000a        /* TASK 8: restrict access to dataports */\u000a        /* hint 1: use attributes <connection name>.to_access and <connection name>.from_access\u000a         * hint 2: appropriate values for the to_access and from_access attributes are: "R" or "W"\u000a         * hint 4: make the "Buf" dataport read only for the Echo component\u000a         * hint 3: make the "str_buf_t" dataport read only for the Client component\u000a         */\u000a       /* echo.d_access="R";\u000a        client.strport_access="R";*/\u000a    }\u000a}\u000a
p2890
sbsg2789
g2485
sg2790
g2809
sg995
I01
sbtp2891
sg995
I01
sbtp2892
sg990
(dp2893
g190
g2485
sg2829
g2812
sg134
g2063
sg106
g1010
sg2883
g2866
sg2856
g2839
sg2800
g2620
sg162
g2350
ssg995
I01
sbsg995
I01
sbsg995
I01
sS'_items'
p2894
(g0
(g1135
g2
Ntp2895
Rp2896
(dp2897
g7
g0
(g13
g2
Ntp2898
Rp2899
(dp2900
g17
I00
sg18
g0
(g19
g2
Ntp2901
Rp2902
(dp2903
g23
g1147
sg29
(lp2904
g0
(g19
g2
Ntp2905
Rp2906
(dp2907
g23
g85
sg29
(lp2908
g0
(g87
g25
VIOPort
p2909
tp2910
Rp2911
(dp2912
g92
I11
sg93
I9
sg94
I19
sg95
g98
sg99
I556
sbasbag0
(g19
g2
Ntp2913
Rp2914
(dp2915
g23
g1162
sg29
(lp2916
g0
(g19
g2
Ntp2917
Rp2918
(dp2919
g23
g0
(g24
g25
Vinclude
p2920
tp2921
Rp2922
sg29
(lp2923
g0
(g19
g2
Ntp2924
Rp2925
(dp2926
g23
g0
(g24
g25
Vangle_string
p2927
tp2928
Rp2929
sg29
(lp2930
g0
(g87
g25
V<stdint.h>
p2931
tp2932
Rp2933
(dp2934
g92
I13
sg93
I16
sg94
I20
sg95
S'_ANON_37'
p2935
sg99
I577
sbasbasbag0
(g19
g2
Ntp2936
Rp2937
(dp2938
g23
g1169
sg29
(lp2939
g0
(g19
g2
Ntp2940
Rp2941
(dp2942
g23
g1205
sg29
(lp2943
g0
(g19
g2
Ntp2944
Rp2945
(dp2946
g23
g0
(g24
g25
Vstruct_ref
p2947
tp2948
Rp2949
sg29
(lp2950
g0
(g19
g2
Ntp2951
Rp2952
(dp2953
g23
g78
sg29
(lp2954
g0
(g19
g2
Ntp2955
Rp2956
(dp2957
g23
g85
sg29
(lp2958
g0
(g87
g25
Vuint8_t
p2959
tp2960
Rp2961
(dp2962
g92
I5
sg93
I21
sg94
I22
sg95
g98
sg99
I594
sbasbasbasbasbag0
(g19
g2
Ntp2963
Rp2964
(dp2965
g23
g85
sg29
(lp2966
g0
(g87
g25
Vin8
p2967
tp2968
Rp2969
(dp2970
g92
I13
sg93
I23
sg94
I22
sg95
g98
sg99
I602
sbasbag0
(g19
g2
Ntp2971
Rp2972
(dp2973
g23
g1184
sg29
(lp2974
g0
(g19
g2
Ntp2975
Rp2976
(dp2977
g23
g1191
sg29
(lp2978
g0
(g87
g25
Vin
p2979
tp2980
Rp2981
(dp2982
g92
I17
sg93
I25
sg94
I22
sg95
g1199
sg99
I606
sbasbag0
(g19
g2
Ntp2983
Rp2984
(dp2985
g23
g1205
sg29
(lp2986
g0
(g19
g2
Ntp2987
Rp2988
(dp2989
g23
g2949
sg29
(lp2990
g0
(g19
g2
Ntp2991
Rp2992
(dp2993
g23
g78
sg29
(lp2994
g0
(g19
g2
Ntp2995
Rp2996
(dp2997
g23
g85
sg29
(lp2998
g0
(g87
g25
Vuint16_t
p2999
tp3000
Rp3001
(dp3002
g92
I20
sg93
I27
sg94
I22
sg95
g98
sg99
I609
sbasbasbasbasbag0
(g19
g2
Ntp3003
Rp3004
(dp3005
g23
g85
sg29
(lp3006
g0
(g87
g25
Vioport
p3007
tp3008
Rp3009
(dp3010
g92
I29
sg93
I29
sg94
I22
sg95
g98
sg99
I618
sbasbasbasbag0
(g19
g2
Ntp3011
Rp3012
(dp3013
g23
g1169
sg29
(lp3014
g0
(g19
g2
Ntp3015
Rp3016
(dp3017
g23
g1205
sg29
(lp3018
g0
(g19
g2
Ntp3019
Rp3020
(dp3021
g23
g2949
sg29
(lp3022
g0
(g19
g2
Ntp3023
Rp3024
(dp3025
g23
g78
sg29
(lp3026
g0
(g19
g2
Ntp3027
Rp3028
(dp3029
g23
g85
sg29
(lp3030
g0
(g87
g25
Vuint16_t
p3031
tp3032
Rp3033
(dp3034
g92
I5
sg93
I34
sg94
I23
sg95
g98
sg99
I631
sbasbasbasbasbag0
(g19
g2
Ntp3035
Rp3036
(dp3037
g23
g85
sg29
(lp3038
g0
(g87
g25
Vin16
p3039
tp3040
Rp3041
(dp3042
g92
I14
sg93
I36
sg94
I23
sg95
g98
sg99
I640
sbasbag0
(g19
g2
Ntp3043
Rp3044
(dp3045
g23
g1184
sg29
(lp3046
g0
(g19
g2
Ntp3047
Rp3048
(dp3049
g23
g1191
sg29
(lp3050
g0
(g87
g25
Vin
p3051
tp3052
Rp3053
(dp3054
g92
I19
sg93
I38
sg94
I23
sg95
g1199
sg99
I645
sbasbag0
(g19
g2
Ntp3055
Rp3056
(dp3057
g23
g1205
sg29
(lp3058
g0
(g19
g2
Ntp3059
Rp3060
(dp3061
g23
g2949
sg29
(lp3062
g0
(g19
g2
Ntp3063
Rp3064
(dp3065
g23
g78
sg29
(lp3066
g0
(g19
g2
Ntp3067
Rp3068
(dp3069
g23
g85
sg29
(lp3070
g0
(g87
g25
Vuint16_t
p3071
tp3072
Rp3073
(dp3074
g92
I22
sg93
I40
sg94
I23
sg95
g98
sg99
I648
sbasbasbasbasbag0
(g19
g2
Ntp3075
Rp3076
(dp3077
g23
g85
sg29
(lp3078
g0
(g87
g25
Vioport
p3079
tp3080
Rp3081
(dp3082
g92
I31
sg93
I42
sg94
I23
sg95
g98
sg99
I657
sbasbasbasbag0
(g19
g2
Ntp3083
Rp3084
(dp3085
g23
g1169
sg29
(lp3086
g0
(g19
g2
Ntp3087
Rp3088
(dp3089
g23
g1205
sg29
(lp3090
g0
(g19
g2
Ntp3091
Rp3092
(dp3093
g23
g2949
sg29
(lp3094
g0
(g19
g2
Ntp3095
Rp3096
(dp3097
g23
g78
sg29
(lp3098
g0
(g19
g2
Ntp3099
Rp3100
(dp3101
g23
g85
sg29
(lp3102
g0
(g87
g25
Vuint32_t
p3103
tp3104
Rp3105
(dp3106
g92
I5
sg93
I47
sg94
I24
sg95
g98
sg99
I670
sbasbasbasbasbag0
(g19
g2
Ntp3107
Rp3108
(dp3109
g23
g85
sg29
(lp3110
g0
(g87
g25
Vin32
p3111
tp3112
Rp3113
(dp3114
g92
I14
sg93
I49
sg94
I24
sg95
g98
sg99
I679
sbasbag0
(g19
g2
Ntp3115
Rp3116
(dp3117
g23
g1184
sg29
(lp3118
g0
(g19
g2
Ntp3119
Rp3120
(dp3121
g23
g1191
sg29
(lp3122
g0
(g87
g25
Vin
p3123
tp3124
Rp3125
(dp3126
g92
I19
sg93
I51
sg94
I24
sg95
g1199
sg99
I684
sbasbag0
(g19
g2
Ntp3127
Rp3128
(dp3129
g23
g1205
sg29
(lp3130
g0
(g19
g2
Ntp3131
Rp3132
(dp3133
g23
g2949
sg29
(lp3134
g0
(g19
g2
Ntp3135
Rp3136
(dp3137
g23
g78
sg29
(lp3138
g0
(g19
g2
Ntp3139
Rp3140
(dp3141
g23
g85
sg29
(lp3142
g0
(g87
g25
Vuint16_t
p3143
tp3144
Rp3145
(dp3146
g92
I22
sg93
I53
sg94
I24
sg95
g98
sg99
I687
sbasbasbasbasbag0
(g19
g2
Ntp3147
Rp3148
(dp3149
g23
g85
sg29
(lp3150
g0
(g87
g25
Vioport
p3151
tp3152
Rp3153
(dp3154
g92
I31
sg93
I55
sg94
I24
sg95
g98
sg99
I696
sbasbasbasbag0
(g19
g2
Ntp3155
Rp3156
(dp3157
g23
g1169
sg29
(lp3158
g0
(g19
g2
Ntp3159
Rp3160
(dp3161
g23
g1205
sg29
(lp3162
g0
(g19
g2
Ntp3163
Rp3164
(dp3165
g23
g2949
sg29
(lp3166
g0
(g19
g2
Ntp3167
Rp3168
(dp3169
g23
g78
sg29
(lp3170
g0
(g19
g2
Ntp3171
Rp3172
(dp3173
g23
g85
sg29
(lp3174
g0
(g87
g25
Vuint8_t
p3175
tp3176
Rp3177
(dp3178
g92
I5
sg93
I61
sg94
I26
sg95
g98
sg99
I710
sbasbasbasbasbag0
(g19
g2
Ntp3179
Rp3180
(dp3181
g23
g85
sg29
(lp3182
g0
(g87
g25
Vin8_offset
p3183
tp3184
Rp3185
(dp3186
g92
I13
sg93
I63
sg94
I26
sg95
g98
sg99
I718
sbasbag0
(g19
g2
Ntp3187
Rp3188
(dp3189
g23
g1184
sg29
(lp3190
g0
(g19
g2
Ntp3191
Rp3192
(dp3193
g23
g1191
sg29
(lp3194
g0
(g87
g25
Vin
p3195
tp3196
Rp3197
(dp3198
g92
I24
sg93
I65
sg94
I26
sg95
g1199
sg99
I729
sbasbag0
(g19
g2
Ntp3199
Rp3200
(dp3201
g23
g1205
sg29
(lp3202
g0
(g19
g2
Ntp3203
Rp3204
(dp3205
g23
g2949
sg29
(lp3206
g0
(g19
g2
Ntp3207
Rp3208
(dp3209
g23
g78
sg29
(lp3210
g0
(g19
g2
Ntp3211
Rp3212
(dp3213
g23
g85
sg29
(lp3214
g0
(g87
g25
Vuint16_t
p3215
tp3216
Rp3217
(dp3218
g92
I27
sg93
I67
sg94
I26
sg95
g98
sg99
I732
sbasbasbasbasbag0
(g19
g2
Ntp3219
Rp3220
(dp3221
g23
g85
sg29
(lp3222
g0
(g87
g25
Voffset
p3223
tp3224
Rp3225
(dp3226
g92
I36
sg93
I69
sg94
I26
sg95
g98
sg99
I741
sbasbasbasbag0
(g19
g2
Ntp3227
Rp3228
(dp3229
g23
g1169
sg29
(lp3230
g0
(g19
g2
Ntp3231
Rp3232
(dp3233
g23
g1205
sg29
(lp3234
g0
(g19
g2
Ntp3235
Rp3236
(dp3237
g23
g2949
sg29
(lp3238
g0
(g19
g2
Ntp3239
Rp3240
(dp3241
g23
g78
sg29
(lp3242
g0
(g19
g2
Ntp3243
Rp3244
(dp3245
g23
g85
sg29
(lp3246
g0
(g87
g25
Vuint16_t
p3247
tp3248
Rp3249
(dp3250
g92
I5
sg93
I74
sg94
I27
sg95
g98
sg99
I754
sbasbasbasbasbag0
(g19
g2
Ntp3251
Rp3252
(dp3253
g23
g85
sg29
(lp3254
g0
(g87
g25
Vin16_offset
p3255
tp3256
Rp3257
(dp3258
g92
I14
sg93
I76
sg94
I27
sg95
g98
sg99
I763
sbasbag0
(g19
g2
Ntp3259
Rp3260
(dp3261
g23
g1184
sg29
(lp3262
g0
(g19
g2
Ntp3263
Rp3264
(dp3265
g23
g1191
sg29
(lp3266
g0
(g87
g25
Vin
p3267
tp3268
Rp3269
(dp3270
g92
I26
sg93
I78
sg94
I27
sg95
g1199
sg99
I775
sbasbag0
(g19
g2
Ntp3271
Rp3272
(dp3273
g23
g1205
sg29
(lp3274
g0
(g19
g2
Ntp3275
Rp3276
(dp3277
g23
g2949
sg29
(lp3278
g0
(g19
g2
Ntp3279
Rp3280
(dp3281
g23
g78
sg29
(lp3282
g0
(g19
g2
Ntp3283
Rp3284
(dp3285
g23
g85
sg29
(lp3286
g0
(g87
g25
Vuint16_t
p3287
tp3288
Rp3289
(dp3290
g92
I29
sg93
I80
sg94
I27
sg95
g98
sg99
I778
sbasbasbasbasbag0
(g19
g2
Ntp3291
Rp3292
(dp3293
g23
g85
sg29
(lp3294
g0
(g87
g25
Voffset
p3295
tp3296
Rp3297
(dp3298
g92
I38
sg93
I82
sg94
I27
sg95
g98
sg99
I787
sbasbasbasbag0
(g19
g2
Ntp3299
Rp3300
(dp3301
g23
g1169
sg29
(lp3302
g0
(g19
g2
Ntp3303
Rp3304
(dp3305
g23
g1205
sg29
(lp3306
g0
(g19
g2
Ntp3307
Rp3308
(dp3309
g23
g2949
sg29
(lp3310
g0
(g19
g2
Ntp3311
Rp3312
(dp3313
g23
g78
sg29
(lp3314
g0
(g19
g2
Ntp3315
Rp3316
(dp3317
g23
g85
sg29
(lp3318
g0
(g87
g25
Vuint32_t
p3319
tp3320
Rp3321
(dp3322
g92
I5
sg93
I87
sg94
I28
sg95
g98
sg99
I800
sbasbasbasbasbag0
(g19
g2
Ntp3323
Rp3324
(dp3325
g23
g85
sg29
(lp3326
g0
(g87
g25
Vin32_offset
p3327
tp3328
Rp3329
(dp3330
g92
I14
sg93
I89
sg94
I28
sg95
g98
sg99
I809
sbasbag0
(g19
g2
Ntp3331
Rp3332
(dp3333
g23
g1184
sg29
(lp3334
g0
(g19
g2
Ntp3335
Rp3336
(dp3337
g23
g1191
sg29
(lp3338
g0
(g87
g25
Vin
p3339
tp3340
Rp3341
(dp3342
g92
I26
sg93
I91
sg94
I28
sg95
g1199
sg99
I821
sbasbag0
(g19
g2
Ntp3343
Rp3344
(dp3345
g23
g1205
sg29
(lp3346
g0
(g19
g2
Ntp3347
Rp3348
(dp3349
g23
g2949
sg29
(lp3350
g0
(g19
g2
Ntp3351
Rp3352
(dp3353
g23
g78
sg29
(lp3354
g0
(g19
g2
Ntp3355
Rp3356
(dp3357
g23
g85
sg29
(lp3358
g0
(g87
g25
Vuint16_t
p3359
tp3360
Rp3361
(dp3362
g92
I29
sg93
I93
sg94
I28
sg95
g98
sg99
I824
sbasbasbasbasbag0
(g19
g2
Ntp3363
Rp3364
(dp3365
g23
g85
sg29
(lp3366
g0
(g87
g25
Voffset
p3367
tp3368
Rp3369
(dp3370
g92
I38
sg93
I95
sg94
I28
sg95
g98
sg99
I833
sbasbasbasbag0
(g19
g2
Ntp3371
Rp3372
(dp3373
g23
g1169
sg29
(lp3374
g0
(g19
g2
Ntp3375
Rp3376
(dp3377
g23
g85
sg29
(lp3378
g0
(g87
g25
Vout8
p3379
tp3380
Rp3381
(dp3382
g92
I10
sg93
I103
sg94
I30
sg95
g98
sg99
I852
sbasbag0
(g19
g2
Ntp3383
Rp3384
(dp3385
g23
g1184
sg29
(lp3386
g0
(g19
g2
Ntp3387
Rp3388
(dp3389
g23
g1191
sg29
(lp3390
g0
(g87
g25
Vin
p3391
tp3392
Rp3393
(dp3394
g92
I15
sg93
I105
sg94
I30
sg95
g1199
sg99
I857
sbasbag0
(g19
g2
Ntp3395
Rp3396
(dp3397
g23
g1205
sg29
(lp3398
g0
(g19
g2
Ntp3399
Rp3400
(dp3401
g23
g2949
sg29
(lp3402
g0
(g19
g2
Ntp3403
Rp3404
(dp3405
g23
g78
sg29
(lp3406
g0
(g19
g2
Ntp3407
Rp3408
(dp3409
g23
g85
sg29
(lp3410
g0
(g87
g25
Vuint16_t
p3411
tp3412
Rp3413
(dp3414
g92
I18
sg93
I107
sg94
I30
sg95
g98
sg99
I860
sbasbasbasbasbag0
(g19
g2
Ntp3415
Rp3416
(dp3417
g23
g85
sg29
(lp3418
g0
(g87
g25
Vioport
p3419
tp3420
Rp3421
(dp3422
g92
I27
sg93
I109
sg94
I30
sg95
g98
sg99
I869
sbasbasbag0
(g19
g2
Ntp3423
Rp3424
(dp3425
g23
g1184
sg29
(lp3426
g0
(g19
g2
Ntp3427
Rp3428
(dp3429
g23
g1191
sg29
(lp3430
g0
(g87
g25
Vin
p3431
tp3432
Rp3433
(dp3434
g92
I35
sg93
I112
sg94
I30
sg95
g1199
sg99
I877
sbasbag0
(g19
g2
Ntp3435
Rp3436
(dp3437
g23
g1205
sg29
(lp3438
g0
(g19
g2
Ntp3439
Rp3440
(dp3441
g23
g2949
sg29
(lp3442
g0
(g19
g2
Ntp3443
Rp3444
(dp3445
g23
g78
sg29
(lp3446
g0
(g19
g2
Ntp3447
Rp3448
(dp3449
g23
g85
sg29
(lp3450
g0
(g87
g25
Vuint8_t
p3451
tp3452
Rp3453
(dp3454
g92
I38
sg93
I114
sg94
I30
sg95
g98
sg99
I880
sbasbasbasbasbag0
(g19
g2
Ntp3455
Rp3456
(dp3457
g23
g85
sg29
(lp3458
g0
(g87
g25
Vvalue
p3459
tp3460
Rp3461
(dp3462
g92
I46
sg93
I116
sg94
I30
sg95
g98
sg99
I888
sbasbasbasbag0
(g19
g2
Ntp3463
Rp3464
(dp3465
g23
g1169
sg29
(lp3466
g0
(g19
g2
Ntp3467
Rp3468
(dp3469
g23
g85
sg29
(lp3470
g0
(g87
g25
Vout16
p3471
tp3472
Rp3473
(dp3474
g92
I10
sg93
I123
sg94
I31
sg95
g98
sg99
I905
sbasbag0
(g19
g2
Ntp3475
Rp3476
(dp3477
g23
g1184
sg29
(lp3478
g0
(g19
g2
Ntp3479
Rp3480
(dp3481
g23
g1191
sg29
(lp3482
g0
(g87
g25
Vin
p3483
tp3484
Rp3485
(dp3486
g92
I16
sg93
I125
sg94
I31
sg95
g1199
sg99
I911
sbasbag0
(g19
g2
Ntp3487
Rp3488
(dp3489
g23
g1205
sg29
(lp3490
g0
(g19
g2
Ntp3491
Rp3492
(dp3493
g23
g2949
sg29
(lp3494
g0
(g19
g2
Ntp3495
Rp3496
(dp3497
g23
g78
sg29
(lp3498
g0
(g19
g2
Ntp3499
Rp3500
(dp3501
g23
g85
sg29
(lp3502
g0
(g87
g25
Vuint16_t
p3503
tp3504
Rp3505
(dp3506
g92
I19
sg93
I127
sg94
I31
sg95
g98
sg99
I914
sbasbasbasbasbag0
(g19
g2
Ntp3507
Rp3508
(dp3509
g23
g85
sg29
(lp3510
g0
(g87
g25
Vioport
p3511
tp3512
Rp3513
(dp3514
g92
I28
sg93
I129
sg94
I31
sg95
g98
sg99
I923
sbasbasbag0
(g19
g2
Ntp3515
Rp3516
(dp3517
g23
g1184
sg29
(lp3518
g0
(g19
g2
Ntp3519
Rp3520
(dp3521
g23
g1191
sg29
(lp3522
g0
(g87
g25
Vin
p3523
tp3524
Rp3525
(dp3526
g92
I36
sg93
I132
sg94
I31
sg95
g1199
sg99
I931
sbasbag0
(g19
g2
Ntp3527
Rp3528
(dp3529
g23
g1205
sg29
(lp3530
g0
(g19
g2
Ntp3531
Rp3532
(dp3533
g23
g2949
sg29
(lp3534
g0
(g19
g2
Ntp3535
Rp3536
(dp3537
g23
g78
sg29
(lp3538
g0
(g19
g2
Ntp3539
Rp3540
(dp3541
g23
g85
sg29
(lp3542
g0
(g87
g25
Vuint16_t
p3543
tp3544
Rp3545
(dp3546
g92
I39
sg93
I134
sg94
I31
sg95
g98
sg99
I934
sbasbasbasbasbag0
(g19
g2
Ntp3547
Rp3548
(dp3549
g23
g85
sg29
(lp3550
g0
(g87
g25
Vvalue
p3551
tp3552
Rp3553
(dp3554
g92
I48
sg93
I136
sg94
I31
sg95
g98
sg99
I943
sbasbasbasbag0
(g19
g2
Ntp3555
Rp3556
(dp3557
g23
g1169
sg29
(lp3558
g0
(g19
g2
Ntp3559
Rp3560
(dp3561
g23
g85
sg29
(lp3562
g0
(g87
g25
Vout32
p3563
tp3564
Rp3565
(dp3566
g92
I10
sg93
I143
sg94
I32
sg95
g98
sg99
I960
sbasbag0
(g19
g2
Ntp3567
Rp3568
(dp3569
g23
g1184
sg29
(lp3570
g0
(g19
g2
Ntp3571
Rp3572
(dp3573
g23
g1191
sg29
(lp3574
g0
(g87
g25
Vin
p3575
tp3576
Rp3577
(dp3578
g92
I16
sg93
I145
sg94
I32
sg95
g1199
sg99
I966
sbasbag0
(g19
g2
Ntp3579
Rp3580
(dp3581
g23
g1205
sg29
(lp3582
g0
(g19
g2
Ntp3583
Rp3584
(dp3585
g23
g2949
sg29
(lp3586
g0
(g19
g2
Ntp3587
Rp3588
(dp3589
g23
g78
sg29
(lp3590
g0
(g19
g2
Ntp3591
Rp3592
(dp3593
g23
g85
sg29
(lp3594
g0
(g87
g25
Vuint16_t
p3595
tp3596
Rp3597
(dp3598
g92
I19
sg93
I147
sg94
I32
sg95
g98
sg99
I969
sbasbasbasbasbag0
(g19
g2
Ntp3599
Rp3600
(dp3601
g23
g85
sg29
(lp3602
g0
(g87
g25
Vioport
p3603
tp3604
Rp3605
(dp3606
g92
I28
sg93
I149
sg94
I32
sg95
g98
sg99
I978
sbasbasbag0
(g19
g2
Ntp3607
Rp3608
(dp3609
g23
g1184
sg29
(lp3610
g0
(g19
g2
Ntp3611
Rp3612
(dp3613
g23
g1191
sg29
(lp3614
g0
(g87
g25
Vin
p3615
tp3616
Rp3617
(dp3618
g92
I36
sg93
I152
sg94
I32
sg95
g1199
sg99
I986
sbasbag0
(g19
g2
Ntp3619
Rp3620
(dp3621
g23
g1205
sg29
(lp3622
g0
(g19
g2
Ntp3623
Rp3624
(dp3625
g23
g2949
sg29
(lp3626
g0
(g19
g2
Ntp3627
Rp3628
(dp3629
g23
g78
sg29
(lp3630
g0
(g19
g2
Ntp3631
Rp3632
(dp3633
g23
g85
sg29
(lp3634
g0
(g87
g25
Vuint32_t
p3635
tp3636
Rp3637
(dp3638
g92
I39
sg93
I154
sg94
I32
sg95
g98
sg99
I989
sbasbasbasbasbag0
(g19
g2
Ntp3639
Rp3640
(dp3641
g23
g85
sg29
(lp3642
g0
(g87
g25
Vvalue
p3643
tp3644
Rp3645
(dp3646
g92
I48
sg93
I156
sg94
I32
sg95
g98
sg99
I998
sbasbasbasbag0
(g19
g2
Ntp3647
Rp3648
(dp3649
g23
g1169
sg29
(lp3650
g0
(g19
g2
Ntp3651
Rp3652
(dp3653
g23
g85
sg29
(lp3654
g0
(g87
g25
Vout8_offset
p3655
tp3656
Rp3657
(dp3658
g92
I10
sg93
I164
sg94
I34
sg95
g98
sg99
I1016
sbasbag0
(g19
g2
Ntp3659
Rp3660
(dp3661
g23
g1184
sg29
(lp3662
g0
(g19
g2
Ntp3663
Rp3664
(dp3665
g23
g1191
sg29
(lp3666
g0
(g87
g25
Vin
p3667
tp3668
Rp3669
(dp3670
g92
I22
sg93
I166
sg94
I34
sg95
g1199
sg99
I1028
sbasbag0
(g19
g2
Ntp3671
Rp3672
(dp3673
g23
g1205
sg29
(lp3674
g0
(g19
g2
Ntp3675
Rp3676
(dp3677
g23
g2949
sg29
(lp3678
g0
(g19
g2
Ntp3679
Rp3680
(dp3681
g23
g78
sg29
(lp3682
g0
(g19
g2
Ntp3683
Rp3684
(dp3685
g23
g85
sg29
(lp3686
g0
(g87
g25
Vuint16_t
p3687
tp3688
Rp3689
(dp3690
g92
I25
sg93
I168
sg94
I34
sg95
g98
sg99
I1031
sbasbasbasbasbag0
(g19
g2
Ntp3691
Rp3692
(dp3693
g23
g85
sg29
(lp3694
g0
(g87
g25
Voffset
p3695
tp3696
Rp3697
(dp3698
g92
I34
sg93
I170
sg94
I34
sg95
g98
sg99
I1040
sbasbasbag0
(g19
g2
Ntp3699
Rp3700
(dp3701
g23
g1184
sg29
(lp3702
g0
(g19
g2
Ntp3703
Rp3704
(dp3705
g23
g1191
sg29
(lp3706
g0
(g87
g25
Vin
p3707
tp3708
Rp3709
(dp3710
g92
I42
sg93
I173
sg94
I34
sg95
g1199
sg99
I1048
sbasbag0
(g19
g2
Ntp3711
Rp3712
(dp3713
g23
g1205
sg29
(lp3714
g0
(g19
g2
Ntp3715
Rp3716
(dp3717
g23
g2949
sg29
(lp3718
g0
(g19
g2
Ntp3719
Rp3720
(dp3721
g23
g78
sg29
(lp3722
g0
(g19
g2
Ntp3723
Rp3724
(dp3725
g23
g85
sg29
(lp3726
g0
(g87
g25
Vuint8_t
p3727
tp3728
Rp3729
(dp3730
g92
I45
sg93
I175
sg94
I34
sg95
g98
sg99
I1051
sbasbasbasbasbag0
(g19
g2
Ntp3731
Rp3732
(dp3733
g23
g85
sg29
(lp3734
g0
(g87
g25
Vvalue
p3735
tp3736
Rp3737
(dp3738
g92
I53
sg93
I177
sg94
I34
sg95
g98
sg99
I1059
sbasbasbasbag0
(g19
g2
Ntp3739
Rp3740
(dp3741
g23
g1169
sg29
(lp3742
g0
(g19
g2
Ntp3743
Rp3744
(dp3745
g23
g85
sg29
(lp3746
g0
(g87
g25
Vout16_offset
p3747
tp3748
Rp3749
(dp3750
g92
I10
sg93
I184
sg94
I35
sg95
g98
sg99
I1076
sbasbag0
(g19
g2
Ntp3751
Rp3752
(dp3753
g23
g1184
sg29
(lp3754
g0
(g19
g2
Ntp3755
Rp3756
(dp3757
g23
g1191
sg29
(lp3758
g0
(g87
g25
Vin
p3759
tp3760
Rp3761
(dp3762
g92
I23
sg93
I186
sg94
I35
sg95
g1199
sg99
I1089
sbasbag0
(g19
g2
Ntp3763
Rp3764
(dp3765
g23
g1205
sg29
(lp3766
g0
(g19
g2
Ntp3767
Rp3768
(dp3769
g23
g2949
sg29
(lp3770
g0
(g19
g2
Ntp3771
Rp3772
(dp3773
g23
g78
sg29
(lp3774
g0
(g19
g2
Ntp3775
Rp3776
(dp3777
g23
g85
sg29
(lp3778
g0
(g87
g25
Vuint16_t
p3779
tp3780
Rp3781
(dp3782
g92
I26
sg93
I188
sg94
I35
sg95
g98
sg99
I1092
sbasbasbasbasbag0
(g19
g2
Ntp3783
Rp3784
(dp3785
g23
g85
sg29
(lp3786
g0
(g87
g25
Voffset
p3787
tp3788
Rp3789
(dp3790
g92
I35
sg93
I190
sg94
I35
sg95
g98
sg99
I1101
sbasbasbag0
(g19
g2
Ntp3791
Rp3792
(dp3793
g23
g1184
sg29
(lp3794
g0
(g19
g2
Ntp3795
Rp3796
(dp3797
g23
g1191
sg29
(lp3798
g0
(g87
g25
Vin
p3799
tp3800
Rp3801
(dp3802
g92
I43
sg93
I193
sg94
I35
sg95
g1199
sg99
I1109
sbasbag0
(g19
g2
Ntp3803
Rp3804
(dp3805
g23
g1205
sg29
(lp3806
g0
(g19
g2
Ntp3807
Rp3808
(dp3809
g23
g2949
sg29
(lp3810
g0
(g19
g2
Ntp3811
Rp3812
(dp3813
g23
g78
sg29
(lp3814
g0
(g19
g2
Ntp3815
Rp3816
(dp3817
g23
g85
sg29
(lp3818
g0
(g87
g25
Vuint16_t
p3819
tp3820
Rp3821
(dp3822
g92
I46
sg93
I195
sg94
I35
sg95
g98
sg99
I1112
sbasbasbasbasbag0
(g19
g2
Ntp3823
Rp3824
(dp3825
g23
g85
sg29
(lp3826
g0
(g87
g25
Vvalue
p3827
tp3828
Rp3829
(dp3830
g92
I55
sg93
I197
sg94
I35
sg95
g98
sg99
I1121
sbasbasbasbag0
(g19
g2
Ntp3831
Rp3832
(dp3833
g23
g1169
sg29
(lp3834
g0
(g19
g2
Ntp3835
Rp3836
(dp3837
g23
g85
sg29
(lp3838
g0
(g87
g25
Vout32_offset
p3839
tp3840
Rp3841
(dp3842
g92
I10
sg93
I204
sg94
I36
sg95
g98
sg99
I1138
sbasbag0
(g19
g2
Ntp3843
Rp3844
(dp3845
g23
g1184
sg29
(lp3846
g0
(g19
g2
Ntp3847
Rp3848
(dp3849
g23
g1191
sg29
(lp3850
g0
(g87
g25
Vin
p3851
tp3852
Rp3853
(dp3854
g92
I23
sg93
I206
sg94
I36
sg95
g1199
sg99
I1151
sbasbag0
(g19
g2
Ntp3855
Rp3856
(dp3857
g23
g1205
sg29
(lp3858
g0
(g19
g2
Ntp3859
Rp3860
(dp3861
g23
g2949
sg29
(lp3862
g0
(g19
g2
Ntp3863
Rp3864
(dp3865
g23
g78
sg29
(lp3866
g0
(g19
g2
Ntp3867
Rp3868
(dp3869
g23
g85
sg29
(lp3870
g0
(g87
g25
Vuint16_t
p3871
tp3872
Rp3873
(dp3874
g92
I26
sg93
I208
sg94
I36
sg95
g98
sg99
I1154
sbasbasbasbasbag0
(g19
g2
Ntp3875
Rp3876
(dp3877
g23
g85
sg29
(lp3878
g0
(g87
g25
Voffset
p3879
tp3880
Rp3881
(dp3882
g92
I35
sg93
I210
sg94
I36
sg95
g98
sg99
I1163
sbasbasbag0
(g19
g2
Ntp3883
Rp3884
(dp3885
g23
g1184
sg29
(lp3886
g0
(g19
g2
Ntp3887
Rp3888
(dp3889
g23
g1191
sg29
(lp3890
g0
(g87
g25
Vin
p3891
tp3892
Rp3893
(dp3894
g92
I43
sg93
I213
sg94
I36
sg95
g1199
sg99
I1171
sbasbag0
(g19
g2
Ntp3895
Rp3896
(dp3897
g23
g1205
sg29
(lp3898
g0
(g19
g2
Ntp3899
Rp3900
(dp3901
g23
g2949
sg29
(lp3902
g0
(g19
g2
Ntp3903
Rp3904
(dp3905
g23
g78
sg29
(lp3906
g0
(g19
g2
Ntp3907
Rp3908
(dp3909
g23
g85
sg29
(lp3910
g0
(g87
g25
Vuint32_t
p3911
tp3912
Rp3913
(dp3914
g92
I46
sg93
I215
sg94
I36
sg95
g98
sg99
I1174
sbasbasbasbasbag0
(g19
g2
Ntp3915
Rp3916
(dp3917
g23
g85
sg29
(lp3918
g0
(g87
g25
Vvalue
p3919
tp3920
Rp3921
(dp3922
g92
I55
sg93
I217
sg94
I36
sg95
g98
sg99
I1183
sbasbasbasbag0
(g19
g2
Ntp3923
Rp3924
(dp3925
g23
g1169
sg29
(lp3926
g0
(g19
g2
Ntp3927
Rp3928
(dp3929
g23
g1205
sg29
(lp3930
g0
(g19
g2
Ntp3931
Rp3932
(dp3933
g23
g1243
sg29
(lp3934
g0
(g87
g25
Vint
p3935
tp3936
Rp3937
(dp3938
g92
I5
sg93
I226
sg94
I41
sg95
g1251
sg99
I1356
sbasbasbag0
(g19
g2
Ntp3939
Rp3940
(dp3941
g23
g85
sg29
(lp3942
g0
(g87
g25
Vin_range
p3943
tp3944
Rp3945
(dp3946
g92
I9
sg93
I228
sg94
I41
sg95
g98
sg99
I1360
sbasbag0
(g19
g2
Ntp3947
Rp3948
(dp3949
g23
g1184
sg29
(lp3950
g0
(g19
g2
Ntp3951
Rp3952
(dp3953
g23
g1191
sg29
(lp3954
g0
(g87
g25
Vin
p3955
tp3956
Rp3957
(dp3958
g92
I18
sg93
I230
sg94
I41
sg95
g1199
sg99
I1369
sbasbag0
(g19
g2
Ntp3959
Rp3960
(dp3961
g23
g1205
sg29
(lp3962
g0
(g19
g2
Ntp3963
Rp3964
(dp3965
g23
g0
(g24
g25
Vunsigned_int
p3966
tp3967
Rp3968
sg29
(lp3969
sbasbag0
(g19
g2
Ntp3970
Rp3971
(dp3972
g23
g85
sg29
(lp3973
g0
(g87
g25
Vport
p3974
tp3975
Rp3976
(dp3977
g92
I34
sg93
I236
sg94
I41
sg95
g98
sg99
I1385
sbasbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/camkes-hardware.idl4
p3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p3979
sbsg987
g2911
sg6
g4
sg1362
(lp3980
g0
(g1364
g2
Ntp3981
Rp3982
(dp3983
g1368
(g0
(g1369
g2
Ntp3984
Rp3985
(dp3986
g1012
g3001
sg7
g0
(g13
g2
Ntp3987
Rp3988
(dp3989
g17
I00
sg18
g2972
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p3990
sbsg1378
I00
sg987
g3009
sg6
g3982
sg1379
g2981
sg995
I01
sbtp3991
sg7
g0
(g13
g2
Ntp3992
Rp3993
(dp3994
g17
I00
sg18
g2937
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p3995
sbsg1393
g2961
sg987
g2969
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp3996
Rp3997
(dp3998
g1368
(g0
(g1369
g2
Ntp3999
Rp4000
(dp4001
g1012
g3073
sg7
g0
(g13
g2
Ntp4002
Rp4003
(dp4004
g17
I00
sg18
g3044
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4005
sbsg1378
I00
sg987
g3081
sg6
g3997
sg1379
g3053
sg995
I01
sbtp4006
sg7
g0
(g13
g2
Ntp4007
Rp4008
(dp4009
g17
I00
sg18
g3012
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4010
sbsg1393
g3033
sg987
g3041
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4011
Rp4012
(dp4013
g1368
(g0
(g1369
g2
Ntp4014
Rp4015
(dp4016
g1012
g3145
sg7
g0
(g13
g2
Ntp4017
Rp4018
(dp4019
g17
I00
sg18
g3116
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4020
sbsg1378
I00
sg987
g3153
sg6
g4012
sg1379
g3125
sg995
I01
sbtp4021
sg7
g0
(g13
g2
Ntp4022
Rp4023
(dp4024
g17
I00
sg18
g3084
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4025
sbsg1393
g3105
sg987
g3113
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4026
Rp4027
(dp4028
g1368
(g0
(g1369
g2
Ntp4029
Rp4030
(dp4031
g1012
g3217
sg7
g0
(g13
g2
Ntp4032
Rp4033
(dp4034
g17
I00
sg18
g3188
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4035
sbsg1378
I00
sg987
g3225
sg6
g4027
sg1379
g3197
sg995
I01
sbtp4036
sg7
g0
(g13
g2
Ntp4037
Rp4038
(dp4039
g17
I00
sg18
g3156
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4040
sbsg1393
g3177
sg987
g3185
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4041
Rp4042
(dp4043
g1368
(g0
(g1369
g2
Ntp4044
Rp4045
(dp4046
g1012
g3289
sg7
g0
(g13
g2
Ntp4047
Rp4048
(dp4049
g17
I00
sg18
g3260
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4050
sbsg1378
I00
sg987
g3297
sg6
g4042
sg1379
g3269
sg995
I01
sbtp4051
sg7
g0
(g13
g2
Ntp4052
Rp4053
(dp4054
g17
I00
sg18
g3228
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4055
sbsg1393
g3249
sg987
g3257
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4056
Rp4057
(dp4058
g1368
(g0
(g1369
g2
Ntp4059
Rp4060
(dp4061
g1012
g3361
sg7
g0
(g13
g2
Ntp4062
Rp4063
(dp4064
g17
I00
sg18
g3332
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4065
sbsg1378
I00
sg987
g3369
sg6
g4057
sg1379
g3341
sg995
I01
sbtp4066
sg7
g0
(g13
g2
Ntp4067
Rp4068
(dp4069
g17
I00
sg18
g3300
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4070
sbsg1393
g3321
sg987
g3329
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4071
Rp4072
(dp4073
g1368
(g0
(g1369
g2
Ntp4074
Rp4075
(dp4076
g1012
g3413
sg7
g0
(g13
g2
Ntp4077
Rp4078
(dp4079
g17
I00
sg18
g3384
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4080
sbsg1378
I00
sg987
g3421
sg6
g4072
sg1379
g3393
sg995
I01
sbg0
(g1369
g2
Ntp4081
Rp4082
(dp4083
g1012
g3453
sg7
g0
(g13
g2
Ntp4084
Rp4085
(dp4086
g17
I00
sg18
g3424
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4087
sbsg1378
I00
sg987
g3461
sg6
g4072
sg1379
g3433
sg995
I01
sbtp4088
sg7
g0
(g13
g2
Ntp4089
Rp4090
(dp4091
g17
I00
sg18
g3372
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4092
sbsg1393
Nsg987
g3381
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4093
Rp4094
(dp4095
g1368
(g0
(g1369
g2
Ntp4096
Rp4097
(dp4098
g1012
g3505
sg7
g0
(g13
g2
Ntp4099
Rp4100
(dp4101
g17
I00
sg18
g3476
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4102
sbsg1378
I00
sg987
g3513
sg6
g4094
sg1379
g3485
sg995
I01
sbg0
(g1369
g2
Ntp4103
Rp4104
(dp4105
g1012
g3545
sg7
g0
(g13
g2
Ntp4106
Rp4107
(dp4108
g17
I00
sg18
g3516
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4109
sbsg1378
I00
sg987
g3553
sg6
g4094
sg1379
g3525
sg995
I01
sbtp4110
sg7
g0
(g13
g2
Ntp4111
Rp4112
(dp4113
g17
I00
sg18
g3464
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4114
sbsg1393
Nsg987
g3473
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4115
Rp4116
(dp4117
g1368
(g0
(g1369
g2
Ntp4118
Rp4119
(dp4120
g1012
g3597
sg7
g0
(g13
g2
Ntp4121
Rp4122
(dp4123
g17
I00
sg18
g3568
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4124
sbsg1378
I00
sg987
g3605
sg6
g4116
sg1379
g3577
sg995
I01
sbg0
(g1369
g2
Ntp4125
Rp4126
(dp4127
g1012
g3637
sg7
g0
(g13
g2
Ntp4128
Rp4129
(dp4130
g17
I00
sg18
g3608
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4131
sbsg1378
I00
sg987
g3645
sg6
g4116
sg1379
g3617
sg995
I01
sbtp4132
sg7
g0
(g13
g2
Ntp4133
Rp4134
(dp4135
g17
I00
sg18
g3556
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4136
sbsg1393
Nsg987
g3565
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4137
Rp4138
(dp4139
g1368
(g0
(g1369
g2
Ntp4140
Rp4141
(dp4142
g1012
g3689
sg7
g0
(g13
g2
Ntp4143
Rp4144
(dp4145
g17
I00
sg18
g3660
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4146
sbsg1378
I00
sg987
g3697
sg6
g4138
sg1379
g3669
sg995
I01
sbg0
(g1369
g2
Ntp4147
Rp4148
(dp4149
g1012
g3729
sg7
g0
(g13
g2
Ntp4150
Rp4151
(dp4152
g17
I00
sg18
g3700
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4153
sbsg1378
I00
sg987
g3737
sg6
g4138
sg1379
g3709
sg995
I01
sbtp4154
sg7
g0
(g13
g2
Ntp4155
Rp4156
(dp4157
g17
I00
sg18
g3648
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4158
sbsg1393
Nsg987
g3657
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4159
Rp4160
(dp4161
g1368
(g0
(g1369
g2
Ntp4162
Rp4163
(dp4164
g1012
g3781
sg7
g0
(g13
g2
Ntp4165
Rp4166
(dp4167
g17
I00
sg18
g3752
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4168
sbsg1378
I00
sg987
g3789
sg6
g4160
sg1379
g3761
sg995
I01
sbg0
(g1369
g2
Ntp4169
Rp4170
(dp4171
g1012
g3821
sg7
g0
(g13
g2
Ntp4172
Rp4173
(dp4174
g17
I00
sg18
g3792
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4175
sbsg1378
I00
sg987
g3829
sg6
g4160
sg1379
g3801
sg995
I01
sbtp4176
sg7
g0
(g13
g2
Ntp4177
Rp4178
(dp4179
g17
I00
sg18
g3740
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4180
sbsg1393
Nsg987
g3749
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4181
Rp4182
(dp4183
g1368
(g0
(g1369
g2
Ntp4184
Rp4185
(dp4186
g1012
g3873
sg7
g0
(g13
g2
Ntp4187
Rp4188
(dp4189
g17
I00
sg18
g3844
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4190
sbsg1378
I00
sg987
g3881
sg6
g4182
sg1379
g3853
sg995
I01
sbg0
(g1369
g2
Ntp4191
Rp4192
(dp4193
g1012
g3913
sg7
g0
(g13
g2
Ntp4194
Rp4195
(dp4196
g17
I00
sg18
g3884
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4197
sbsg1378
I00
sg987
g3921
sg6
g4182
sg1379
g3893
sg995
I01
sbtp4198
sg7
g0
(g13
g2
Ntp4199
Rp4200
(dp4201
g17
I00
sg18
g3832
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4202
sbsg1393
Nsg987
g3841
sg6
g2896
sg995
I01
sbag0
(g1364
g2
Ntp4203
Rp4204
(dp4205
g1368
(g0
(g1369
g2
Ntp4206
Rp4207
(dp4208
g1012
Vunsigned int
p4209
sg7
g0
(g13
g2
Ntp4210
Rp4211
(dp4212
g17
I00
sg18
g3948
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4213
sbsg1378
I00
sg987
g3976
sg6
g4204
sg1379
g3957
sg995
I01
sbtp4214
sg7
g0
(g13
g2
Ntp4215
Rp4216
(dp4217
g17
I00
sg18
g3924
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4218
sbsg1393
g1383
sg987
g3945
sg6
g2896
sg995
I01
sbasg1425
(lp4219
g0
(ccamkes.ast.objects
Include
p4220
g2
Ntp4221
Rp4222
(dp4223
g6
g2896
sg7
g0
(g13
g2
Ntp4224
Rp4225
(dp4226
g17
I00
sg18
g2918
sg970
Nsg971
Nsg972
g3978
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000a/**\u000a * This interface defines presents an RPC interface to ia32 I/O ports.  The\u000a * camkes port configured with this interface should be connected using a\u000a * HardwareIOPorts connector to a hardware component.\u000a */\u000a\u000aprocedure IOPort {\u000a    include <stdint.h>;\u000a\u000a    uint8_t in8(in uint16_t ioport);\u000a    uint16_t in16(in uint16_t ioport);\u000a    uint32_t in32(in uint16_t ioport);\u000a\u000a    uint8_t in8_offset(in uint16_t offset);\u000a    uint16_t in16_offset(in uint16_t offset);\u000a    uint32_t in32_offset(in uint16_t offset);\u000a\u000a    void out8(in uint16_t ioport, in uint8_t value);\u000a    void out16(in uint16_t ioport, in uint16_t value);\u000a    void out32(in uint16_t ioport, in uint32_t value);\u000a\u000a    void out8_offset(in uint16_t offset, in uint8_t value);\u000a    void out16_offset(in uint16_t offset, in uint16_t value);\u000a    void out32_offset(in uint16_t offset, in uint32_t value);\u000a\u000a    /* This function is expected to return 0 if the given port does not fall in\u000a     * the addressable range of this interface, or non-zero if it does.\u000a     */\u000a    int in_range(in unsigned int port);\u000a}\u000a
p4227
sbsS'_relative'
p4228
I00
sg995
I01
sS'_source'
p4229
Vstdint.h
p4230
sbasg990
(dp4231
g3657
g4138
sg3565
g4116
sg2969
g3982
sg3749
g4160
sg3381
g4072
sg3945
g4204
sg3257
g4042
sg3113
g4012
sg3041
g3997
sg3185
g4027
sg3841
g4182
sg3473
g4094
sg3329
g4057
ssg1428
(lp4232
sg995
I01
sbg0
(g2622
g2
Ntp4233
Rp4234
(dp4235
g7
g0
(g13
g2
Ntp4236
Rp4237
(dp4238
g17
I00
sg18
g0
(g19
g2
Ntp4239
Rp4240
(dp4241
g23
g2634
sg29
(lp4242
g0
(g19
g2
Ntp4243
Rp4244
(dp4245
g23
g85
sg29
(lp4246
g0
(g87
g25
VseL4GDB
p4247
tp4248
Rp4249
(dp4250
g92
I11
sg93
I12
sg94
I15
sg95
g98
sg99
I375
sbasbag0
(g19
g2
Ntp4251
Rp4252
(dp4253
g23
g2649
sg29
(lp4254
g0
(g19
g2
Ntp4255
Rp4256
(dp4257
g23
g2656
sg29
(lp4258
g0
(g87
g25
VProcedure
p4259
tp4260
Rp4261
(dp4262
g92
I8
sg93
I19
sg94
I16
sg95
g2764
sg99
I392
sbasbag0
(g19
g2
Ntp4263
Rp4264
(dp4265
g23
g0
(g24
g25
Vmulti_string
p4266
tp4267
Rp4268
sg29
(lp4269
g0
(g19
g2
Ntp4270
Rp4271
(dp4272
g23
g0
(g24
g25
Vquoted_string
p4273
tp4274
Rp4275
sg29
(lp4276
g0
(g87
g25
V"seL4GDB-from.template.c"
p4277
tp4278
Rp4279
(dp4280
g92
I27
sg93
I23
sg94
I16
sg95
S'_ANON_36'
p4281
sg99
I411
sbasbasbag0
(g19
g2
Ntp4282
Rp4283
(dp4284
g23
g2656
sg29
(lp4285
g0
(g87
g25
VProcedure
p4286
tp4287
Rp4288
(dp4289
g92
I6
sg93
I30
sg94
I17
sg95
g2764
sg99
I444
sbasbag0
(g19
g2
Ntp4290
Rp4291
(dp4292
g23
g4268
sg29
(lp4293
g0
(g19
g2
Ntp4294
Rp4295
(dp4296
g23
g4275
sg29
(lp4297
g0
(g87
g25
V"seL4GDB-to.template.c"
p4298
tp4299
Rp4300
(dp4301
g92
I25
sg93
I34
sg94
I17
sg95
g4281
sg99
I463
sbasbasbasbasbsg970
Nsg971
Nsg972
V/home/sel4-training/sel4-tutorials-manifest/tools/camkes/include/builtin/gdb-delegate.camkes
p4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p4303
sbsg2767
I00
sg1428
(lp4304
sg2769
I1
sg987
g4249
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
VseL4GDB-from.template.c
p4305
sg2775
g2772
sg2776
VseL4GDB-to.template.c
p4306
sg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp4307
Rp4308
(dp4309
g7
g0
(g13
g2
Ntp4310
Rp4311
(dp4312
g17
I00
sg18
g0
(g19
g2
Ntp4313
Rp4314
(dp4315
g23
g2634
sg29
(lp4316
g0
(g19
g2
Ntp4317
Rp4318
(dp4319
g23
g85
sg29
(lp4320
g0
(g87
g25
VseL4GDBMem
p4321
tp4322
Rp4323
(dp4324
g92
I11
sg93
I42
sg94
I19
sg95
g98
sg99
I501
sbasbag0
(g19
g2
Ntp4325
Rp4326
(dp4327
g23
g2649
sg29
(lp4328
g0
(g19
g2
Ntp4329
Rp4330
(dp4331
g23
g2656
sg29
(lp4332
g0
(g87
g25
VProcedure
p4333
tp4334
Rp4335
(dp4336
g92
I8
sg93
I49
sg94
I20
sg95
g2764
sg99
I521
sbasbag0
(g19
g2
Ntp4337
Rp4338
(dp4339
g23
g4268
sg29
(lp4340
g0
(g19
g2
Ntp4341
Rp4342
(dp4343
g23
g4275
sg29
(lp4344
g0
(g87
g25
V"seL4GDBMem-from.template.c"
p4345
tp4346
Rp4347
(dp4348
g92
I27
sg93
I53
sg94
I20
sg95
g4281
sg99
I540
sbasbasbag0
(g19
g2
Ntp4349
Rp4350
(dp4351
g23
g2656
sg29
(lp4352
g0
(g87
g25
VProcedure
p4353
tp4354
Rp4355
(dp4356
g92
I6
sg93
I60
sg94
I21
sg95
g2764
sg99
I576
sbasbag0
(g19
g2
Ntp4357
Rp4358
(dp4359
g23
g4268
sg29
(lp4360
g0
(g19
g2
Ntp4361
Rp4362
(dp4363
g23
g4275
sg29
(lp4364
g0
(g87
g25
V"seL4GDBMem-to.template.c"
p4365
tp4366
Rp4367
(dp4368
g92
I25
sg93
I64
sg94
I21
sg95
g4281
sg99
I595
sbasbasbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p4369
sbsg2767
I00
sg1428
(lp4370
sg2769
I1
sg987
g4323
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
VseL4GDBMem-from.template.c
p4371
sg2775
g2772
sg2776
VseL4GDBMem-to.template.c
p4372
sg2777
I00
sg2778
I00
sg995
I01
sbg0
(g1135
g2
Ntp4373
Rp4374
(dp4375
g7
g0
(g13
g2
Ntp4376
Rp4377
(dp4378
g17
I00
sg18
g0
(g19
g2
Ntp4379
Rp4380
(dp4381
g23
g1147
sg29
(lp4382
g0
(g19
g2
Ntp4383
Rp4384
(dp4385
g23
g85
sg29
(lp4386
g0
(g87
g25
VGDB_delegate
p4387
tp4388
Rp4389
(dp4390
g92
I11
sg93
I74
sg94
I25
sg95
g98
sg99
I638
sbasbag0
(g19
g2
Ntp4391
Rp4392
(dp4393
g23
g1162
sg29
(lp4394
g0
(g19
g2
Ntp4395
Rp4396
(dp4397
g23
g2922
sg29
(lp4398
g0
(g19
g2
Ntp4399
Rp4400
(dp4401
g23
g2929
sg29
(lp4402
g0
(g87
g25
V<camkes/gdb/delegate_types.h>
p4403
tp4404
Rp4405
(dp4406
g92
I13
sg93
I81
sg94
I26
sg95
g2935
sg99
I665
sbasbasbag0
(g19
g2
Ntp4407
Rp4408
(dp4409
g23
g1169
sg29
(lp4410
g0
(g19
g2
Ntp4411
Rp4412
(dp4413
g23
g1205
sg29
(lp4414
g0
(g19
g2
Ntp4415
Rp4416
(dp4417
g23
g1243
sg29
(lp4418
g0
(g87
g25
Vint
p4419
tp4420
Rp4421
(dp4422
g92
I5
sg93
I85
sg94
I27
sg95
g1251
sg99
I700
sbasbasbag0
(g19
g2
Ntp4423
Rp4424
(dp4425
g23
g85
sg29
(lp4426
g0
(g87
g25
Vread_memory
p4427
tp4428
Rp4429
(dp4430
g92
I9
sg93
I87
sg94
I27
sg95
g98
sg99
I704
sbasbag0
(g19
g2
Ntp4431
Rp4432
(dp4433
g23
g1184
sg29
(lp4434
g0
(g19
g2
Ntp4435
Rp4436
(dp4437
g23
g1191
sg29
(lp4438
g0
(g87
g25
Vin
p4439
tp4440
Rp4441
(dp4442
g92
I21
sg93
I89
sg94
I27
sg95
g1199
sg99
I716
sbasbag0
(g19
g2
Ntp4443
Rp4444
(dp4445
g23
g1205
sg29
(lp4446
g0
(g19
g2
Ntp4447
Rp4448
(dp4449
g23
g2949
sg29
(lp4450
g0
(g19
g2
Ntp4451
Rp4452
(dp4453
g23
g78
sg29
(lp4454
g0
(g19
g2
Ntp4455
Rp4456
(dp4457
g23
g85
sg29
(lp4458
g0
(g87
g25
VseL4_Word
p4459
tp4460
Rp4461
(dp4462
g92
I24
sg93
I91
sg94
I27
sg95
g98
sg99
I719
sbasbasbasbasbag0
(g19
g2
Ntp4463
Rp4464
(dp4465
g23
g85
sg29
(lp4466
g0
(g87
g25
Vaddr
p4467
tp4468
Rp4469
(dp4470
g92
I34
sg93
I93
sg94
I27
sg95
g98
sg99
I729
sbasbasbag0
(g19
g2
Ntp4471
Rp4472
(dp4473
g23
g1184
sg29
(lp4474
g0
(g19
g2
Ntp4475
Rp4476
(dp4477
g23
g1191
sg29
(lp4478
g0
(g87
g25
Vin
p4479
tp4480
Rp4481
(dp4482
g92
I40
sg93
I96
sg94
I27
sg95
g1199
sg99
I735
sbasbag0
(g19
g2
Ntp4483
Rp4484
(dp4485
g23
g1205
sg29
(lp4486
g0
(g19
g2
Ntp4487
Rp4488
(dp4489
g23
g2949
sg29
(lp4490
g0
(g19
g2
Ntp4491
Rp4492
(dp4493
g23
g78
sg29
(lp4494
g0
(g19
g2
Ntp4495
Rp4496
(dp4497
g23
g85
sg29
(lp4498
g0
(g87
g25
VseL4_Word
p4499
tp4500
Rp4501
(dp4502
g92
I43
sg93
I98
sg94
I27
sg95
g98
sg99
I738
sbasbasbasbasbag0
(g19
g2
Ntp4503
Rp4504
(dp4505
g23
g85
sg29
(lp4506
g0
(g87
g25
Vlength
p4507
tp4508
Rp4509
(dp4510
g92
I53
sg93
I100
sg94
I27
sg95
g98
sg99
I748
sbasbasbag0
(g19
g2
Ntp4511
Rp4512
(dp4513
g23
g1184
sg29
(lp4514
g0
(g19
g2
Ntp4515
Rp4516
(dp4517
g23
g1191
sg29
(lp4518
g0
(g87
g25
Vout
p4519
tp4520
Rp4521
(dp4522
g92
I61
sg93
I103
sg94
I27
sg95
g0
(g24
g25
VOUT
p4523
tp4524
Rp4525
sg99
I756
sbasbag0
(g19
g2
Ntp4526
Rp4527
(dp4528
g23
g1205
sg29
(lp4529
g0
(g19
g2
Ntp4530
Rp4531
(dp4532
g23
g2949
sg29
(lp4533
g0
(g19
g2
Ntp4534
Rp4535
(dp4536
g23
g78
sg29
(lp4537
g0
(g19
g2
Ntp4538
Rp4539
(dp4540
g23
g85
sg29
(lp4541
g0
(g87
g25
Vdelegate_mem_range_t
p4542
tp4543
Rp4544
(dp4545
g92
I65
sg93
I105
sg94
I27
sg95
g98
sg99
I760
sbasbasbasbasbag0
(g19
g2
Ntp4546
Rp4547
(dp4548
g23
g85
sg29
(lp4549
g0
(g87
g25
Vdata
p4550
tp4551
Rp4552
(dp4553
g92
I86
sg93
I107
sg94
I27
sg95
g98
sg99
I781
sbasbasbasbag0
(g19
g2
Ntp4554
Rp4555
(dp4556
g23
g1169
sg29
(lp4557
g0
(g19
g2
Ntp4558
Rp4559
(dp4560
g23
g1205
sg29
(lp4561
g0
(g19
g2
Ntp4562
Rp4563
(dp4564
g23
g1243
sg29
(lp4565
g0
(g87
g25
Vint
p4566
tp4567
Rp4568
(dp4569
g92
I5
sg93
I112
sg94
I28
sg95
g1251
sg99
I792
sbasbasbag0
(g19
g2
Ntp4570
Rp4571
(dp4572
g23
g85
sg29
(lp4573
g0
(g87
g25
Vwrite_memory
p4574
tp4575
Rp4576
(dp4577
g92
I9
sg93
I114
sg94
I28
sg95
g98
sg99
I796
sbasbag0
(g19
g2
Ntp4578
Rp4579
(dp4580
g23
g1184
sg29
(lp4581
g0
(g19
g2
Ntp4582
Rp4583
(dp4584
g23
g1191
sg29
(lp4585
g0
(g87
g25
Vin
p4586
tp4587
Rp4588
(dp4589
g92
I22
sg93
I116
sg94
I28
sg95
g1199
sg99
I809
sbasbag0
(g19
g2
Ntp4590
Rp4591
(dp4592
g23
g1205
sg29
(lp4593
g0
(g19
g2
Ntp4594
Rp4595
(dp4596
g23
g2949
sg29
(lp4597
g0
(g19
g2
Ntp4598
Rp4599
(dp4600
g23
g78
sg29
(lp4601
g0
(g19
g2
Ntp4602
Rp4603
(dp4604
g23
g85
sg29
(lp4605
g0
(g87
g25
VseL4_Word
p4606
tp4607
Rp4608
(dp4609
g92
I25
sg93
I118
sg94
I28
sg95
g98
sg99
I812
sbasbasbasbasbag0
(g19
g2
Ntp4610
Rp4611
(dp4612
g23
g85
sg29
(lp4613
g0
(g87
g25
Vaddr
p4614
tp4615
Rp4616
(dp4617
g92
I35
sg93
I120
sg94
I28
sg95
g98
sg99
I822
sbasbasbag0
(g19
g2
Ntp4618
Rp4619
(dp4620
g23
g1184
sg29
(lp4621
g0
(g19
g2
Ntp4622
Rp4623
(dp4624
g23
g1191
sg29
(lp4625
g0
(g87
g25
Vin
p4626
tp4627
Rp4628
(dp4629
g92
I41
sg93
I123
sg94
I28
sg95
g1199
sg99
I828
sbasbag0
(g19
g2
Ntp4630
Rp4631
(dp4632
g23
g1205
sg29
(lp4633
g0
(g19
g2
Ntp4634
Rp4635
(dp4636
g23
g2949
sg29
(lp4637
g0
(g19
g2
Ntp4638
Rp4639
(dp4640
g23
g78
sg29
(lp4641
g0
(g19
g2
Ntp4642
Rp4643
(dp4644
g23
g85
sg29
(lp4645
g0
(g87
g25
VseL4_Word
p4646
tp4647
Rp4648
(dp4649
g92
I44
sg93
I125
sg94
I28
sg95
g98
sg99
I831
sbasbasbasbasbag0
(g19
g2
Ntp4650
Rp4651
(dp4652
g23
g85
sg29
(lp4653
g0
(g87
g25
Vlength
p4654
tp4655
Rp4656
(dp4657
g92
I54
sg93
I127
sg94
I28
sg95
g98
sg99
I841
sbasbasbag0
(g19
g2
Ntp4658
Rp4659
(dp4660
g23
g1184
sg29
(lp4661
g0
(g19
g2
Ntp4662
Rp4663
(dp4664
g23
g1191
sg29
(lp4665
g0
(g87
g25
Vin
p4666
tp4667
Rp4668
(dp4669
g92
I62
sg93
I130
sg94
I28
sg95
g1199
sg99
I849
sbasbag0
(g19
g2
Ntp4670
Rp4671
(dp4672
g23
g1205
sg29
(lp4673
g0
(g19
g2
Ntp4674
Rp4675
(dp4676
g23
g2949
sg29
(lp4677
g0
(g19
g2
Ntp4678
Rp4679
(dp4680
g23
g78
sg29
(lp4681
g0
(g19
g2
Ntp4682
Rp4683
(dp4684
g23
g85
sg29
(lp4685
g0
(g87
g25
Vdelegate_mem_range_t
p4686
tp4687
Rp4688
(dp4689
g92
I65
sg93
I132
sg94
I28
sg95
g98
sg99
I852
sbasbasbasbasbag0
(g19
g2
Ntp4690
Rp4691
(dp4692
g23
g85
sg29
(lp4693
g0
(g87
g25
Vdata
p4694
tp4695
Rp4696
(dp4697
g92
I86
sg93
I134
sg94
I28
sg95
g98
sg99
I873
sbasbasbasbag0
(g19
g2
Ntp4698
Rp4699
(dp4700
g23
g1169
sg29
(lp4701
g0
(g19
g2
Ntp4702
Rp4703
(dp4704
g23
g85
sg29
(lp4705
g0
(g87
g25
Vread_registers
p4706
tp4707
Rp4708
(dp4709
g92
I10
sg93
I141
sg94
I29
sg95
g98
sg99
I889
sbasbag0
(g19
g2
Ntp4710
Rp4711
(dp4712
g23
g1184
sg29
(lp4713
g0
(g19
g2
Ntp4714
Rp4715
(dp4716
g23
g1191
sg29
(lp4717
g0
(g87
g25
Vin
p4718
tp4719
Rp4720
(dp4721
g92
I25
sg93
I143
sg94
I29
sg95
g1199
sg99
I904
sbasbag0
(g19
g2
Ntp4722
Rp4723
(dp4724
g23
g1205
sg29
(lp4725
g0
(g19
g2
Ntp4726
Rp4727
(dp4728
g23
g2949
sg29
(lp4729
g0
(g19
g2
Ntp4730
Rp4731
(dp4732
g23
g78
sg29
(lp4733
g0
(g19
g2
Ntp4734
Rp4735
(dp4736
g23
g85
sg29
(lp4737
g0
(g87
g25
VseL4_Word
p4738
tp4739
Rp4740
(dp4741
g92
I28
sg93
I145
sg94
I29
sg95
g98
sg99
I907
sbasbasbasbasbag0
(g19
g2
Ntp4742
Rp4743
(dp4744
g23
g85
sg29
(lp4745
g0
(g87
g25
Vtcb_cap
p4746
tp4747
Rp4748
(dp4749
g92
I38
sg93
I147
sg94
I29
sg95
g98
sg99
I917
sbasbasbag0
(g19
g2
Ntp4750
Rp4751
(dp4752
g23
g1184
sg29
(lp4753
g0
(g19
g2
Ntp4754
Rp4755
(dp4756
g23
g1191
sg29
(lp4757
g0
(g87
g25
Vout
p4758
tp4759
Rp4760
(dp4761
g92
I47
sg93
I150
sg94
I29
sg95
g4525
sg99
I926
sbasbag0
(g19
g2
Ntp4762
Rp4763
(dp4764
g23
g1205
sg29
(lp4765
g0
(g19
g2
Ntp4766
Rp4767
(dp4768
g23
g2949
sg29
(lp4769
g0
(g19
g2
Ntp4770
Rp4771
(dp4772
g23
g78
sg29
(lp4773
g0
(g19
g2
Ntp4774
Rp4775
(dp4776
g23
g85
sg29
(lp4777
g0
(g87
g25
VseL4_UserContext
p4778
tp4779
Rp4780
(dp4781
g92
I51
sg93
I152
sg94
I29
sg95
g98
sg99
I930
sbasbasbasbasbag0
(g19
g2
Ntp4782
Rp4783
(dp4784
g23
g85
sg29
(lp4785
g0
(g87
g25
Vregisters
p4786
tp4787
Rp4788
(dp4789
g92
I68
sg93
I154
sg94
I29
sg95
g98
sg99
I947
sbasbasbasbag0
(g19
g2
Ntp4790
Rp4791
(dp4792
g23
g1169
sg29
(lp4793
g0
(g19
g2
Ntp4794
Rp4795
(dp4796
g23
g85
sg29
(lp4797
g0
(g87
g25
Vread_register
p4798
tp4799
Rp4800
(dp4801
g92
I10
sg93
I161
sg94
I30
sg95
g98
sg99
I968
sbasbag0
(g19
g2
Ntp4802
Rp4803
(dp4804
g23
g1184
sg29
(lp4805
g0
(g19
g2
Ntp4806
Rp4807
(dp4808
g23
g1191
sg29
(lp4809
g0
(g87
g25
Vin
p4810
tp4811
Rp4812
(dp4813
g92
I24
sg93
I163
sg94
I30
sg95
g1199
sg99
I982
sbasbag0
(g19
g2
Ntp4814
Rp4815
(dp4816
g23
g1205
sg29
(lp4817
g0
(g19
g2
Ntp4818
Rp4819
(dp4820
g23
g2949
sg29
(lp4821
g0
(g19
g2
Ntp4822
Rp4823
(dp4824
g23
g78
sg29
(lp4825
g0
(g19
g2
Ntp4826
Rp4827
(dp4828
g23
g85
sg29
(lp4829
g0
(g87
g25
VseL4_Word
p4830
tp4831
Rp4832
(dp4833
g92
I27
sg93
I165
sg94
I30
sg95
g98
sg99
I985
sbasbasbasbasbag0
(g19
g2
Ntp4834
Rp4835
(dp4836
g23
g85
sg29
(lp4837
g0
(g87
g25
Vtcb_cap
p4838
tp4839
Rp4840
(dp4841
g92
I37
sg93
I167
sg94
I30
sg95
g98
sg99
I995
sbasbasbag0
(g19
g2
Ntp4842
Rp4843
(dp4844
g23
g1184
sg29
(lp4845
g0
(g19
g2
Ntp4846
Rp4847
(dp4848
g23
g1191
sg29
(lp4849
g0
(g87
g25
Vout
p4850
tp4851
Rp4852
(dp4853
g92
I46
sg93
I170
sg94
I30
sg95
g4525
sg99
I1004
sbasbag0
(g19
g2
Ntp4854
Rp4855
(dp4856
g23
g1205
sg29
(lp4857
g0
(g19
g2
Ntp4858
Rp4859
(dp4860
g23
g2949
sg29
(lp4861
g0
(g19
g2
Ntp4862
Rp4863
(dp4864
g23
g78
sg29
(lp4865
g0
(g19
g2
Ntp4866
Rp4867
(dp4868
g23
g85
sg29
(lp4869
g0
(g87
g25
VseL4_Word
p4870
tp4871
Rp4872
(dp4873
g92
I50
sg93
I172
sg94
I30
sg95
g98
sg99
I1008
sbasbasbasbasbag0
(g19
g2
Ntp4874
Rp4875
(dp4876
g23
g85
sg29
(lp4877
g0
(g87
g25
Vreg
p4878
tp4879
Rp4880
(dp4881
g92
I60
sg93
I174
sg94
I30
sg95
g98
sg99
I1018
sbasbasbag0
(g19
g2
Ntp4882
Rp4883
(dp4884
g23
g1184
sg29
(lp4885
g0
(g19
g2
Ntp4886
Rp4887
(dp4888
g23
g1191
sg29
(lp4889
g0
(g87
g25
Vin
p4890
tp4891
Rp4892
(dp4893
g92
I65
sg93
I177
sg94
I30
sg95
g1199
sg99
I1023
sbasbag0
(g19
g2
Ntp4894
Rp4895
(dp4896
g23
g1205
sg29
(lp4897
g0
(g19
g2
Ntp4898
Rp4899
(dp4900
g23
g2949
sg29
(lp4901
g0
(g19
g2
Ntp4902
Rp4903
(dp4904
g23
g78
sg29
(lp4905
g0
(g19
g2
Ntp4906
Rp4907
(dp4908
g23
g85
sg29
(lp4909
g0
(g87
g25
VseL4_Word
p4910
tp4911
Rp4912
(dp4913
g92
I68
sg93
I179
sg94
I30
sg95
g98
sg99
I1026
sbasbasbasbasbag0
(g19
g2
Ntp4914
Rp4915
(dp4916
g23
g85
sg29
(lp4917
g0
(g87
g25
Vreg_num
p4918
tp4919
Rp4920
(dp4921
g92
I78
sg93
I181
sg94
I30
sg95
g98
sg99
I1036
sbasbasbasbag0
(g19
g2
Ntp4922
Rp4923
(dp4924
g23
g1169
sg29
(lp4925
g0
(g19
g2
Ntp4926
Rp4927
(dp4928
g23
g1205
sg29
(lp4929
g0
(g19
g2
Ntp4930
Rp4931
(dp4932
g23
g1243
sg29
(lp4933
g0
(g87
g25
Vint
p4934
tp4935
Rp4936
(dp4937
g92
I5
sg93
I186
sg94
I31
sg95
g1251
sg99
I1050
sbasbasbag0
(g19
g2
Ntp4938
Rp4939
(dp4940
g23
g85
sg29
(lp4941
g0
(g87
g25
Vwrite_registers
p4942
tp4943
Rp4944
(dp4945
g92
I9
sg93
I188
sg94
I31
sg95
g98
sg99
I1054
sbasbag0
(g19
g2
Ntp4946
Rp4947
(dp4948
g23
g1184
sg29
(lp4949
g0
(g19
g2
Ntp4950
Rp4951
(dp4952
g23
g1191
sg29
(lp4953
g0
(g87
g25
Vin
p4954
tp4955
Rp4956
(dp4957
g92
I25
sg93
I190
sg94
I31
sg95
g1199
sg99
I1070
sbasbag0
(g19
g2
Ntp4958
Rp4959
(dp4960
g23
g1205
sg29
(lp4961
g0
(g19
g2
Ntp4962
Rp4963
(dp4964
g23
g2949
sg29
(lp4965
g0
(g19
g2
Ntp4966
Rp4967
(dp4968
g23
g78
sg29
(lp4969
g0
(g19
g2
Ntp4970
Rp4971
(dp4972
g23
g85
sg29
(lp4973
g0
(g87
g25
VseL4_Word
p4974
tp4975
Rp4976
(dp4977
g92
I28
sg93
I192
sg94
I31
sg95
g98
sg99
I1073
sbasbasbasbasbag0
(g19
g2
Ntp4978
Rp4979
(dp4980
g23
g85
sg29
(lp4981
g0
(g87
g25
Vtcb_cap
p4982
tp4983
Rp4984
(dp4985
g92
I38
sg93
I194
sg94
I31
sg95
g98
sg99
I1083
sbasbasbag0
(g19
g2
Ntp4986
Rp4987
(dp4988
g23
g1184
sg29
(lp4989
g0
(g19
g2
Ntp4990
Rp4991
(dp4992
g23
g1191
sg29
(lp4993
g0
(g87
g25
Vin
p4994
tp4995
Rp4996
(dp4997
g92
I47
sg93
I197
sg94
I31
sg95
g1199
sg99
I1092
sbasbag0
(g19
g2
Ntp4998
Rp4999
(dp5000
g23
g1205
sg29
(lp5001
g0
(g19
g2
Ntp5002
Rp5003
(dp5004
g23
g2949
sg29
(lp5005
g0
(g19
g2
Ntp5006
Rp5007
(dp5008
g23
g78
sg29
(lp5009
g0
(g19
g2
Ntp5010
Rp5011
(dp5012
g23
g85
sg29
(lp5013
g0
(g87
g25
VseL4_UserContext
p5014
tp5015
Rp5016
(dp5017
g92
I50
sg93
I199
sg94
I31
sg95
g98
sg99
I1095
sbasbasbasbasbag0
(g19
g2
Ntp5018
Rp5019
(dp5020
g23
g85
sg29
(lp5021
g0
(g87
g25
Vregisters
p5022
tp5023
Rp5024
(dp5025
g92
I67
sg93
I201
sg94
I31
sg95
g98
sg99
I1112
sbasbasbag0
(g19
g2
Ntp5026
Rp5027
(dp5028
g23
g1184
sg29
(lp5029
g0
(g19
g2
Ntp5030
Rp5031
(dp5032
g23
g1191
sg29
(lp5033
g0
(g87
g25
Vin
p5034
tp5035
Rp5036
(dp5037
g92
I78
sg93
I204
sg94
I31
sg95
g1199
sg99
I1123
sbasbag0
(g19
g2
Ntp5038
Rp5039
(dp5040
g23
g1205
sg29
(lp5041
g0
(g19
g2
Ntp5042
Rp5043
(dp5044
g23
g1243
sg29
(lp5045
g0
(g87
g25
Vint
p5046
tp5047
Rp5048
(dp5049
g92
I81
sg93
I206
sg94
I31
sg95
g1251
sg99
I1126
sbasbasbag0
(g19
g2
Ntp5050
Rp5051
(dp5052
g23
g85
sg29
(lp5053
g0
(g87
g25
Vlen
p5054
tp5055
Rp5056
(dp5057
g92
I85
sg93
I208
sg94
I31
sg95
g98
sg99
I1130
sbasbasbasbag0
(g19
g2
Ntp5058
Rp5059
(dp5060
g23
g1169
sg29
(lp5061
g0
(g19
g2
Ntp5062
Rp5063
(dp5064
g23
g1205
sg29
(lp5065
g0
(g19
g2
Ntp5066
Rp5067
(dp5068
g23
g1243
sg29
(lp5069
g0
(g87
g25
Vint
p5070
tp5071
Rp5072
(dp5073
g92
I5
sg93
I213
sg94
I32
sg95
g1251
sg99
I1140
sbasbasbag0
(g19
g2
Ntp5074
Rp5075
(dp5076
g23
g85
sg29
(lp5077
g0
(g87
g25
Vwrite_register
p5078
tp5079
Rp5080
(dp5081
g92
I9
sg93
I215
sg94
I32
sg95
g98
sg99
I1144
sbasbag0
(g19
g2
Ntp5082
Rp5083
(dp5084
g23
g1184
sg29
(lp5085
g0
(g19
g2
Ntp5086
Rp5087
(dp5088
g23
g1191
sg29
(lp5089
g0
(g87
g25
Vin
p5090
tp5091
Rp5092
(dp5093
g92
I24
sg93
I217
sg94
I32
sg95
g1199
sg99
I1159
sbasbag0
(g19
g2
Ntp5094
Rp5095
(dp5096
g23
g1205
sg29
(lp5097
g0
(g19
g2
Ntp5098
Rp5099
(dp5100
g23
g2949
sg29
(lp5101
g0
(g19
g2
Ntp5102
Rp5103
(dp5104
g23
g78
sg29
(lp5105
g0
(g19
g2
Ntp5106
Rp5107
(dp5108
g23
g85
sg29
(lp5109
g0
(g87
g25
VseL4_Word
p5110
tp5111
Rp5112
(dp5113
g92
I27
sg93
I219
sg94
I32
sg95
g98
sg99
I1162
sbasbasbasbasbag0
(g19
g2
Ntp5114
Rp5115
(dp5116
g23
g85
sg29
(lp5117
g0
(g87
g25
Vtcb_cap
p5118
tp5119
Rp5120
(dp5121
g92
I37
sg93
I221
sg94
I32
sg95
g98
sg99
I1172
sbasbasbag0
(g19
g2
Ntp5122
Rp5123
(dp5124
g23
g1184
sg29
(lp5125
g0
(g19
g2
Ntp5126
Rp5127
(dp5128
g23
g1191
sg29
(lp5129
g0
(g87
g25
Vin
p5130
tp5131
Rp5132
(dp5133
g92
I46
sg93
I224
sg94
I32
sg95
g1199
sg99
I1181
sbasbag0
(g19
g2
Ntp5134
Rp5135
(dp5136
g23
g1205
sg29
(lp5137
g0
(g19
g2
Ntp5138
Rp5139
(dp5140
g23
g2949
sg29
(lp5141
g0
(g19
g2
Ntp5142
Rp5143
(dp5144
g23
g78
sg29
(lp5145
g0
(g19
g2
Ntp5146
Rp5147
(dp5148
g23
g85
sg29
(lp5149
g0
(g87
g25
VseL4_Word
p5150
tp5151
Rp5152
(dp5153
g92
I49
sg93
I226
sg94
I32
sg95
g98
sg99
I1184
sbasbasbasbasbag0
(g19
g2
Ntp5154
Rp5155
(dp5156
g23
g85
sg29
(lp5157
g0
(g87
g25
Vdata
p5158
tp5159
Rp5160
(dp5161
g92
I59
sg93
I228
sg94
I32
sg95
g98
sg99
I1194
sbasbasbag0
(g19
g2
Ntp5162
Rp5163
(dp5164
g23
g1184
sg29
(lp5165
g0
(g19
g2
Ntp5166
Rp5167
(dp5168
g23
g1191
sg29
(lp5169
g0
(g87
g25
Vin
p5170
tp5171
Rp5172
(dp5173
g92
I65
sg93
I231
sg94
I32
sg95
g1199
sg99
I1200
sbasbag0
(g19
g2
Ntp5174
Rp5175
(dp5176
g23
g1205
sg29
(lp5177
g0
(g19
g2
Ntp5178
Rp5179
(dp5180
g23
g2949
sg29
(lp5181
g0
(g19
g2
Ntp5182
Rp5183
(dp5184
g23
g78
sg29
(lp5185
g0
(g19
g2
Ntp5186
Rp5187
(dp5188
g23
g85
sg29
(lp5189
g0
(g87
g25
VseL4_Word
p5190
tp5191
Rp5192
(dp5193
g92
I68
sg93
I233
sg94
I32
sg95
g98
sg99
I1203
sbasbasbasbasbag0
(g19
g2
Ntp5194
Rp5195
(dp5196
g23
g85
sg29
(lp5197
g0
(g87
g25
Vreg_num
p5198
tp5199
Rp5200
(dp5201
g92
I78
sg93
I235
sg94
I32
sg95
g98
sg99
I1213
sbasbasbasbag0
(g19
g2
Ntp5202
Rp5203
(dp5204
g23
g1169
sg29
(lp5205
g0
(g19
g2
Ntp5206
Rp5207
(dp5208
g23
g1205
sg29
(lp5209
g0
(g19
g2
Ntp5210
Rp5211
(dp5212
g23
g1243
sg29
(lp5213
g0
(g87
g25
Vint
p5214
tp5215
Rp5216
(dp5217
g92
I5
sg93
I240
sg94
I33
sg95
g1251
sg99
I1227
sbasbasbag0
(g19
g2
Ntp5218
Rp5219
(dp5220
g23
g85
sg29
(lp5221
g0
(g87
g25
Vinsert_break
p5222
tp5223
Rp5224
(dp5225
g92
I9
sg93
I242
sg94
I33
sg95
g98
sg99
I1231
sbasbag0
(g19
g2
Ntp5226
Rp5227
(dp5228
g23
g1184
sg29
(lp5229
g0
(g19
g2
Ntp5230
Rp5231
(dp5232
g23
g1191
sg29
(lp5233
g0
(g87
g25
Vin
p5234
tp5235
Rp5236
(dp5237
g92
I22
sg93
I244
sg94
I33
sg95
g1199
sg99
I1244
sbasbag0
(g19
g2
Ntp5238
Rp5239
(dp5240
g23
g1205
sg29
(lp5241
g0
(g19
g2
Ntp5242
Rp5243
(dp5244
g23
g2949
sg29
(lp5245
g0
(g19
g2
Ntp5246
Rp5247
(dp5248
g23
g78
sg29
(lp5249
g0
(g19
g2
Ntp5250
Rp5251
(dp5252
g23
g85
sg29
(lp5253
g0
(g87
g25
VseL4_Word
p5254
tp5255
Rp5256
(dp5257
g92
I25
sg93
I246
sg94
I33
sg95
g98
sg99
I1247
sbasbasbasbasbag0
(g19
g2
Ntp5258
Rp5259
(dp5260
g23
g85
sg29
(lp5261
g0
(g87
g25
Vtcb_cap
p5262
tp5263
Rp5264
(dp5265
g92
I35
sg93
I248
sg94
I33
sg95
g98
sg99
I1257
sbasbasbag0
(g19
g2
Ntp5266
Rp5267
(dp5268
g23
g1184
sg29
(lp5269
g0
(g19
g2
Ntp5270
Rp5271
(dp5272
g23
g1191
sg29
(lp5273
g0
(g87
g25
Vin
p5274
tp5275
Rp5276
(dp5277
g92
I44
sg93
I251
sg94
I33
sg95
g1199
sg99
I1266
sbasbag0
(g19
g2
Ntp5278
Rp5279
(dp5280
g23
g1205
sg29
(lp5281
g0
(g19
g2
Ntp5282
Rp5283
(dp5284
g23
g2949
sg29
(lp5285
g0
(g19
g2
Ntp5286
Rp5287
(dp5288
g23
g78
sg29
(lp5289
g0
(g19
g2
Ntp5290
Rp5291
(dp5292
g23
g85
sg29
(lp5293
g0
(g87
g25
VseL4_Word
p5294
tp5295
Rp5296
(dp5297
g92
I47
sg93
I253
sg94
I33
sg95
g98
sg99
I1269
sbasbasbasbasbag0
(g19
g2
Ntp5298
Rp5299
(dp5300
g23
g85
sg29
(lp5301
g0
(g87
g25
Vtype
p5302
tp5303
Rp5304
(dp5305
g92
I57
sg93
I255
sg94
I33
sg95
g98
sg99
I1279
sbasbasbag0
(g19
g2
Ntp5306
Rp5307
(dp5308
g23
g1184
sg29
(lp5309
g0
(g19
g2
Ntp5310
Rp5311
(dp5312
g23
g1191
sg29
(lp5313
g0
(g87
g25
Vin
p5314
tp5315
Rp5316
(dp5317
g92
I63
sg93
I258
sg94
I33
sg95
g1199
sg99
I1285
sbasbag0
(g19
g2
Ntp5318
Rp5319
(dp5320
g23
g1205
sg29
(lp5321
g0
(g19
g2
Ntp5322
Rp5323
(dp5324
g23
g2949
sg29
(lp5325
g0
(g19
g2
Ntp5326
Rp5327
(dp5328
g23
g78
sg29
(lp5329
g0
(g19
g2
Ntp5330
Rp5331
(dp5332
g23
g85
sg29
(lp5333
g0
(g87
g25
VseL4_Word
p5334
tp5335
Rp5336
(dp5337
g92
I66
sg93
I260
sg94
I33
sg95
g98
sg99
I1288
sbasbasbasbasbag0
(g19
g2
Ntp5338
Rp5339
(dp5340
g23
g85
sg29
(lp5341
g0
(g87
g25
Vaddr
p5342
tp5343
Rp5344
(dp5345
g92
I76
sg93
I262
sg94
I33
sg95
g98
sg99
I1298
sbasbasbag0
(g19
g2
Ntp5346
Rp5347
(dp5348
g23
g1184
sg29
(lp5349
g0
(g19
g2
Ntp5350
Rp5351
(dp5352
g23
g1191
sg29
(lp5353
g0
(g87
g25
Vin
p5354
tp5355
Rp5356
(dp5357
g92
I82
sg93
I265
sg94
I33
sg95
g1199
sg99
I1304
sbasbag0
(g19
g2
Ntp5358
Rp5359
(dp5360
g23
g1205
sg29
(lp5361
g0
(g19
g2
Ntp5362
Rp5363
(dp5364
g23
g2949
sg29
(lp5365
g0
(g19
g2
Ntp5366
Rp5367
(dp5368
g23
g78
sg29
(lp5369
g0
(g19
g2
Ntp5370
Rp5371
(dp5372
g23
g85
sg29
(lp5373
g0
(g87
g25
VseL4_Word
p5374
tp5375
Rp5376
(dp5377
g92
I85
sg93
I267
sg94
I33
sg95
g98
sg99
I1307
sbasbasbasbasbag0
(g19
g2
Ntp5378
Rp5379
(dp5380
g23
g85
sg29
(lp5381
g0
(g87
g25
Vsize
p5382
tp5383
Rp5384
(dp5385
g92
I95
sg93
I269
sg94
I33
sg95
g98
sg99
I1317
sbasbasbag0
(g19
g2
Ntp5386
Rp5387
(dp5388
g23
g1184
sg29
(lp5389
g0
(g19
g2
Ntp5390
Rp5391
(dp5392
g23
g1191
sg29
(lp5393
g0
(g87
g25
Vin
p5394
tp5395
Rp5396
(dp5397
g92
I101
sg93
I272
sg94
I33
sg95
g1199
sg99
I1323
sbasbag0
(g19
g2
Ntp5398
Rp5399
(dp5400
g23
g1205
sg29
(lp5401
g0
(g19
g2
Ntp5402
Rp5403
(dp5404
g23
g2949
sg29
(lp5405
g0
(g19
g2
Ntp5406
Rp5407
(dp5408
g23
g78
sg29
(lp5409
g0
(g19
g2
Ntp5410
Rp5411
(dp5412
g23
g85
sg29
(lp5413
g0
(g87
g25
VseL4_Word
p5414
tp5415
Rp5416
(dp5417
g92
I104
sg93
I274
sg94
I33
sg95
g98
sg99
I1326
sbasbasbasbasbag0
(g19
g2
Ntp5418
Rp5419
(dp5420
g23
g85
sg29
(lp5421
g0
(g87
g25
Vrw
p5422
tp5423
Rp5424
(dp5425
g92
I114
sg93
I276
sg94
I33
sg95
g98
sg99
I1336
sbasbasbasbag0
(g19
g2
Ntp5426
Rp5427
(dp5428
g23
g1169
sg29
(lp5429
g0
(g19
g2
Ntp5430
Rp5431
(dp5432
g23
g1205
sg29
(lp5433
g0
(g19
g2
Ntp5434
Rp5435
(dp5436
g23
g1243
sg29
(lp5437
g0
(g87
g25
Vint
p5438
tp5439
Rp5440
(dp5441
g92
I5
sg93
I281
sg94
I34
sg95
g1251
sg99
I1345
sbasbasbag0
(g19
g2
Ntp5442
Rp5443
(dp5444
g23
g85
sg29
(lp5445
g0
(g87
g25
Vremove_break
p5446
tp5447
Rp5448
(dp5449
g92
I9
sg93
I283
sg94
I34
sg95
g98
sg99
I1349
sbasbag0
(g19
g2
Ntp5450
Rp5451
(dp5452
g23
g1184
sg29
(lp5453
g0
(g19
g2
Ntp5454
Rp5455
(dp5456
g23
g1191
sg29
(lp5457
g0
(g87
g25
Vin
p5458
tp5459
Rp5460
(dp5461
g92
I22
sg93
I285
sg94
I34
sg95
g1199
sg99
I1362
sbasbag0
(g19
g2
Ntp5462
Rp5463
(dp5464
g23
g1205
sg29
(lp5465
g0
(g19
g2
Ntp5466
Rp5467
(dp5468
g23
g2949
sg29
(lp5469
g0
(g19
g2
Ntp5470
Rp5471
(dp5472
g23
g78
sg29
(lp5473
g0
(g19
g2
Ntp5474
Rp5475
(dp5476
g23
g85
sg29
(lp5477
g0
(g87
g25
VseL4_Word
p5478
tp5479
Rp5480
(dp5481
g92
I25
sg93
I287
sg94
I34
sg95
g98
sg99
I1365
sbasbasbasbasbag0
(g19
g2
Ntp5482
Rp5483
(dp5484
g23
g85
sg29
(lp5485
g0
(g87
g25
Vtcb_cap
p5486
tp5487
Rp5488
(dp5489
g92
I35
sg93
I289
sg94
I34
sg95
g98
sg99
I1375
sbasbasbag0
(g19
g2
Ntp5490
Rp5491
(dp5492
g23
g1184
sg29
(lp5493
g0
(g19
g2
Ntp5494
Rp5495
(dp5496
g23
g1191
sg29
(lp5497
g0
(g87
g25
Vin
p5498
tp5499
Rp5500
(dp5501
g92
I44
sg93
I292
sg94
I34
sg95
g1199
sg99
I1384
sbasbag0
(g19
g2
Ntp5502
Rp5503
(dp5504
g23
g1205
sg29
(lp5505
g0
(g19
g2
Ntp5506
Rp5507
(dp5508
g23
g2949
sg29
(lp5509
g0
(g19
g2
Ntp5510
Rp5511
(dp5512
g23
g78
sg29
(lp5513
g0
(g19
g2
Ntp5514
Rp5515
(dp5516
g23
g85
sg29
(lp5517
g0
(g87
g25
VseL4_Word
p5518
tp5519
Rp5520
(dp5521
g92
I47
sg93
I294
sg94
I34
sg95
g98
sg99
I1387
sbasbasbasbasbag0
(g19
g2
Ntp5522
Rp5523
(dp5524
g23
g85
sg29
(lp5525
g0
(g87
g25
Vtype
p5526
tp5527
Rp5528
(dp5529
g92
I57
sg93
I296
sg94
I34
sg95
g98
sg99
I1397
sbasbasbag0
(g19
g2
Ntp5530
Rp5531
(dp5532
g23
g1184
sg29
(lp5533
g0
(g19
g2
Ntp5534
Rp5535
(dp5536
g23
g1191
sg29
(lp5537
g0
(g87
g25
Vin
p5538
tp5539
Rp5540
(dp5541
g92
I63
sg93
I299
sg94
I34
sg95
g1199
sg99
I1403
sbasbag0
(g19
g2
Ntp5542
Rp5543
(dp5544
g23
g1205
sg29
(lp5545
g0
(g19
g2
Ntp5546
Rp5547
(dp5548
g23
g2949
sg29
(lp5549
g0
(g19
g2
Ntp5550
Rp5551
(dp5552
g23
g78
sg29
(lp5553
g0
(g19
g2
Ntp5554
Rp5555
(dp5556
g23
g85
sg29
(lp5557
g0
(g87
g25
VseL4_Word
p5558
tp5559
Rp5560
(dp5561
g92
I66
sg93
I301
sg94
I34
sg95
g98
sg99
I1406
sbasbasbasbasbag0
(g19
g2
Ntp5562
Rp5563
(dp5564
g23
g85
sg29
(lp5565
g0
(g87
g25
Vaddr
p5566
tp5567
Rp5568
(dp5569
g92
I76
sg93
I303
sg94
I34
sg95
g98
sg99
I1416
sbasbasbag0
(g19
g2
Ntp5570
Rp5571
(dp5572
g23
g1184
sg29
(lp5573
g0
(g19
g2
Ntp5574
Rp5575
(dp5576
g23
g1191
sg29
(lp5577
g0
(g87
g25
Vin
p5578
tp5579
Rp5580
(dp5581
g92
I82
sg93
I306
sg94
I34
sg95
g1199
sg99
I1422
sbasbag0
(g19
g2
Ntp5582
Rp5583
(dp5584
g23
g1205
sg29
(lp5585
g0
(g19
g2
Ntp5586
Rp5587
(dp5588
g23
g2949
sg29
(lp5589
g0
(g19
g2
Ntp5590
Rp5591
(dp5592
g23
g78
sg29
(lp5593
g0
(g19
g2
Ntp5594
Rp5595
(dp5596
g23
g85
sg29
(lp5597
g0
(g87
g25
VseL4_Word
p5598
tp5599
Rp5600
(dp5601
g92
I85
sg93
I308
sg94
I34
sg95
g98
sg99
I1425
sbasbasbasbasbag0
(g19
g2
Ntp5602
Rp5603
(dp5604
g23
g85
sg29
(lp5605
g0
(g87
g25
Vsize
p5606
tp5607
Rp5608
(dp5609
g92
I95
sg93
I310
sg94
I34
sg95
g98
sg99
I1435
sbasbasbag0
(g19
g2
Ntp5610
Rp5611
(dp5612
g23
g1184
sg29
(lp5613
g0
(g19
g2
Ntp5614
Rp5615
(dp5616
g23
g1191
sg29
(lp5617
g0
(g87
g25
Vin
p5618
tp5619
Rp5620
(dp5621
g92
I101
sg93
I313
sg94
I34
sg95
g1199
sg99
I1441
sbasbag0
(g19
g2
Ntp5622
Rp5623
(dp5624
g23
g1205
sg29
(lp5625
g0
(g19
g2
Ntp5626
Rp5627
(dp5628
g23
g2949
sg29
(lp5629
g0
(g19
g2
Ntp5630
Rp5631
(dp5632
g23
g78
sg29
(lp5633
g0
(g19
g2
Ntp5634
Rp5635
(dp5636
g23
g85
sg29
(lp5637
g0
(g87
g25
VseL4_Word
p5638
tp5639
Rp5640
(dp5641
g92
I104
sg93
I315
sg94
I34
sg95
g98
sg99
I1444
sbasbasbasbasbag0
(g19
g2
Ntp5642
Rp5643
(dp5644
g23
g85
sg29
(lp5645
g0
(g87
g25
Vrw
p5646
tp5647
Rp5648
(dp5649
g92
I114
sg93
I317
sg94
I34
sg95
g98
sg99
I1454
sbasbasbasbag0
(g19
g2
Ntp5650
Rp5651
(dp5652
g23
g1169
sg29
(lp5653
g0
(g19
g2
Ntp5654
Rp5655
(dp5656
g23
g1205
sg29
(lp5657
g0
(g19
g2
Ntp5658
Rp5659
(dp5660
g23
g1243
sg29
(lp5661
g0
(g87
g25
Vint
p5662
tp5663
Rp5664
(dp5665
g92
I5
sg93
I322
sg94
I35
sg95
g1251
sg99
I1463
sbasbasbag0
(g19
g2
Ntp5666
Rp5667
(dp5668
g23
g85
sg29
(lp5669
g0
(g87
g25
Vresume
p5670
tp5671
Rp5672
(dp5673
g92
I9
sg93
I324
sg94
I35
sg95
g98
sg99
I1467
sbasbag0
(g19
g2
Ntp5674
Rp5675
(dp5676
g23
g1184
sg29
(lp5677
g0
(g19
g2
Ntp5678
Rp5679
(dp5680
g23
g1191
sg29
(lp5681
g0
(g87
g25
Vin
p5682
tp5683
Rp5684
(dp5685
g92
I16
sg93
I326
sg94
I35
sg95
g1199
sg99
I1474
sbasbag0
(g19
g2
Ntp5686
Rp5687
(dp5688
g23
g1205
sg29
(lp5689
g0
(g19
g2
Ntp5690
Rp5691
(dp5692
g23
g2949
sg29
(lp5693
g0
(g19
g2
Ntp5694
Rp5695
(dp5696
g23
g78
sg29
(lp5697
g0
(g19
g2
Ntp5698
Rp5699
(dp5700
g23
g85
sg29
(lp5701
g0
(g87
g25
VseL4_Word
p5702
tp5703
Rp5704
(dp5705
g92
I19
sg93
I328
sg94
I35
sg95
g98
sg99
I1477
sbasbasbasbasbag0
(g19
g2
Ntp5706
Rp5707
(dp5708
g23
g85
sg29
(lp5709
g0
(g87
g25
Vtcb_cap
p5710
tp5711
Rp5712
(dp5713
g92
I29
sg93
I330
sg94
I35
sg95
g98
sg99
I1487
sbasbasbasbag0
(g19
g2
Ntp5714
Rp5715
(dp5716
g23
g1169
sg29
(lp5717
g0
(g19
g2
Ntp5718
Rp5719
(dp5720
g23
g1205
sg29
(lp5721
g0
(g19
g2
Ntp5722
Rp5723
(dp5724
g23
g1243
sg29
(lp5725
g0
(g87
g25
Vint
p5726
tp5727
Rp5728
(dp5729
g92
I5
sg93
I335
sg94
I36
sg95
g1251
sg99
I1501
sbasbasbag0
(g19
g2
Ntp5730
Rp5731
(dp5732
g23
g85
sg29
(lp5733
g0
(g87
g25
Vstep
p5734
tp5735
Rp5736
(dp5737
g92
I9
sg93
I337
sg94
I36
sg95
g98
sg99
I1505
sbasbag0
(g19
g2
Ntp5738
Rp5739
(dp5740
g23
g1184
sg29
(lp5741
g0
(g19
g2
Ntp5742
Rp5743
(dp5744
g23
g1191
sg29
(lp5745
g0
(g87
g25
Vin
p5746
tp5747
Rp5748
(dp5749
g92
I14
sg93
I339
sg94
I36
sg95
g1199
sg99
I1510
sbasbag0
(g19
g2
Ntp5750
Rp5751
(dp5752
g23
g1205
sg29
(lp5753
g0
(g19
g2
Ntp5754
Rp5755
(dp5756
g23
g2949
sg29
(lp5757
g0
(g19
g2
Ntp5758
Rp5759
(dp5760
g23
g78
sg29
(lp5761
g0
(g19
g2
Ntp5762
Rp5763
(dp5764
g23
g85
sg29
(lp5765
g0
(g87
g25
VseL4_Word
p5766
tp5767
Rp5768
(dp5769
g92
I17
sg93
I341
sg94
I36
sg95
g98
sg99
I1513
sbasbasbasbasbag0
(g19
g2
Ntp5770
Rp5771
(dp5772
g23
g85
sg29
(lp5773
g0
(g87
g25
Vtcb_cap
p5774
tp5775
Rp5776
(dp5777
g92
I27
sg93
I343
sg94
I36
sg95
g98
sg99
I1523
sbasbasbasbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5778
sbsg987
g4389
sg6
g4
sg1362
(lp5779
g0
(g1364
g2
Ntp5780
Rp5781
(dp5782
g1368
(g0
(g1369
g2
Ntp5783
Rp5784
(dp5785
g1012
g4461
sg7
g0
(g13
g2
Ntp5786
Rp5787
(dp5788
g17
I00
sg18
g4432
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5789
sbsg1378
I00
sg987
g4469
sg6
g5781
sg1379
g4441
sg995
I01
sbg0
(g1369
g2
Ntp5790
Rp5791
(dp5792
g1012
g4501
sg7
g0
(g13
g2
Ntp5793
Rp5794
(dp5795
g17
I00
sg18
g4472
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5796
sbsg1378
I00
sg987
g4509
sg6
g5781
sg1379
g4481
sg995
I01
sbg0
(g1369
g2
Ntp5797
Rp5798
(dp5799
g1012
g4544
sg7
g0
(g13
g2
Ntp5800
Rp5801
(dp5802
g17
I00
sg18
g4512
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5803
sbsg1378
I00
sg987
g4552
sg6
g5781
sg1379
g4521
sg995
I01
sbtp5804
sg7
g0
(g13
g2
Ntp5805
Rp5806
(dp5807
g17
I00
sg18
g4408
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5808
sbsg1393
g1383
sg987
g4429
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5809
Rp5810
(dp5811
g1368
(g0
(g1369
g2
Ntp5812
Rp5813
(dp5814
g1012
g4608
sg7
g0
(g13
g2
Ntp5815
Rp5816
(dp5817
g17
I00
sg18
g4579
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5818
sbsg1378
I00
sg987
g4616
sg6
g5810
sg1379
g4588
sg995
I01
sbg0
(g1369
g2
Ntp5819
Rp5820
(dp5821
g1012
g4648
sg7
g0
(g13
g2
Ntp5822
Rp5823
(dp5824
g17
I00
sg18
g4619
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5825
sbsg1378
I00
sg987
g4656
sg6
g5810
sg1379
g4628
sg995
I01
sbg0
(g1369
g2
Ntp5826
Rp5827
(dp5828
g1012
g4688
sg7
g0
(g13
g2
Ntp5829
Rp5830
(dp5831
g17
I00
sg18
g4659
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5832
sbsg1378
I00
sg987
g4696
sg6
g5810
sg1379
g4668
sg995
I01
sbtp5833
sg7
g0
(g13
g2
Ntp5834
Rp5835
(dp5836
g17
I00
sg18
g4555
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5837
sbsg1393
g1383
sg987
g4576
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5838
Rp5839
(dp5840
g1368
(g0
(g1369
g2
Ntp5841
Rp5842
(dp5843
g1012
g4740
sg7
g0
(g13
g2
Ntp5844
Rp5845
(dp5846
g17
I00
sg18
g4711
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5847
sbsg1378
I00
sg987
g4748
sg6
g5839
sg1379
g4720
sg995
I01
sbg0
(g1369
g2
Ntp5848
Rp5849
(dp5850
g1012
g4780
sg7
g0
(g13
g2
Ntp5851
Rp5852
(dp5853
g17
I00
sg18
g4751
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5854
sbsg1378
I00
sg987
g4788
sg6
g5839
sg1379
g4760
sg995
I01
sbtp5855
sg7
g0
(g13
g2
Ntp5856
Rp5857
(dp5858
g17
I00
sg18
g4699
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5859
sbsg1393
Nsg987
g4708
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5860
Rp5861
(dp5862
g1368
(g0
(g1369
g2
Ntp5863
Rp5864
(dp5865
g1012
g4832
sg7
g0
(g13
g2
Ntp5866
Rp5867
(dp5868
g17
I00
sg18
g4803
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5869
sbsg1378
I00
sg987
g4840
sg6
g5861
sg1379
g4812
sg995
I01
sbg0
(g1369
g2
Ntp5870
Rp5871
(dp5872
g1012
g4872
sg7
g0
(g13
g2
Ntp5873
Rp5874
(dp5875
g17
I00
sg18
g4843
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5876
sbsg1378
I00
sg987
g4880
sg6
g5861
sg1379
g4852
sg995
I01
sbg0
(g1369
g2
Ntp5877
Rp5878
(dp5879
g1012
g4912
sg7
g0
(g13
g2
Ntp5880
Rp5881
(dp5882
g17
I00
sg18
g4883
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5883
sbsg1378
I00
sg987
g4920
sg6
g5861
sg1379
g4892
sg995
I01
sbtp5884
sg7
g0
(g13
g2
Ntp5885
Rp5886
(dp5887
g17
I00
sg18
g4791
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5888
sbsg1393
Nsg987
g4800
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5889
Rp5890
(dp5891
g1368
(g0
(g1369
g2
Ntp5892
Rp5893
(dp5894
g1012
g4976
sg7
g0
(g13
g2
Ntp5895
Rp5896
(dp5897
g17
I00
sg18
g4947
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5898
sbsg1378
I00
sg987
g4984
sg6
g5890
sg1379
g4956
sg995
I01
sbg0
(g1369
g2
Ntp5899
Rp5900
(dp5901
g1012
g5016
sg7
g0
(g13
g2
Ntp5902
Rp5903
(dp5904
g17
I00
sg18
g4987
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5905
sbsg1378
I00
sg987
g5024
sg6
g5890
sg1379
g4996
sg995
I01
sbg0
(g1369
g2
Ntp5906
Rp5907
(dp5908
g1012
g1383
sg7
g0
(g13
g2
Ntp5909
Rp5910
(dp5911
g17
I00
sg18
g5027
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5912
sbsg1378
I00
sg987
g5056
sg6
g5890
sg1379
g5036
sg995
I01
sbtp5913
sg7
g0
(g13
g2
Ntp5914
Rp5915
(dp5916
g17
I00
sg18
g4923
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5917
sbsg1393
g1383
sg987
g4944
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5918
Rp5919
(dp5920
g1368
(g0
(g1369
g2
Ntp5921
Rp5922
(dp5923
g1012
g5112
sg7
g0
(g13
g2
Ntp5924
Rp5925
(dp5926
g17
I00
sg18
g5083
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5927
sbsg1378
I00
sg987
g5120
sg6
g5919
sg1379
g5092
sg995
I01
sbg0
(g1369
g2
Ntp5928
Rp5929
(dp5930
g1012
g5152
sg7
g0
(g13
g2
Ntp5931
Rp5932
(dp5933
g17
I00
sg18
g5123
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5934
sbsg1378
I00
sg987
g5160
sg6
g5919
sg1379
g5132
sg995
I01
sbg0
(g1369
g2
Ntp5935
Rp5936
(dp5937
g1012
g5192
sg7
g0
(g13
g2
Ntp5938
Rp5939
(dp5940
g17
I00
sg18
g5163
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5941
sbsg1378
I00
sg987
g5200
sg6
g5919
sg1379
g5172
sg995
I01
sbtp5942
sg7
g0
(g13
g2
Ntp5943
Rp5944
(dp5945
g17
I00
sg18
g5059
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5946
sbsg1393
g1383
sg987
g5080
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5947
Rp5948
(dp5949
g1368
(g0
(g1369
g2
Ntp5950
Rp5951
(dp5952
g1012
g5256
sg7
g0
(g13
g2
Ntp5953
Rp5954
(dp5955
g17
I00
sg18
g5227
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5956
sbsg1378
I00
sg987
g5264
sg6
g5948
sg1379
g5236
sg995
I01
sbg0
(g1369
g2
Ntp5957
Rp5958
(dp5959
g1012
g5296
sg7
g0
(g13
g2
Ntp5960
Rp5961
(dp5962
g17
I00
sg18
g5267
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5963
sbsg1378
I00
sg987
g5304
sg6
g5948
sg1379
g5276
sg995
I01
sbg0
(g1369
g2
Ntp5964
Rp5965
(dp5966
g1012
g5336
sg7
g0
(g13
g2
Ntp5967
Rp5968
(dp5969
g17
I00
sg18
g5307
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5970
sbsg1378
I00
sg987
g5344
sg6
g5948
sg1379
g5316
sg995
I01
sbg0
(g1369
g2
Ntp5971
Rp5972
(dp5973
g1012
g5376
sg7
g0
(g13
g2
Ntp5974
Rp5975
(dp5976
g17
I00
sg18
g5347
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5977
sbsg1378
I00
sg987
g5384
sg6
g5948
sg1379
g5356
sg995
I01
sbg0
(g1369
g2
Ntp5978
Rp5979
(dp5980
g1012
g5416
sg7
g0
(g13
g2
Ntp5981
Rp5982
(dp5983
g17
I00
sg18
g5387
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5984
sbsg1378
I00
sg987
g5424
sg6
g5948
sg1379
g5396
sg995
I01
sbtp5985
sg7
g0
(g13
g2
Ntp5986
Rp5987
(dp5988
g17
I00
sg18
g5203
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5989
sbsg1393
g1383
sg987
g5224
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp5990
Rp5991
(dp5992
g1368
(g0
(g1369
g2
Ntp5993
Rp5994
(dp5995
g1012
g5480
sg7
g0
(g13
g2
Ntp5996
Rp5997
(dp5998
g17
I00
sg18
g5451
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p5999
sbsg1378
I00
sg987
g5488
sg6
g5991
sg1379
g5460
sg995
I01
sbg0
(g1369
g2
Ntp6000
Rp6001
(dp6002
g1012
g5520
sg7
g0
(g13
g2
Ntp6003
Rp6004
(dp6005
g17
I00
sg18
g5491
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6006
sbsg1378
I00
sg987
g5528
sg6
g5991
sg1379
g5500
sg995
I01
sbg0
(g1369
g2
Ntp6007
Rp6008
(dp6009
g1012
g5560
sg7
g0
(g13
g2
Ntp6010
Rp6011
(dp6012
g17
I00
sg18
g5531
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6013
sbsg1378
I00
sg987
g5568
sg6
g5991
sg1379
g5540
sg995
I01
sbg0
(g1369
g2
Ntp6014
Rp6015
(dp6016
g1012
g5600
sg7
g0
(g13
g2
Ntp6017
Rp6018
(dp6019
g17
I00
sg18
g5571
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6020
sbsg1378
I00
sg987
g5608
sg6
g5991
sg1379
g5580
sg995
I01
sbg0
(g1369
g2
Ntp6021
Rp6022
(dp6023
g1012
g5640
sg7
g0
(g13
g2
Ntp6024
Rp6025
(dp6026
g17
I00
sg18
g5611
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6027
sbsg1378
I00
sg987
g5648
sg6
g5991
sg1379
g5620
sg995
I01
sbtp6028
sg7
g0
(g13
g2
Ntp6029
Rp6030
(dp6031
g17
I00
sg18
g5427
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6032
sbsg1393
g1383
sg987
g5448
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp6033
Rp6034
(dp6035
g1368
(g0
(g1369
g2
Ntp6036
Rp6037
(dp6038
g1012
g5704
sg7
g0
(g13
g2
Ntp6039
Rp6040
(dp6041
g17
I00
sg18
g5675
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6042
sbsg1378
I00
sg987
g5712
sg6
g6034
sg1379
g5684
sg995
I01
sbtp6043
sg7
g0
(g13
g2
Ntp6044
Rp6045
(dp6046
g17
I00
sg18
g5651
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6047
sbsg1393
g1383
sg987
g5672
sg6
g4374
sg995
I01
sbag0
(g1364
g2
Ntp6048
Rp6049
(dp6050
g1368
(g0
(g1369
g2
Ntp6051
Rp6052
(dp6053
g1012
g5768
sg7
g0
(g13
g2
Ntp6054
Rp6055
(dp6056
g17
I00
sg18
g5739
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6057
sbsg1378
I00
sg987
g5776
sg6
g6049
sg1379
g5748
sg995
I01
sbtp6058
sg7
g0
(g13
g2
Ntp6059
Rp6060
(dp6061
g17
I00
sg18
g5715
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6062
sbsg1393
g1383
sg987
g5736
sg6
g4374
sg995
I01
sbasg1425
(lp6063
g0
(g4220
g2
Ntp6064
Rp6065
(dp6066
g6
g4374
sg7
g0
(g13
g2
Ntp6067
Rp6068
(dp6069
g17
I00
sg18
g4396
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6070
sbsg4228
I00
sg995
I01
sg4229
Vcamkes/gdb/delegate_types.h
p6071
sbasg990
(dp6072
g4708
g5839
sg5448
g5991
sg5672
g6034
sg5224
g5948
sg5080
g5919
sg5736
g6049
sg4944
g5890
sg4800
g5861
sg4576
g5810
sg4429
g5781
ssg1428
(lp6073
sg995
I01
sbg0
(g1135
g2
Ntp6074
Rp6075
(dp6076
g7
g0
(g13
g2
Ntp6077
Rp6078
(dp6079
g17
I00
sg18
g0
(g19
g2
Ntp6080
Rp6081
(dp6082
g23
g1147
sg29
(lp6083
g0
(g19
g2
Ntp6084
Rp6085
(dp6086
g23
g85
sg29
(lp6087
g0
(g87
g25
VCAmkES_Debug
p6088
tp6089
Rp6090
(dp6091
g92
I11
sg93
I353
sg94
I39
sg95
g98
sg99
I1547
sbasbag0
(g19
g2
Ntp6092
Rp6093
(dp6094
g23
g1162
sg29
(lp6095
g0
(g19
g2
Ntp6096
Rp6097
(dp6098
g23
g1169
sg29
(lp6099
g0
(g19
g2
Ntp6100
Rp6101
(dp6102
g23
g85
sg29
(lp6103
g0
(g87
g25
Vdebug
p6104
tp6105
Rp6106
(dp6107
g92
I8
sg93
I361
sg94
I40
sg95
g98
sg99
I1570
sbasbag0
(g19
g2
Ntp6108
Rp6109
(dp6110
g23
g1184
sg29
(lp6111
g0
(g19
g2
Ntp6112
Rp6113
(dp6114
g23
g1191
sg29
(lp6115
g0
(g87
g25
Vinout
p6116
tp6117
Rp6118
(dp6119
g92
I14
sg93
I363
sg94
I40
sg95
g0
(g24
g25
VINOUT
p6120
tp6121
Rp6122
sg99
I1576
sbasbag0
(g19
g2
Ntp6123
Rp6124
(dp6125
g23
g1205
sg29
(lp6126
g0
(g19
g2
Ntp6127
Rp6128
(dp6129
g23
g1243
sg29
(lp6130
g0
(g87
g25
Vint
p6131
tp6132
Rp6133
(dp6134
g92
I20
sg93
I365
sg94
I40
sg95
g1251
sg99
I1582
sbasbasbag0
(g19
g2
Ntp6135
Rp6136
(dp6137
g23
g85
sg29
(lp6138
g0
(g87
g25
Vnum
p6139
tp6140
Rp6141
(dp6142
g92
I24
sg93
I367
sg94
I40
sg95
g98
sg99
I1586
sbasbasbasbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6143
sbsg987
g6090
sg6
g4
sg1362
(lp6144
g0
(g1364
g2
Ntp6145
Rp6146
(dp6147
g1368
(g0
(g1369
g2
Ntp6148
Rp6149
(dp6150
g1012
g1383
sg7
g0
(g13
g2
Ntp6151
Rp6152
(dp6153
g17
I00
sg18
g6109
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6154
sbsg1378
I00
sg987
g6141
sg6
g6146
sg1379
g6118
sg995
I01
sbtp6155
sg7
g0
(g13
g2
Ntp6156
Rp6157
(dp6158
g17
I00
sg18
g6097
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6159
sbsg1393
Nsg987
g6106
sg6
g6075
sg995
I01
sbasg1425
(lp6160
sg990
(dp6161
g6106
g6146
ssg1428
(lp6162
sg995
I01
sbg0
(g1013
g2
Ntp6163
Rp6164
(dp6165
g1017
(g0
(ccamkes.ast.objects
Mutex
p6166
g2
Ntp6167
Rp6168
(dp6169
g6
g6164
sg7
g0
(g13
g2
Ntp6170
Rp6171
(dp6172
g17
I00
sg18
g0
(g19
g2
Ntp6173
Rp6174
(dp6175
g23
g0
(g24
g25
Vmutex
p6176
tp6177
Rp6178
sg29
(lp6179
g0
(g19
g2
Ntp6180
Rp6181
(dp6182
g23
g85
sg29
(lp6183
g0
(g87
g25
Vserial
p6184
tp6185
Rp6186
(dp6187
g92
I13
sg93
I432
sg94
I49
sg95
g98
sg99
I1788
sbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6188
sbsg995
I01
sg987
g6186
sbtp6189
sg1018
(lp6190
g0
(ccamkes.ast.objects
BinarySemaphore
p6191
g2
Ntp6192
Rp6193
(dp6194
g6
g6164
sg7
g0
(g13
g2
Ntp6195
Rp6196
(dp6197
g17
I00
sg18
g0
(g19
g2
Ntp6198
Rp6199
(dp6200
g23
g0
(g24
g25
Vbinary_semaphore
p6201
tp6202
Rp6203
sg29
(lp6204
g0
(g19
g2
Ntp6205
Rp6206
(dp6207
g23
g85
sg29
(lp6208
g0
(g87
g25
Vb
p6209
tp6210
Rp6211
(dp6212
g92
I24
sg93
I424
sg94
I48
sg95
g98
sg99
I1773
sbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6213
sbsg995
I01
sg987
g6211
sbasg7
g0
(g13
g2
Ntp6214
Rp6215
(dp6216
g17
I00
sg18
g0
(g19
g2
Ntp6217
Rp6218
(dp6219
g23
g1028
sg29
(lp6220
g0
(g19
g2
Ntp6221
Rp6222
(dp6223
g23
g85
sg29
(lp6224
g0
(g87
g25
Vdebug_server
p6225
tp6226
Rp6227
(dp6228
g92
I11
sg93
I378
sg94
I43
sg95
g98
sg99
I1607
sbasbag0
(g19
g2
Ntp6229
Rp6230
(dp6231
g23
g1043
sg29
(lp6232
g0
(g19
g2
Ntp6233
Rp6234
(dp6235
g23
g1050
sg29
(lp6236
g0
(g19
g2
Ntp6237
Rp6238
(dp6239
g23
g78
sg29
(lp6240
g0
(g19
g2
Ntp6241
Rp6242
(dp6243
g23
g85
sg29
(lp6244
g0
(g87
g25
VCAmkES_Debug
p6245
tp6246
Rp6247
(dp6248
g92
I12
sg93
I386
sg94
I44
sg95
g98
sg99
I1634
sbasbasbag0
(g19
g2
Ntp6249
Rp6250
(dp6251
g23
g85
sg29
(lp6252
g0
(g87
g25
Vclient_fault
p6253
tp6254
Rp6255
(dp6256
g92
I25
sg93
I388
sg94
I44
sg95
g98
sg99
I1647
sbasbasbag0
(g19
g2
Ntp6257
Rp6258
(dp6259
g23
g1077
sg29
(lp6260
g0
(g19
g2
Ntp6261
Rp6262
(dp6263
g23
g78
sg29
(lp6264
g0
(g19
g2
Ntp6265
Rp6266
(dp6267
g23
g85
sg29
(lp6268
g0
(g87
g25
VIOPort
p6269
tp6270
Rp6271
(dp6272
g92
I8
sg93
I395
sg94
I45
sg95
g98
sg99
I1669
sbasbasbag0
(g19
g2
Ntp6273
Rp6274
(dp6275
g23
g85
sg29
(lp6276
g0
(g87
g25
Vserial_port
p6277
tp6278
Rp6279
(dp6280
g92
I15
sg93
I397
sg94
I45
sg95
g98
sg99
I1676
sbasbasbag0
(g19
g2
Ntp6281
Rp6282
(dp6283
g23
g1077
sg29
(lp6284
g0
(g19
g2
Ntp6285
Rp6286
(dp6287
g23
g78
sg29
(lp6288
g0
(g19
g2
Ntp6289
Rp6290
(dp6291
g23
g85
sg29
(lp6292
g0
(g87
g25
VGDB_delegate
p6293
tp6294
Rp6295
(dp6296
g92
I8
sg93
I404
sg94
I46
sg95
g98
sg99
I1697
sbasbasbag0
(g19
g2
Ntp6297
Rp6298
(dp6299
g23
g85
sg29
(lp6300
g0
(g87
g25
Vdelegate
p6301
tp6302
Rp6303
(dp6304
g92
I21
sg93
I406
sg94
I46
sg95
g98
sg99
I1710
sbasbasbag0
(g19
g2
Ntp6305
Rp6306
(dp6307
g23
g0
(g24
g25
Vconsumes
p6308
tp6309
Rp6310
sg29
(lp6311
g0
(g19
g2
Ntp6312
Rp6313
(dp6314
g23
g85
sg29
(lp6315
g0
(g87
g25
VIRQ3
p6316
tp6317
Rp6318
(dp6319
g92
I12
sg93
I413
sg94
I47
sg95
g98
sg99
I1732
sbasbag0
(g19
g2
Ntp6320
Rp6321
(dp6322
g23
g85
sg29
(lp6323
g0
(g87
g25
Vserial_irq
p6324
tp6325
Rp6326
(dp6327
g92
I17
sg93
I415
sg94
I47
sg95
g98
sg99
I1737
sbasbasbag6199
ag6174
asbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6328
sbsg977
Nsg1125
(tsg996
Nsg1126
I00
sg1127
(tsg987
g6227
sg6
g4
sg1128
I00
sg1129
(g0
(ccamkes.ast.objects
Consumes
p6329
g2
Ntp6330
Rp6331
(dp6332
g1012
g6318
sg7
g0
(g13
g2
Ntp6333
Rp6334
(dp6335
g17
I00
sg18
g6306
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6336
sbsg987
g6326
sg6
g6164
sg1848
I00
sg995
I01
sbtp6337
sg1130
(g0
(g1131
g2
Ntp6338
Rp6339
(dp6340
g6
g6164
sg1012
g6075
sg7
g0
(g13
g2
Ntp6341
Rp6342
(dp6343
g17
I00
sg18
g6234
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6344
sbsg995
I01
sg987
g6255
sbtp6345
sg1425
(tsg990
(dp6346
g6255
g6339
sg6211
g6193
sg6326
g6331
sg6279
g0
(g1436
g2
Ntp6347
Rp6348
(dp6349
g1012
g2896
sg7
g0
(g13
g2
Ntp6350
Rp6351
(dp6352
g17
I00
sg18
g6258
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6353
sbsg987
g6279
sg6
g6164
sg1848
I00
sg995
I01
sbsg6303
g0
(g1436
g2
Ntp6354
Rp6355
(dp6356
g1012
g4374
sg7
g0
(g13
g2
Ntp6357
Rp6358
(dp6359
g17
I00
sg18
g6282
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6360
sbsg987
g6303
sg6
g6164
sg1848
I00
sg995
I01
sbsg6186
g6168
ssg2054
(g6348
g6355
tp6361
sg1428
(tsg2056
(tsg995
I01
sbg0
(g1013
g2
Ntp6362
Rp6363
(dp6364
g1017
(tsg1018
(lp6365
sg7
g0
(g13
g2
Ntp6366
Rp6367
(dp6368
g17
I00
sg18
g0
(g19
g2
Ntp6369
Rp6370
(dp6371
g23
g1028
sg29
(lp6372
g0
(g19
g2
Ntp6373
Rp6374
(dp6375
g23
g85
sg29
(lp6376
g0
(g87
g25
Vdebug_serial
p6377
tp6378
Rp6379
(dp6380
g92
I11
sg93
I441
sg94
I52
sg95
g98
sg99
I1810
sbasbag0
(g19
g2
Ntp6381
Rp6382
(dp6383
g23
g1043
sg29
(lp6384
g0
(g19
g2
Ntp6385
Rp6386
(dp6387
g23
g0
(g24
g25
Vhardware
p6388
tp6389
Rp6390
sg29
(lp6391
sbag0
(g19
g2
Ntp6392
Rp6393
(dp6394
g23
g1050
sg29
(lp6395
g0
(g19
g2
Ntp6396
Rp6397
(dp6398
g23
g78
sg29
(lp6399
g0
(g19
g2
Ntp6400
Rp6401
(dp6402
g23
g85
sg29
(lp6403
g0
(g87
g25
VIOPort
p6404
tp6405
Rp6406
(dp6407
g92
I12
sg93
I454
sg94
I54
sg95
g98
sg99
I1850
sbasbasbag0
(g19
g2
Ntp6408
Rp6409
(dp6410
g23
g85
sg29
(lp6411
g0
(g87
g25
Vserial
p6412
tp6413
Rp6414
(dp6415
g92
I19
sg93
I456
sg94
I54
sg95
g98
sg99
I1857
sbasbasbag0
(g19
g2
Ntp6416
Rp6417
(dp6418
g23
g0
(g24
g25
Vemits
p6419
tp6420
Rp6421
sg29
(lp6422
g0
(g19
g2
Ntp6423
Rp6424
(dp6425
g23
g85
sg29
(lp6426
g0
(g87
g25
VIRQ3
p6427
tp6428
Rp6429
(dp6430
g92
I9
sg93
I463
sg94
I55
sg95
g98
sg99
I1874
sbasbag0
(g19
g2
Ntp6431
Rp6432
(dp6433
g23
g85
sg29
(lp6434
g0
(g87
g25
Vserial_irq
p6435
tp6436
Rp6437
(dp6438
g92
I14
sg93
I465
sg94
I55
sg95
g98
sg99
I1879
sbasbasbasbasbsg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6439
sbsg977
Nsg1125
(g0
(ccamkes.ast.objects
Emits
p6440
g2
Ntp6441
Rp6442
(dp6443
g6
g6363
sg1012
g6429
sg7
g0
(g13
g2
Ntp6444
Rp6445
(dp6446
g17
I00
sg18
g6417
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6447
sbsg995
I01
sg987
g6437
sbtp6448
sg996
Nsg1126
I00
sg1127
(tsg987
g6379
sg6
g4
sg1128
I01
sg1129
(tsg1130
(g0
(g1131
g2
Ntp6449
Rp6450
(dp6451
g6
g6363
sg1012
g2896
sg7
g0
(g13
g2
Ntp6452
Rp6453
(dp6454
g17
I00
sg18
g6393
sg970
Nsg971
Nsg972
g4302
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000a\u000aconnector seL4GDB {\u000a  from Procedure template "seL4GDB-from.template.c" ;\u000a  to Procedure template "seL4GDB-to.template.c" ;\u000a}\u000aconnector seL4GDBMem {\u000a  from Procedure template "seL4GDBMem-from.template.c" ;\u000a  to Procedure template "seL4GDBMem-to.template.c" ;\u000a}\u000a\u000a\u000aprocedure GDB_delegate {\u000a    include <camkes/gdb/delegate_types.h>;\u000a    int read_memory(in seL4_Word addr, in seL4_Word length, out delegate_mem_range_t data);\u000a    int write_memory(in seL4_Word addr, in seL4_Word length, in delegate_mem_range_t data);\u000a    void read_registers(in seL4_Word tcb_cap, out seL4_UserContext registers);\u000a    void read_register(in seL4_Word tcb_cap, out seL4_Word reg, in seL4_Word reg_num);\u000a    int write_registers(in seL4_Word tcb_cap, in seL4_UserContext registers, in int len);\u000a    int write_register(in seL4_Word tcb_cap, in seL4_Word data, in seL4_Word reg_num);\u000a    int insert_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int remove_break(in seL4_Word tcb_cap, in seL4_Word type, in seL4_Word addr, in seL4_Word size, in seL4_Word rw);\u000a    int resume(in seL4_Word tcb_cap);\u000a    int step(in seL4_Word tcb_cap);\u000a};\u000a\u000aprocedure CAmkES_Debug { \u000a  void debug(inout int num); \u000a} \u000a\u000acomponent debug_server { \u000a  provides CAmkES_Debug client_fault; \u000a  uses IOPort serial_port; \u000a  uses GDB_delegate delegate; \u000a  consumes IRQ3 serial_irq; \u000a  has binary_semaphore b;\u000a  has mutex serial;\u000a\u000a} \u000acomponent debug_serial { \u000a  hardware; \u000a  provides IOPort serial; \u000a  emits IRQ3 serial_irq; \u000a}\u000a
p6455
sbsg995
I01
sg987
g6414
sbtp6456
sg1425
(tsg990
(dp6457
g6414
g6450
sg6437
g6442
ssg2054
(tsg1428
(tsg2056
(tsg995
I01
sbg0
(g2622
g2
Ntp6458
Rp6459
(dp6460
g7
g0
(g13
g2
Ntp6461
Rp6462
(dp6463
g17
I00
sg18
g0
(g19
g2
Ntp6464
Rp6465
(dp6466
g23
g2634
sg29
(lp6467
g0
(g19
g2
Ntp6468
Rp6469
(dp6470
g23
g85
sg29
(lp6471
g0
(g87
g25
VseL4Notification
p6472
tp6473
Rp6474
(dp6475
g92
I11
sg93
I22
sg94
I51
sg95
g98
sg99
I1906
sbasbag0
(g19
g2
Ntp6476
Rp6477
(dp6478
g23
g2649
sg29
(lp6479
g0
(g19
g2
Ntp6480
Rp6481
(dp6482
g23
g2656
sg29
(lp6483
g0
(g87
g25
VEvent
p6484
tp6485
Rp6486
(dp6487
g92
I10
sg93
I29
sg94
I52
sg95
g0
(g24
g25
VEVENT_TYPE
p6488
tp6489
Rp6490
sg99
I1934
sbasbag0
(g19
g2
Ntp6491
Rp6492
(dp6493
g23
g2670
sg29
(lp6494
g0
(g19
g2
Ntp6495
Rp6496
(dp6497
g23
g2677
sg29
(lp6498
g0
(g19
g2
Ntp6499
Rp6500
(dp6501
g23
g2684
sg29
(lp6502
g0
(g19
g2
Ntp6503
Rp6504
(dp6505
g23
g2691
sg29
(lp6506
g0
(g19
g2
Ntp6507
Rp6508
(dp6509
g23
g2698
sg29
(lp6510
g0
(g19
g2
Ntp6511
Rp6512
(dp6513
g23
g2705
sg29
(lp6514
g0
(g19
g2
Ntp6515
Rp6516
(dp6517
g23
g2712
sg29
(lp6518
g0
(g19
g2
Ntp6519
Rp6520
(dp6521
g23
g2719
sg29
(lp6522
g0
(g19
g2
Ntp6523
Rp6524
(dp6525
g23
g2726
sg29
(lp6526
g0
(g19
g2
Ntp6527
Rp6528
(dp6529
g23
g2733
sg29
(lp6530
g0
(g19
g2
Ntp6531
Rp6532
(dp6533
g23
g2740
sg29
(lp6534
g0
(g19
g2
Ntp6535
Rp6536
(dp6537
g23
g2747
sg29
(lp6538
g0
(g87
g25
g2749
tp6539
Rp6540
(dp6541
g92
I21
sg93
I33
sg94
I52
sg95
g2753
sg99
I1945
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp6542
Rp6543
(dp6544
g23
g2656
sg29
(lp6545
g0
(g87
g25
VEvents
p6546
tp6547
Rp6548
(dp6549
g92
I8
sg93
I41
sg94
I53
sg95
g0
(g24
g25
VEVENTS_TYPE
p6550
tp6551
Rp6552
sg99
I1963
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6553
sbsg2767
I00
sg1428
(lp6554
sg2769
I0
sg987
g6474
sg6
g4
sg2770
I00
sg2771
VEvent
p6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I01
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp6556
Rp6557
(dp6558
g7
g0
(g13
g2
Ntp6559
Rp6560
(dp6561
g17
I00
sg18
g0
(g19
g2
Ntp6562
Rp6563
(dp6564
g23
g2634
sg29
(lp6565
g0
(g19
g2
Ntp6566
Rp6567
(dp6568
g23
g85
sg29
(lp6569
g0
(g87
g25
VseL4NotificationBind
p6570
tp6571
Rp6572
(dp6573
g92
I11
sg93
I48
sg94
I55
sg95
g98
sg99
I1983
sbasbag0
(g19
g2
Ntp6574
Rp6575
(dp6576
g23
g2649
sg29
(lp6577
g0
(g19
g2
Ntp6578
Rp6579
(dp6580
g23
g2656
sg29
(lp6581
g0
(g87
g25
VEvents
p6582
tp6583
Rp6584
(dp6585
g92
I10
sg93
I55
sg94
I56
sg95
g6552
sg99
I2015
sbasbag0
(g19
g2
Ntp6586
Rp6587
(dp6588
g23
g2670
sg29
(lp6589
g0
(g19
g2
Ntp6590
Rp6591
(dp6592
g23
g2677
sg29
(lp6593
g0
(g19
g2
Ntp6594
Rp6595
(dp6596
g23
g2684
sg29
(lp6597
g0
(g19
g2
Ntp6598
Rp6599
(dp6600
g23
g2691
sg29
(lp6601
g0
(g19
g2
Ntp6602
Rp6603
(dp6604
g23
g2698
sg29
(lp6605
g0
(g19
g2
Ntp6606
Rp6607
(dp6608
g23
g2705
sg29
(lp6609
g0
(g19
g2
Ntp6610
Rp6611
(dp6612
g23
g2712
sg29
(lp6613
g0
(g19
g2
Ntp6614
Rp6615
(dp6616
g23
g2719
sg29
(lp6617
g0
(g19
g2
Ntp6618
Rp6619
(dp6620
g23
g2726
sg29
(lp6621
g0
(g19
g2
Ntp6622
Rp6623
(dp6624
g23
g2733
sg29
(lp6625
g0
(g19
g2
Ntp6626
Rp6627
(dp6628
g23
g2740
sg29
(lp6629
g0
(g19
g2
Ntp6630
Rp6631
(dp6632
g23
g2747
sg29
(lp6633
g0
(g87
g25
g2749
tp6634
Rp6635
(dp6636
g92
I22
sg93
I59
sg94
I56
sg95
g2753
sg99
I2027
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp6637
Rp6638
(dp6639
g23
g2656
sg29
(lp6640
g0
(g87
g25
VEvent
p6641
tp6642
Rp6643
(dp6644
g92
I8
sg93
I67
sg94
I57
sg95
g6490
sg99
I2045
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6645
sbsg2767
I00
sg1428
(lp6646
sg2769
I0
sg987
g6572
sg6
g4
sg2770
I01
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp6647
Rp6648
(dp6649
g7
g0
(g13
g2
Ntp6650
Rp6651
(dp6652
g17
I00
sg18
g0
(g19
g2
Ntp6653
Rp6654
(dp6655
g23
g2634
sg29
(lp6656
g0
(g19
g2
Ntp6657
Rp6658
(dp6659
g23
g85
sg29
(lp6660
g0
(g87
g25
VseL4NotificationQueue
p6661
tp6662
Rp6663
(dp6664
g92
I11
sg93
I74
sg94
I59
sg95
g98
sg99
I2064
sbasbag0
(g19
g2
Ntp6665
Rp6666
(dp6667
g23
g2649
sg29
(lp6668
g0
(g19
g2
Ntp6669
Rp6670
(dp6671
g23
g2656
sg29
(lp6672
g0
(g87
g25
VEvent
p6673
tp6674
Rp6675
(dp6676
g92
I10
sg93
I81
sg94
I60
sg95
g6490
sg99
I2097
sbasbag0
(g19
g2
Ntp6677
Rp6678
(dp6679
g23
g2670
sg29
(lp6680
g0
(g19
g2
Ntp6681
Rp6682
(dp6683
g23
g2677
sg29
(lp6684
g0
(g19
g2
Ntp6685
Rp6686
(dp6687
g23
g2684
sg29
(lp6688
g0
(g19
g2
Ntp6689
Rp6690
(dp6691
g23
g2691
sg29
(lp6692
g0
(g19
g2
Ntp6693
Rp6694
(dp6695
g23
g2698
sg29
(lp6696
g0
(g19
g2
Ntp6697
Rp6698
(dp6699
g23
g2705
sg29
(lp6700
g0
(g19
g2
Ntp6701
Rp6702
(dp6703
g23
g2712
sg29
(lp6704
g0
(g19
g2
Ntp6705
Rp6706
(dp6707
g23
g2719
sg29
(lp6708
g0
(g19
g2
Ntp6709
Rp6710
(dp6711
g23
g2726
sg29
(lp6712
g0
(g19
g2
Ntp6713
Rp6714
(dp6715
g23
g2733
sg29
(lp6716
g0
(g19
g2
Ntp6717
Rp6718
(dp6719
g23
g2740
sg29
(lp6720
g0
(g19
g2
Ntp6721
Rp6722
(dp6723
g23
g2747
sg29
(lp6724
g0
(g87
g25
g2749
tp6725
Rp6726
(dp6727
g92
I21
sg93
I85
sg94
I60
sg95
g2753
sg99
I2108
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp6728
Rp6729
(dp6730
g23
g2656
sg29
(lp6731
g0
(g87
g25
VEvents
p6732
tp6733
Rp6734
(dp6735
g92
I8
sg93
I93
sg94
I61
sg95
g6552
sg99
I2126
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6736
sbsg2767
I00
sg1428
(lp6737
sg2769
I0
sg987
g6663
sg6
g4
sg2770
I00
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I01
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp6738
Rp6739
(dp6740
g7
g0
(g13
g2
Ntp6741
Rp6742
(dp6743
g17
I00
sg18
g0
(g19
g2
Ntp6744
Rp6745
(dp6746
g23
g2634
sg29
(lp6747
g0
(g19
g2
Ntp6748
Rp6749
(dp6750
g23
g85
sg29
(lp6751
g0
(g87
g25
VseL4NotificationNative
p6752
tp6753
Rp6754
(dp6755
g92
I11
sg93
I100
sg94
I63
sg95
g98
sg99
I2146
sbasbag0
(g19
g2
Ntp6756
Rp6757
(dp6758
g23
g2649
sg29
(lp6759
g0
(g19
g2
Ntp6760
Rp6761
(dp6762
g23
g2656
sg29
(lp6763
g0
(g87
g25
VEvents
p6764
tp6765
Rp6766
(dp6767
g92
I10
sg93
I107
sg94
I64
sg95
g6552
sg99
I2180
sbasbag0
(g19
g2
Ntp6768
Rp6769
(dp6770
g23
g2670
sg29
(lp6771
g0
(g19
g2
Ntp6772
Rp6773
(dp6774
g23
g2677
sg29
(lp6775
g0
(g19
g2
Ntp6776
Rp6777
(dp6778
g23
g2684
sg29
(lp6779
g0
(g19
g2
Ntp6780
Rp6781
(dp6782
g23
g2691
sg29
(lp6783
g0
(g19
g2
Ntp6784
Rp6785
(dp6786
g23
g2698
sg29
(lp6787
g0
(g19
g2
Ntp6788
Rp6789
(dp6790
g23
g2705
sg29
(lp6791
g0
(g19
g2
Ntp6792
Rp6793
(dp6794
g23
g2712
sg29
(lp6795
g0
(g19
g2
Ntp6796
Rp6797
(dp6798
g23
g2719
sg29
(lp6799
g0
(g19
g2
Ntp6800
Rp6801
(dp6802
g23
g2726
sg29
(lp6803
g0
(g19
g2
Ntp6804
Rp6805
(dp6806
g23
g2733
sg29
(lp6807
g0
(g19
g2
Ntp6808
Rp6809
(dp6810
g23
g2740
sg29
(lp6811
g0
(g19
g2
Ntp6812
Rp6813
(dp6814
g23
g2747
sg29
(lp6815
g0
(g87
g25
g2749
tp6816
Rp6817
(dp6818
g92
I22
sg93
I111
sg94
I64
sg95
g2753
sg99
I2192
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp6819
Rp6820
(dp6821
g23
g2656
sg29
(lp6822
g0
(g87
g25
VEvent
p6823
tp6824
Rp6825
(dp6826
g92
I8
sg93
I119
sg94
I65
sg95
g6490
sg99
I2210
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6827
sbsg2767
I00
sg1428
(lp6828
sg2769
I0
sg987
g6754
sg6
g4
sg2770
I01
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp6829
Rp6830
(dp6831
g7
g0
(g13
g2
Ntp6832
Rp6833
(dp6834
g17
I00
sg18
g0
(g19
g2
Ntp6835
Rp6836
(dp6837
g23
g2634
sg29
(lp6838
g0
(g19
g2
Ntp6839
Rp6840
(dp6841
g23
g85
sg29
(lp6842
g0
(g87
g25
VseL4RPCEvent
p6843
tp6844
Rp6845
(dp6846
g92
I11
sg93
I129
sg94
I77
sg95
g98
sg99
I2616
sbasbag0
(g19
g2
Ntp6847
Rp6848
(dp6849
g23
g2649
sg29
(lp6850
g0
(g19
g2
Ntp6851
Rp6852
(dp6853
g23
g2656
sg29
(lp6854
g0
(g87
g25
VEvent
p6855
tp6856
Rp6857
(dp6858
g92
I10
sg93
I136
sg94
I78
sg95
g6490
sg99
I2640
sbasbag0
(g19
g2
Ntp6859
Rp6860
(dp6861
g23
g2656
sg29
(lp6862
g0
(g87
g25
VEvent
p6863
tp6864
Rp6865
(dp6866
g92
I8
sg93
I142
sg94
I79
sg95
g6490
sg99
I2654
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6867
sbsg2767
I00
sg1428
(lp6868
sg2769
I1
sg987
g6845
sg6
g4
sg2770
I00
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp6869
Rp6870
(dp6871
g7
g0
(g13
g2
Ntp6872
Rp6873
(dp6874
g17
I00
sg18
g0
(g19
g2
Ntp6875
Rp6876
(dp6877
g23
g2634
sg29
(lp6878
g0
(g19
g2
Ntp6879
Rp6880
(dp6881
g23
g85
sg29
(lp6882
g0
(g87
g25
VseL4RPC
p6883
tp6884
Rp6885
(dp6886
g92
I11
sg93
I152
sg94
I89
sg95
g98
sg99
I2866
sbasbag0
(g19
g2
Ntp6887
Rp6888
(dp6889
g23
g2649
sg29
(lp6890
g0
(g19
g2
Ntp6891
Rp6892
(dp6893
g23
g2656
sg29
(lp6894
g0
(g87
g25
VProcedure
p6895
tp6896
Rp6897
(dp6898
g92
I10
sg93
I159
sg94
I90
sg95
g2764
sg99
I2885
sbasbag0
(g19
g2
Ntp6899
Rp6900
(dp6901
g23
g2670
sg29
(lp6902
g0
(g19
g2
Ntp6903
Rp6904
(dp6905
g23
g2677
sg29
(lp6906
g0
(g19
g2
Ntp6907
Rp6908
(dp6909
g23
g2684
sg29
(lp6910
g0
(g19
g2
Ntp6911
Rp6912
(dp6913
g23
g2691
sg29
(lp6914
g0
(g19
g2
Ntp6915
Rp6916
(dp6917
g23
g2698
sg29
(lp6918
g0
(g19
g2
Ntp6919
Rp6920
(dp6921
g23
g2705
sg29
(lp6922
g0
(g19
g2
Ntp6923
Rp6924
(dp6925
g23
g2712
sg29
(lp6926
g0
(g19
g2
Ntp6927
Rp6928
(dp6929
g23
g2719
sg29
(lp6930
g0
(g19
g2
Ntp6931
Rp6932
(dp6933
g23
g2726
sg29
(lp6934
g0
(g19
g2
Ntp6935
Rp6936
(dp6937
g23
g2733
sg29
(lp6938
g0
(g19
g2
Ntp6939
Rp6940
(dp6941
g23
g2740
sg29
(lp6942
g0
(g19
g2
Ntp6943
Rp6944
(dp6945
g23
g2747
sg29
(lp6946
g0
(g87
g25
g2749
tp6947
Rp6948
(dp6949
g92
I25
sg93
I163
sg94
I90
sg95
g2753
sg99
I2900
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp6950
Rp6951
(dp6952
g23
g2656
sg29
(lp6953
g0
(g87
g25
VProcedure
p6954
tp6955
Rp6956
(dp6957
g92
I8
sg93
I171
sg94
I91
sg95
g2764
sg99
I2918
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p6958
sbsg2767
I00
sg1428
(lp6959
sg2769
I0
sg987
g6885
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
Nsg2775
g2772
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg2624
g0
(g2622
g2
Ntp6960
Rp6961
(dp6962
g7
g0
(g13
g2
Ntp6963
Rp6964
(dp6965
g17
I00
sg18
g0
(g19
g2
Ntp6966
Rp6967
(dp6968
g23
g2634
sg29
(lp6969
g0
(g19
g2
Ntp6970
Rp6971
(dp6972
g23
g85
sg29
(lp6973
g0
(g87
g25
VseL4RPCCallNoType
p6974
tp6975
Rp6976
(dp6977
g92
I11
sg93
I208
sg94
I100
sg95
g98
sg99
I3083
sbasbag0
(g19
g2
Ntp6978
Rp6979
(dp6980
g23
g2649
sg29
(lp6981
g0
(g19
g2
Ntp6982
Rp6983
(dp6984
g23
g2656
sg29
(lp6985
g0
(g87
g25
VProcedures
p6986
tp6987
Rp6988
(dp6989
g92
I10
sg93
I215
sg94
I101
sg95
g2664
sg99
I3112
sbasbag0
(g19
g2
Ntp6990
Rp6991
(dp6992
g23
g2670
sg29
(lp6993
g0
(g19
g2
Ntp6994
Rp6995
(dp6996
g23
g2677
sg29
(lp6997
g0
(g19
g2
Ntp6998
Rp6999
(dp7000
g23
g2684
sg29
(lp7001
g0
(g19
g2
Ntp7002
Rp7003
(dp7004
g23
g2691
sg29
(lp7005
g0
(g19
g2
Ntp7006
Rp7007
(dp7008
g23
g2698
sg29
(lp7009
g0
(g19
g2
Ntp7010
Rp7011
(dp7012
g23
g2705
sg29
(lp7013
g0
(g19
g2
Ntp7014
Rp7015
(dp7016
g23
g2712
sg29
(lp7017
g0
(g19
g2
Ntp7018
Rp7019
(dp7020
g23
g2719
sg29
(lp7021
g0
(g19
g2
Ntp7022
Rp7023
(dp7024
g23
g2726
sg29
(lp7025
g0
(g19
g2
Ntp7026
Rp7027
(dp7028
g23
g2733
sg29
(lp7029
g0
(g19
g2
Ntp7030
Rp7031
(dp7032
g23
g2740
sg29
(lp7033
g0
(g19
g2
Ntp7034
Rp7035
(dp7036
g23
g2747
sg29
(lp7037
g0
(g87
g25
g2749
tp7038
Rp7039
(dp7040
g92
I26
sg93
I219
sg94
I101
sg95
g2753
sg99
I3128
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp7041
Rp7042
(dp7043
g23
g2656
sg29
(lp7044
g0
(g87
g25
VProcedure
p7045
tp7046
Rp7047
(dp7048
g92
I8
sg93
I227
sg94
I102
sg95
g2764
sg99
I3146
sbasbag0
(g19
g2
Ntp7049
Rp7050
(dp7051
g23
g0
(g24
g25
Vattribute_decl
p7052
tp7053
Rp7054
sg29
(lp7055
g0
(g19
g2
Ntp7056
Rp7057
(dp7058
g23
g0
(g24
g25
Vattribute_scalar_parameter
p7059
tp7060
Rp7061
sg29
(lp7062
g0
(g19
g2
Ntp7063
Rp7064
(dp7065
g23
g1205
sg29
(lp7066
g0
(g19
g2
Ntp7067
Rp7068
(dp7069
g23
g2949
sg29
(lp7070
g0
(g19
g2
Ntp7071
Rp7072
(dp7073
g23
g78
sg29
(lp7074
g0
(g19
g2
Ntp7075
Rp7076
(dp7077
g23
g85
sg29
(lp7078
g0
(g87
g25
Vbool
p7079
tp7080
Rp7081
(dp7082
g92
I15
sg93
I233
sg94
I103
sg95
g98
sg99
I3171
sbasbasbasbasbag0
(g19
g2
Ntp7083
Rp7084
(dp7085
g23
g85
sg29
(lp7086
g0
(g87
g25
Vdisable_interface_type_checking
p7087
tp7088
Rp7089
(dp7090
g92
I20
sg93
I235
sg94
I103
sg95
g98
sg99
I3176
sbasbasbag0
(g19
g2
Ntp7091
Rp7092
(dp7093
g23
g2670
sg29
(lp7094
g0
(g19
g2
Ntp7095
Rp7096
(dp7097
g23
g2677
sg29
(lp7098
g0
(g19
g2
Ntp7099
Rp7100
(dp7101
g23
g2684
sg29
(lp7102
g0
(g19
g2
Ntp7103
Rp7104
(dp7105
g23
g2691
sg29
(lp7106
g0
(g19
g2
Ntp7107
Rp7108
(dp7109
g23
g2698
sg29
(lp7110
g0
(g19
g2
Ntp7111
Rp7112
(dp7113
g23
g2705
sg29
(lp7114
g0
(g19
g2
Ntp7115
Rp7116
(dp7117
g23
g2712
sg29
(lp7118
g0
(g19
g2
Ntp7119
Rp7120
(dp7121
g23
g2719
sg29
(lp7122
g0
(g19
g2
Ntp7123
Rp7124
(dp7125
g23
g2726
sg29
(lp7126
g0
(g19
g2
Ntp7127
Rp7128
(dp7129
g23
g2733
sg29
(lp7130
g0
(g19
g2
Ntp7131
Rp7132
(dp7133
g23
g2740
sg29
(lp7134
g0
(g19
g2
Ntp7135
Rp7136
(dp7137
g23
g0
(g24
g25
Vboolean_literal
p7138
tp7139
Rp7140
sg29
(lp7141
g0
(g87
g25
Vtrue
p7142
tp7143
Rp7144
(dp7145
g92
I54
sg93
I239
sg94
I103
sg95
g0
(g24
g25
VTRUE2
p7146
tp7147
Rp7148
sg99
I3210
sbasbasbasbasbasbasbasbasbasbasbasbasbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7149
sbsg2767
I00
sg1428
(lp7150
g0
(ccamkes.ast.objects
Attribute
p7151
g2
Ntp7152
Rp7153
(dp7154
g1012
g0
(ccamkes.ast.objects
Reference
p7155
g2
Ntp7156
Rp7157
(dp7158
g6
Nsg7
g0
(g13
g2
Ntp7159
Rp7160
(dp7161
g17
I00
sg18
g7068
sg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7162
sbsg95
ccamkes.ast.objects
Struct
p7163
sS'name'
p7164
(lp7165
g7081
asg995
I00
sbsg7
g0
(g13
g2
Ntp7166
Rp7167
(dp7168
g17
I00
sg18
g7050
sg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7169
sbsg987
g7089
sg6
NsS'_default'
p7170
I1
sg1378
I00
sS'child_fields'
p7171
(Vtype
p7172
tp7173
sg995
I00
sbasg2769
I0
sg987
g6976
sg6
g4
sg2770
I01
sg2771
g2772
sg2773
I1
sg2774
Nsg2775
g2772
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp7174
Rp7175
(dp7176
g7
g0
(g13
g2
Ntp7177
Rp7178
(dp7179
g17
I00
sg18
g0
(g19
g2
Ntp7180
Rp7181
(dp7182
g23
g2634
sg29
(lp7183
g0
(g19
g2
Ntp7184
Rp7185
(dp7186
g23
g85
sg29
(lp7187
g0
(g87
g25
VseL4DirectCall
p7188
tp7189
Rp7190
(dp7191
g92
I11
sg93
I249
sg94
I112
sg95
g98
sg99
I3399
sbasbag0
(g19
g2
Ntp7192
Rp7193
(dp7194
g23
g2649
sg29
(lp7195
g0
(g19
g2
Ntp7196
Rp7197
(dp7198
g23
g2656
sg29
(lp7199
g0
(g87
g25
VProcedure
p7200
tp7201
Rp7202
(dp7203
g92
I10
sg93
I256
sg94
I113
sg95
g2764
sg99
I3425
sbasbag0
(g19
g2
Ntp7204
Rp7205
(dp7206
g23
g2656
sg29
(lp7207
g0
(g87
g25
VProcedure
p7208
tp7209
Rp7210
(dp7211
g92
I8
sg93
I262
sg94
I114
sg95
g2764
sg99
I3443
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7212
sbsg2767
I00
sg1428
(lp7213
sg2769
I1
sg987
g7190
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
Nsg2775
g2772
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp7214
Rp7215
(dp7216
g7
g0
(g13
g2
Ntp7217
Rp7218
(dp7219
g17
I00
sg18
g0
(g19
g2
Ntp7220
Rp7221
(dp7222
g23
g2634
sg29
(lp7223
g0
(g19
g2
Ntp7224
Rp7225
(dp7226
g23
g85
sg29
(lp7227
g0
(g87
g25
VseL4SharedData
p7228
tp7229
Rp7230
(dp7231
g92
I11
sg93
I272
sg94
I125
sg95
g98
sg99
I3656
sbasbag0
(g19
g2
Ntp7232
Rp7233
(dp7234
g23
g2649
sg29
(lp7235
g0
(g19
g2
Ntp7236
Rp7237
(dp7238
g23
g2656
sg29
(lp7239
g0
(g87
g25
VDataports
p7240
tp7241
Rp7242
(dp7243
g92
I10
sg93
I279
sg94
I126
sg95
g0
(g24
g25
VDATAPORTS_TYPE
p7244
tp7245
Rp7246
sg99
I3682
sbasbag0
(g19
g2
Ntp7247
Rp7248
(dp7249
g23
g2670
sg29
(lp7250
g0
(g19
g2
Ntp7251
Rp7252
(dp7253
g23
g2677
sg29
(lp7254
g0
(g19
g2
Ntp7255
Rp7256
(dp7257
g23
g2684
sg29
(lp7258
g0
(g19
g2
Ntp7259
Rp7260
(dp7261
g23
g2691
sg29
(lp7262
g0
(g19
g2
Ntp7263
Rp7264
(dp7265
g23
g2698
sg29
(lp7266
g0
(g19
g2
Ntp7267
Rp7268
(dp7269
g23
g2705
sg29
(lp7270
g0
(g19
g2
Ntp7271
Rp7272
(dp7273
g23
g2712
sg29
(lp7274
g0
(g19
g2
Ntp7275
Rp7276
(dp7277
g23
g2719
sg29
(lp7278
g0
(g19
g2
Ntp7279
Rp7280
(dp7281
g23
g2726
sg29
(lp7282
g0
(g19
g2
Ntp7283
Rp7284
(dp7285
g23
g2733
sg29
(lp7286
g0
(g19
g2
Ntp7287
Rp7288
(dp7289
g23
g2740
sg29
(lp7290
g0
(g19
g2
Ntp7291
Rp7292
(dp7293
g23
g2747
sg29
(lp7294
g0
(g87
g25
g2749
tp7295
Rp7296
(dp7297
g92
I25
sg93
I283
sg94
I126
sg95
g2753
sg99
I3697
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp7298
Rp7299
(dp7300
g23
g2656
sg29
(lp7301
g0
(g87
g25
VDataports
p7302
tp7303
Rp7304
(dp7305
g92
I8
sg93
I291
sg94
I127
sg95
g7246
sg99
I3715
sbasbag0
(g19
g2
Ntp7306
Rp7307
(dp7308
g23
g2670
sg29
(lp7309
g0
(g19
g2
Ntp7310
Rp7311
(dp7312
g23
g2677
sg29
(lp7313
g0
(g19
g2
Ntp7314
Rp7315
(dp7316
g23
g2684
sg29
(lp7317
g0
(g19
g2
Ntp7318
Rp7319
(dp7320
g23
g2691
sg29
(lp7321
g0
(g19
g2
Ntp7322
Rp7323
(dp7324
g23
g2698
sg29
(lp7325
g0
(g19
g2
Ntp7326
Rp7327
(dp7328
g23
g2705
sg29
(lp7329
g0
(g19
g2
Ntp7330
Rp7331
(dp7332
g23
g2712
sg29
(lp7333
g0
(g19
g2
Ntp7334
Rp7335
(dp7336
g23
g2719
sg29
(lp7337
g0
(g19
g2
Ntp7338
Rp7339
(dp7340
g23
g2726
sg29
(lp7341
g0
(g19
g2
Ntp7342
Rp7343
(dp7344
g23
g2733
sg29
(lp7345
g0
(g19
g2
Ntp7346
Rp7347
(dp7348
g23
g2740
sg29
(lp7349
g0
(g19
g2
Ntp7350
Rp7351
(dp7352
g23
g2747
sg29
(lp7353
g0
(g87
g25
g2749
tp7354
Rp7355
(dp7356
g92
I23
sg93
I295
sg94
I127
sg95
g2753
sg99
I3730
sbasbasbasbasbasbasbasbasbasbasbasbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7357
sbsg2767
I00
sg1428
(lp7358
sg2769
I0
sg987
g7230
sg6
g4
sg2770
I01
sg2771
VDataport
p7359
sg2773
I0
sg2774
Nsg2775
g7359
sg2776
Nsg2777
I01
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp7360
Rp7361
(dp7362
g7
g0
(g13
g2
Ntp7363
Rp7364
(dp7365
g17
I00
sg18
g0
(g19
g2
Ntp7366
Rp7367
(dp7368
g23
g2634
sg29
(lp7369
g0
(g19
g2
Ntp7370
Rp7371
(dp7372
g23
g85
sg29
(lp7373
g0
(g87
g25
VseL4HardwareMMIO
p7374
tp7375
Rp7376
(dp7377
g92
I11
sg93
I307
sg94
I143
sg95
g98
sg99
I4275
sbasbag0
(g19
g2
Ntp7378
Rp7379
(dp7380
g23
g2649
sg29
(lp7381
g0
(g19
g2
Ntp7382
Rp7383
(dp7384
g23
g2656
sg29
(lp7385
g0
(g87
g25
VDataports
p7386
tp7387
Rp7388
(dp7389
g92
I10
sg93
I314
sg94
I144
sg95
g7246
sg99
I4303
sbasbag0
(g19
g2
Ntp7390
Rp7391
(dp7392
g23
g2670
sg29
(lp7393
g0
(g19
g2
Ntp7394
Rp7395
(dp7396
g23
g2677
sg29
(lp7397
g0
(g19
g2
Ntp7398
Rp7399
(dp7400
g23
g2684
sg29
(lp7401
g0
(g19
g2
Ntp7402
Rp7403
(dp7404
g23
g2691
sg29
(lp7405
g0
(g19
g2
Ntp7406
Rp7407
(dp7408
g23
g2698
sg29
(lp7409
g0
(g19
g2
Ntp7410
Rp7411
(dp7412
g23
g2705
sg29
(lp7413
g0
(g19
g2
Ntp7414
Rp7415
(dp7416
g23
g2712
sg29
(lp7417
g0
(g19
g2
Ntp7418
Rp7419
(dp7420
g23
g2719
sg29
(lp7421
g0
(g19
g2
Ntp7422
Rp7423
(dp7424
g23
g2726
sg29
(lp7425
g0
(g19
g2
Ntp7426
Rp7427
(dp7428
g23
g2733
sg29
(lp7429
g0
(g19
g2
Ntp7430
Rp7431
(dp7432
g23
g2740
sg29
(lp7433
g0
(g19
g2
Ntp7434
Rp7435
(dp7436
g23
g2747
sg29
(lp7437
g0
(g87
g25
g2749
tp7438
Rp7439
(dp7440
g92
I25
sg93
I318
sg94
I144
sg95
g2753
sg99
I4318
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp7441
Rp7442
(dp7443
g23
g0
(g24
g25
Vhardware_bare
p7444
tp7445
Rp7446
sg29
(lp7447
g0
(g87
g25
Vhardware
p7448
tp7449
Rp7450
(dp7451
g92
I8
sg93
I326
sg94
I145
sg95
g0
(g24
g25
VHARDWARE
p7452
tp7453
Rp7454
sg99
I4336
sbasbag0
(g19
g2
Ntp7455
Rp7456
(dp7457
g23
g2656
sg29
(lp7458
g0
(g87
g25
VDataport
p7459
tp7460
Rp7461
(dp7462
g92
I17
sg93
I328
sg94
I145
sg95
g0
(g24
g25
VDATAPORT_TYPE
p7463
tp7464
Rp7465
sg99
I4345
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7466
sbsg2767
I00
sg1428
(lp7467
sg2769
I0
sg987
g7376
sg6
g4
sg2770
I01
sg2771
g7359
sg2773
I1
sg2774
Nsg2775
g7359
sg2776
Nsg2777
I00
sg2778
I01
sg995
I01
sbg0
(g2622
g2
Ntp7468
Rp7469
(dp7470
g7
g0
(g13
g2
Ntp7471
Rp7472
(dp7473
g17
I00
sg18
g0
(g19
g2
Ntp7474
Rp7475
(dp7476
g23
g2634
sg29
(lp7477
g0
(g19
g2
Ntp7478
Rp7479
(dp7480
g23
g85
sg29
(lp7481
g0
(g87
g25
VseL4HardwareInterrupt
p7482
tp7483
Rp7484
(dp7485
g92
I11
sg93
I338
sg94
I159
sg95
g98
sg99
I4806
sbasbag0
(g19
g2
Ntp7486
Rp7487
(dp7488
g23
g2649
sg29
(lp7489
g0
(g19
g2
Ntp7490
Rp7491
(dp7492
g23
g7446
sg29
(lp7493
g0
(g87
g25
Vhardware
p7494
tp7495
Rp7496
(dp7497
g92
I10
sg93
I345
sg94
I160
sg95
g7454
sg99
I4839
sbasbag0
(g19
g2
Ntp7498
Rp7499
(dp7500
g23
g2656
sg29
(lp7501
g0
(g87
g25
VEvent
p7502
tp7503
Rp7504
(dp7505
g92
I19
sg93
I347
sg94
I160
sg95
g6490
sg99
I4848
sbasbag0
(g19
g2
Ntp7506
Rp7507
(dp7508
g23
g2656
sg29
(lp7509
g0
(g87
g25
VEvent
p7510
tp7511
Rp7512
(dp7513
g92
I8
sg93
I353
sg94
I161
sg95
g6490
sg99
I4862
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7514
sbsg2767
I01
sg1428
(lp7515
sg2769
I1
sg987
g7484
sg6
g4
sg2770
I00
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp7516
Rp7517
(dp7518
g7
g0
(g13
g2
Ntp7519
Rp7520
(dp7521
g17
I00
sg18
g0
(g19
g2
Ntp7522
Rp7523
(dp7524
g23
g2634
sg29
(lp7525
g0
(g19
g2
Ntp7526
Rp7527
(dp7528
g23
g85
sg29
(lp7529
g0
(g87
g25
VseL4IOAPICHardwareInterrupt
p7530
tp7531
Rp7532
(dp7533
g92
I11
sg93
I360
sg94
I163
sg95
g98
sg99
I4881
sbasbag0
(g19
g2
Ntp7534
Rp7535
(dp7536
g23
g2649
sg29
(lp7537
g0
(g19
g2
Ntp7538
Rp7539
(dp7540
g23
g7446
sg29
(lp7541
g0
(g87
g25
Vhardware
p7542
tp7543
Rp7544
(dp7545
g92
I10
sg93
I367
sg94
I164
sg95
g7454
sg99
I4920
sbasbag0
(g19
g2
Ntp7546
Rp7547
(dp7548
g23
g2656
sg29
(lp7549
g0
(g87
g25
VEvent
p7550
tp7551
Rp7552
(dp7553
g92
I19
sg93
I369
sg94
I164
sg95
g6490
sg99
I4929
sbasbag0
(g19
g2
Ntp7554
Rp7555
(dp7556
g23
g2656
sg29
(lp7557
g0
(g87
g25
VEvent
p7558
tp7559
Rp7560
(dp7561
g92
I8
sg93
I375
sg94
I165
sg95
g6490
sg99
I4943
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7562
sbsg2767
I01
sg1428
(lp7563
sg2769
I1
sg987
g7532
sg6
g4
sg2770
I00
sg2771
g6555
sg2773
I1
sg2774
Nsg2775
g6555
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg0
(g2622
g2
Ntp7564
Rp7565
(dp7566
g7
g0
(g13
g2
Ntp7567
Rp7568
(dp7569
g17
I00
sg18
g0
(g19
g2
Ntp7570
Rp7571
(dp7572
g23
g2634
sg29
(lp7573
g0
(g19
g2
Ntp7574
Rp7575
(dp7576
g23
g85
sg29
(lp7577
g0
(g87
g25
VseL4HardwareIOPort
p7578
tp7579
Rp7580
(dp7581
g92
I11
sg93
I385
sg94
I195
sg95
g98
sg99
I5818
sbasbag0
(g19
g2
Ntp7582
Rp7583
(dp7584
g23
g2649
sg29
(lp7585
g0
(g19
g2
Ntp7586
Rp7587
(dp7588
g23
g2656
sg29
(lp7589
g0
(g87
g25
VProcedure
p7590
tp7591
Rp7592
(dp7593
g92
I10
sg93
I392
sg94
I196
sg95
g2764
sg99
I5848
sbasbag0
(g19
g2
Ntp7594
Rp7595
(dp7596
g23
g2670
sg29
(lp7597
g0
(g19
g2
Ntp7598
Rp7599
(dp7600
g23
g2677
sg29
(lp7601
g0
(g19
g2
Ntp7602
Rp7603
(dp7604
g23
g2684
sg29
(lp7605
g0
(g19
g2
Ntp7606
Rp7607
(dp7608
g23
g2691
sg29
(lp7609
g0
(g19
g2
Ntp7610
Rp7611
(dp7612
g23
g2698
sg29
(lp7613
g0
(g19
g2
Ntp7614
Rp7615
(dp7616
g23
g2705
sg29
(lp7617
g0
(g19
g2
Ntp7618
Rp7619
(dp7620
g23
g2712
sg29
(lp7621
g0
(g19
g2
Ntp7622
Rp7623
(dp7624
g23
g2719
sg29
(lp7625
g0
(g19
g2
Ntp7626
Rp7627
(dp7628
g23
g2726
sg29
(lp7629
g0
(g19
g2
Ntp7630
Rp7631
(dp7632
g23
g2733
sg29
(lp7633
g0
(g19
g2
Ntp7634
Rp7635
(dp7636
g23
g2740
sg29
(lp7637
g0
(g19
g2
Ntp7638
Rp7639
(dp7640
g23
g2747
sg29
(lp7641
g0
(g87
g25
g2749
tp7642
Rp7643
(dp7644
g92
I25
sg93
I396
sg94
I196
sg95
g2753
sg99
I5863
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp7645
Rp7646
(dp7647
g23
g7446
sg29
(lp7648
g0
(g87
g25
Vhardware
p7649
tp7650
Rp7651
(dp7652
g92
I8
sg93
I404
sg94
I197
sg95
g7454
sg99
I5881
sbasbag0
(g19
g2
Ntp7653
Rp7654
(dp7655
g23
g2656
sg29
(lp7656
g0
(g87
g25
VProcedure
p7657
tp7658
Rp7659
(dp7660
g92
I17
sg93
I406
sg94
I197
sg95
g2764
sg99
I5890
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7661
sbsg2767
I00
sg1428
(lp7662
sg2769
I0
sg987
g7580
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
Nsg2775
g2772
sg2776
Nsg2777
I00
sg2778
I01
sg995
I01
sbg0
(g2622
g2
Ntp7663
Rp7664
(dp7665
g7
g0
(g13
g2
Ntp7666
Rp7667
(dp7668
g17
I00
sg18
g0
(g19
g2
Ntp7669
Rp7670
(dp7671
g23
g2634
sg29
(lp7672
g0
(g19
g2
Ntp7673
Rp7674
(dp7675
g23
g85
sg29
(lp7676
g0
(g87
g25
VseL4RPCSimple
p7677
tp7678
Rp7679
(dp7680
g92
I11
sg93
I416
sg94
I204
sg95
g98
sg99
I6130
sbasbag0
(g19
g2
Ntp7681
Rp7682
(dp7683
g23
g2649
sg29
(lp7684
g0
(g19
g2
Ntp7685
Rp7686
(dp7687
g23
g2656
sg29
(lp7688
g0
(g87
g25
VProcedure
p7689
tp7690
Rp7691
(dp7692
g92
I10
sg93
I423
sg94
I205
sg95
g2764
sg99
I6155
sbasbag0
(g19
g2
Ntp7693
Rp7694
(dp7695
g23
g2670
sg29
(lp7696
g0
(g19
g2
Ntp7697
Rp7698
(dp7699
g23
g2677
sg29
(lp7700
g0
(g19
g2
Ntp7701
Rp7702
(dp7703
g23
g2684
sg29
(lp7704
g0
(g19
g2
Ntp7705
Rp7706
(dp7707
g23
g2691
sg29
(lp7708
g0
(g19
g2
Ntp7709
Rp7710
(dp7711
g23
g2698
sg29
(lp7712
g0
(g19
g2
Ntp7713
Rp7714
(dp7715
g23
g2705
sg29
(lp7716
g0
(g19
g2
Ntp7717
Rp7718
(dp7719
g23
g2712
sg29
(lp7720
g0
(g19
g2
Ntp7721
Rp7722
(dp7723
g23
g2719
sg29
(lp7724
g0
(g19
g2
Ntp7725
Rp7726
(dp7727
g23
g2726
sg29
(lp7728
g0
(g19
g2
Ntp7729
Rp7730
(dp7731
g23
g2733
sg29
(lp7732
g0
(g19
g2
Ntp7733
Rp7734
(dp7735
g23
g2740
sg29
(lp7736
g0
(g19
g2
Ntp7737
Rp7738
(dp7739
g23
g2747
sg29
(lp7740
g0
(g87
g25
g2749
tp7741
Rp7742
(dp7743
g92
I25
sg93
I427
sg94
I205
sg95
g2753
sg99
I6170
sbasbasbasbasbasbasbasbasbasbasbasbasbag0
(g19
g2
Ntp7744
Rp7745
(dp7746
g23
g2656
sg29
(lp7747
g0
(g87
g25
VProcedure
p7748
tp7749
Rp7750
(dp7751
g92
I8
sg93
I435
sg94
I206
sg95
g2764
sg99
I6188
sbasbasbasbsg970
Nsg971
Nsg972
g2765
sg974
Nsg975
V/*\u000a * Copyright 2017, Data61\u000a * Commonwealth Scientific and Industrial Research Organisation (CSIRO)\u000a * ABN 41 687 119 230.\u000a *\u000a * This software may be distributed and modified according to the terms of\u000a * the BSD 2-Clause license. Note that NO WARRANTY is provided.\u000a * See "LICENSE_BSD2.txt" for details.\u000a *\u000a * @TAG(DATA61_BSD)\u000a */\u000a\u000aimport "camkes-hardware.idl4";\u000aimport "gdb-delegate.camkes";\u000a\u000a/**\u000a * @file\u000a *\u000a * This file defines a list of connectors. A connection is an instance of a\u000a * connector, allowing two components to communicate with each other.\u000a * Different connectors are used for different purposes.\u000a *\u000a * In essence, a connector defines how exactly a component connects to another\u000a * component. There are two parts, from and to. Most of the connectors are\u000a * defined such that the "from" component sends data to the "to" component. So\u000a * the "from" component is more like a sender and the "to" component is like a\u000a * receiver. Having said that, a totally different semantic can be implemented.\u000a * It's really up to the programmer to decide it.\u000a *\u000a * To use the connector, you define it like this:\u000a *\u000a *    connection RPC util_fatfs_FS(from util.fs, to fatfs.fs);\u000a *\u000a * where the util_fatfs_FS connection is an instance of the RPC connector. It\u000a * connects util.fs interface to fatfs.fs interface.\u000a */\u000a\u000a/**\u000a * Asynchronous event connector\u000a *\u000a * Once the connection has been established, the consumer could wait for\u000a * asynchronous signal sending from the emitter. The waiting process can be\u000a * blocked or non-blocked. The sending process is non-blocked, that is the\u000a * emitter can send data at any time and at any rate.\u000a *\u000a * One of the advantages of this connector is if the consumer executes much\u000a * faster than the emitter. The consumer could do other stuff while waiting for\u000a * the asynchronous signal from the emitter. However it's harder to synchronize\u000a * the components.\u000a */\u000aconnector seL4Notification {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationBind {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000aconnector seL4NotificationQueue {\u000a    from Event with 0 threads;\u000a    to Events;\u000a}\u000aconnector seL4NotificationNative {\u000a    from Events with 0 threads;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Asynchronous RPC event connector\u000a *\u000a * This connector works exactly the same as the asynchronous event connector.\u000a * The consumer and emitter shouldn't notice any difference. But the internal\u000a * implementation is different. seL4Notification uses the asynchronous\u000a * mechanism to send signal, whereas seL4RPCEvent uses the regular RPC\u000a * to send and imitate the event signal.\u000a */\u000aconnector seL4RPCEvent {\u000a    from Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * RPC connector\u000a *\u000a * Once the connection has been established, the user could wait for regular\u000a * RPC signal sending from the provider. The sending and waiting phase are\u000a * blocked.\u000a */\u000aconnector seL4RPC {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000aconnector seL4RPCCall {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a}\u000a\u000a/* Same as seL4RPCCall, except has relaxed type checking */\u000aconnector seL4RPCCallNoType {\u000a    from Procedures with 0 threads;\u000a    to Procedure;\u000a    attribute bool disable_interface_type_checking = true;\u000a}\u000a\u000a/**\u000a * Direct Call connector\u000a *\u000a * Situates both components in the same protection domain, so that interface\u000a * calls are backed by function calls, rather than RPCs.\u000a */\u000aconnector seL4DirectCall {\u000a    from Procedure;\u000a    to Procedure;\u000a}\u000a\u000a/**\u000a * Dataport connector\u000a *\u000a * This connector allows memory sharing between two components.\u000a *\u000a * The dataport size is not defined in this connector, it's up to the\u000a * implementation.\u000a */\u000aconnector seL4SharedData {\u000a    from Dataports with 0 threads;\u000a    to Dataports with 0 threads;\u000a}\u000a\u000a/**\u000a * Hardware MMIO dataport connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * It also implies that the backing memory will be mapped uncached.\u000a *\u000a * The hardware_component_data dataport's attribute string should consist of\u000a * the physical address and size of the memory window, in the following format:\u000a * "0x<address>:0x<size>"\u000a */\u000aconnector seL4HardwareMMIO {\u000a    from Dataports with 0 threads;\u000a    to hardware Dataport;\u000a}\u000a\u000a/**\u000a * Hardware interrupt event connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_interrupt side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * The hardware_component_interrupt event's attribute string should consist of\u000a * the interrupt number, in either decimal or (with the "0x" prefix)\u000a * hexadecimal.\u000a */\u000aconnector seL4HardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000aconnector seL4IOAPICHardwareInterrupt {\u000a    from hardware Event;\u000a    to Event;\u000a}\u000a\u000a/**\u000a * Hardware IOPorts connector\u000a *\u000a * This connector has special behaviour: it designates the component on the\u000a * hardware_component_data side as fictitious, and represents a hardware\u000a * device. Code will therefore not be generated for that component.\u000a *\u000a * Note that by nature, this connector is ia32-specific.\u000a *\u000a * The attribute 'hardware_component_port_attributes' should be set to define the\u000a * the IOPort range needed, in the following format: "0x<first_port>:0x<last_port>".\u000a * The interface provided should be "IOPort". E.g.\u000a *  component foo {\u000a *      hardware;\u000a *      provides IOPort bar;\u000a *  }\u000a *  assembly {\u000a *      composition {\u000a *          component foo f;\u000a *          ...\u000a *          connection HardwareIOPort moo(from ..., to foo.bar);\u000a *      }\u000a *      configuration {\u000a *          foo.bar_attributes = "0x42:0x84";\u000a *      }\u000a *  }\u000a */\u000aconnector seL4HardwareIOPort {\u000a    from Procedure with 0 threads;\u000a    to hardware Procedure;\u000a}\u000a\u000a/* This connector is only capable of marshalling primitive values (no arrays,\u000a * strings, user-defined types, ...), but is designed to use variable\u000a * assignment rather than memcpys so as to be easier to verify.\u000a */\u000aconnector seL4RPCSimple {\u000a    from Procedure with 0 threads;\u000a    to Procedure;\u000a}\u000a
p7752
sbsg2767
I00
sg1428
(lp7753
sg2769
I0
sg987
g7679
sg6
g4
sg2770
I00
sg2771
g2772
sg2773
I1
sg2774
Nsg2775
g2772
sg2776
Nsg2777
I00
sg2778
I00
sg995
I01
sbg1853
g1441
g1137
g2166
g2353
g1015
g2066
g2488
g11
tp7754
sbc__builtin__
set
p7755
((lp7756
g2160
ag2006
ag2586
ag2287
ag2765
ag973
ag2454
ag4302
ag1754
ag3978
ag1123
ag1360
atp7757
Rp7758
tp7759
.